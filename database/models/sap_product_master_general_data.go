// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SapProductMasterGeneralDatum is an object representing the database table.
type SapProductMasterGeneralDatum struct {
	Product                       string      `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	IndustrySector                null.String `boil:"IndustrySector" json:"IndustrySector,omitempty" toml:"IndustrySector" yaml:"IndustrySector,omitempty"`
	ProductType                   null.String `boil:"ProductType" json:"ProductType,omitempty" toml:"ProductType" yaml:"ProductType,omitempty"`
	BaseUnit                      null.String `boil:"BaseUnit" json:"BaseUnit,omitempty" toml:"BaseUnit" yaml:"BaseUnit,omitempty"`
	ValidityStartDate             null.String `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ProductGroup                  null.String `boil:"ProductGroup" json:"ProductGroup,omitempty" toml:"ProductGroup" yaml:"ProductGroup,omitempty"`
	Division                      null.String `boil:"Division" json:"Division,omitempty" toml:"Division" yaml:"Division,omitempty"`
	GrossWeight                   null.String `boil:"GrossWeight" json:"GrossWeight,omitempty" toml:"GrossWeight" yaml:"GrossWeight,omitempty"`
	WeightUnit                    null.String `boil:"WeightUnit" json:"WeightUnit,omitempty" toml:"WeightUnit" yaml:"WeightUnit,omitempty"`
	SizeOrDimensionText           null.String `boil:"SizeOrDimensionText" json:"SizeOrDimensionText,omitempty" toml:"SizeOrDimensionText" yaml:"SizeOrDimensionText,omitempty"`
	IndustryStandardName          null.String `boil:"IndustryStandardName" json:"IndustryStandardName,omitempty" toml:"IndustryStandardName" yaml:"IndustryStandardName,omitempty"`
	ProductStandardID             null.String `boil:"ProductStandardID" json:"ProductStandardID,omitempty" toml:"ProductStandardID" yaml:"ProductStandardID,omitempty"`
	InternationalArticleNumberCat null.String `boil:"InternationalArticleNumberCat" json:"InternationalArticleNumberCat,omitempty" toml:"InternationalArticleNumberCat" yaml:"InternationalArticleNumberCat,omitempty"`
	CreationDate                  null.String `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	LastChangeDate                null.String `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	IsMarkedForDeletion           null.Bool   `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`
	NetWeight                     null.String `boil:"NetWeight" json:"NetWeight,omitempty" toml:"NetWeight" yaml:"NetWeight,omitempty"`
	ChangeNumber                  null.String `boil:"ChangeNumber" json:"ChangeNumber,omitempty" toml:"ChangeNumber" yaml:"ChangeNumber,omitempty"`

	R *sapProductMasterGeneralDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L sapProductMasterGeneralDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SapProductMasterGeneralDatumColumns = struct {
	Product                       string
	IndustrySector                string
	ProductType                   string
	BaseUnit                      string
	ValidityStartDate             string
	ProductGroup                  string
	Division                      string
	GrossWeight                   string
	WeightUnit                    string
	SizeOrDimensionText           string
	IndustryStandardName          string
	ProductStandardID             string
	InternationalArticleNumberCat string
	CreationDate                  string
	LastChangeDate                string
	IsMarkedForDeletion           string
	NetWeight                     string
	ChangeNumber                  string
}{
	Product:                       "Product",
	IndustrySector:                "IndustrySector",
	ProductType:                   "ProductType",
	BaseUnit:                      "BaseUnit",
	ValidityStartDate:             "ValidityStartDate",
	ProductGroup:                  "ProductGroup",
	Division:                      "Division",
	GrossWeight:                   "GrossWeight",
	WeightUnit:                    "WeightUnit",
	SizeOrDimensionText:           "SizeOrDimensionText",
	IndustryStandardName:          "IndustryStandardName",
	ProductStandardID:             "ProductStandardID",
	InternationalArticleNumberCat: "InternationalArticleNumberCat",
	CreationDate:                  "CreationDate",
	LastChangeDate:                "LastChangeDate",
	IsMarkedForDeletion:           "IsMarkedForDeletion",
	NetWeight:                     "NetWeight",
	ChangeNumber:                  "ChangeNumber",
}

var SapProductMasterGeneralDatumTableColumns = struct {
	Product                       string
	IndustrySector                string
	ProductType                   string
	BaseUnit                      string
	ValidityStartDate             string
	ProductGroup                  string
	Division                      string
	GrossWeight                   string
	WeightUnit                    string
	SizeOrDimensionText           string
	IndustryStandardName          string
	ProductStandardID             string
	InternationalArticleNumberCat string
	CreationDate                  string
	LastChangeDate                string
	IsMarkedForDeletion           string
	NetWeight                     string
	ChangeNumber                  string
}{
	Product:                       "sap_product_master_general_data.Product",
	IndustrySector:                "sap_product_master_general_data.IndustrySector",
	ProductType:                   "sap_product_master_general_data.ProductType",
	BaseUnit:                      "sap_product_master_general_data.BaseUnit",
	ValidityStartDate:             "sap_product_master_general_data.ValidityStartDate",
	ProductGroup:                  "sap_product_master_general_data.ProductGroup",
	Division:                      "sap_product_master_general_data.Division",
	GrossWeight:                   "sap_product_master_general_data.GrossWeight",
	WeightUnit:                    "sap_product_master_general_data.WeightUnit",
	SizeOrDimensionText:           "sap_product_master_general_data.SizeOrDimensionText",
	IndustryStandardName:          "sap_product_master_general_data.IndustryStandardName",
	ProductStandardID:             "sap_product_master_general_data.ProductStandardID",
	InternationalArticleNumberCat: "sap_product_master_general_data.InternationalArticleNumberCat",
	CreationDate:                  "sap_product_master_general_data.CreationDate",
	LastChangeDate:                "sap_product_master_general_data.LastChangeDate",
	IsMarkedForDeletion:           "sap_product_master_general_data.IsMarkedForDeletion",
	NetWeight:                     "sap_product_master_general_data.NetWeight",
	ChangeNumber:                  "sap_product_master_general_data.ChangeNumber",
}

// Generated where

var SapProductMasterGeneralDatumWhere = struct {
	Product                       whereHelperstring
	IndustrySector                whereHelpernull_String
	ProductType                   whereHelpernull_String
	BaseUnit                      whereHelpernull_String
	ValidityStartDate             whereHelpernull_String
	ProductGroup                  whereHelpernull_String
	Division                      whereHelpernull_String
	GrossWeight                   whereHelpernull_String
	WeightUnit                    whereHelpernull_String
	SizeOrDimensionText           whereHelpernull_String
	IndustryStandardName          whereHelpernull_String
	ProductStandardID             whereHelpernull_String
	InternationalArticleNumberCat whereHelpernull_String
	CreationDate                  whereHelpernull_String
	LastChangeDate                whereHelpernull_String
	IsMarkedForDeletion           whereHelpernull_Bool
	NetWeight                     whereHelpernull_String
	ChangeNumber                  whereHelpernull_String
}{
	Product:                       whereHelperstring{field: "`sap_product_master_general_data`.`Product`"},
	IndustrySector:                whereHelpernull_String{field: "`sap_product_master_general_data`.`IndustrySector`"},
	ProductType:                   whereHelpernull_String{field: "`sap_product_master_general_data`.`ProductType`"},
	BaseUnit:                      whereHelpernull_String{field: "`sap_product_master_general_data`.`BaseUnit`"},
	ValidityStartDate:             whereHelpernull_String{field: "`sap_product_master_general_data`.`ValidityStartDate`"},
	ProductGroup:                  whereHelpernull_String{field: "`sap_product_master_general_data`.`ProductGroup`"},
	Division:                      whereHelpernull_String{field: "`sap_product_master_general_data`.`Division`"},
	GrossWeight:                   whereHelpernull_String{field: "`sap_product_master_general_data`.`GrossWeight`"},
	WeightUnit:                    whereHelpernull_String{field: "`sap_product_master_general_data`.`WeightUnit`"},
	SizeOrDimensionText:           whereHelpernull_String{field: "`sap_product_master_general_data`.`SizeOrDimensionText`"},
	IndustryStandardName:          whereHelpernull_String{field: "`sap_product_master_general_data`.`IndustryStandardName`"},
	ProductStandardID:             whereHelpernull_String{field: "`sap_product_master_general_data`.`ProductStandardID`"},
	InternationalArticleNumberCat: whereHelpernull_String{field: "`sap_product_master_general_data`.`InternationalArticleNumberCat`"},
	CreationDate:                  whereHelpernull_String{field: "`sap_product_master_general_data`.`CreationDate`"},
	LastChangeDate:                whereHelpernull_String{field: "`sap_product_master_general_data`.`LastChangeDate`"},
	IsMarkedForDeletion:           whereHelpernull_Bool{field: "`sap_product_master_general_data`.`IsMarkedForDeletion`"},
	NetWeight:                     whereHelpernull_String{field: "`sap_product_master_general_data`.`NetWeight`"},
	ChangeNumber:                  whereHelpernull_String{field: "`sap_product_master_general_data`.`ChangeNumber`"},
}

// SapProductMasterGeneralDatumRels is where relationship names are stored.
var SapProductMasterGeneralDatumRels = struct {
}{}

// sapProductMasterGeneralDatumR is where relationships are stored.
type sapProductMasterGeneralDatumR struct {
}

// NewStruct creates a new relationship struct
func (*sapProductMasterGeneralDatumR) NewStruct() *sapProductMasterGeneralDatumR {
	return &sapProductMasterGeneralDatumR{}
}

// sapProductMasterGeneralDatumL is where Load methods for each relationship are stored.
type sapProductMasterGeneralDatumL struct{}

var (
	sapProductMasterGeneralDatumAllColumns            = []string{"Product", "IndustrySector", "ProductType", "BaseUnit", "ValidityStartDate", "ProductGroup", "Division", "GrossWeight", "WeightUnit", "SizeOrDimensionText", "IndustryStandardName", "ProductStandardID", "InternationalArticleNumberCat", "CreationDate", "LastChangeDate", "IsMarkedForDeletion", "NetWeight", "ChangeNumber"}
	sapProductMasterGeneralDatumColumnsWithoutDefault = []string{"Product", "IndustrySector", "ProductType", "BaseUnit", "ValidityStartDate", "ProductGroup", "Division", "GrossWeight", "WeightUnit", "SizeOrDimensionText", "IndustryStandardName", "ProductStandardID", "InternationalArticleNumberCat", "CreationDate", "LastChangeDate", "IsMarkedForDeletion", "NetWeight", "ChangeNumber"}
	sapProductMasterGeneralDatumColumnsWithDefault    = []string{}
	sapProductMasterGeneralDatumPrimaryKeyColumns     = []string{"Product"}
	sapProductMasterGeneralDatumGeneratedColumns      = []string{}
)

type (
	// SapProductMasterGeneralDatumSlice is an alias for a slice of pointers to SapProductMasterGeneralDatum.
	// This should almost always be used instead of []SapProductMasterGeneralDatum.
	SapProductMasterGeneralDatumSlice []*SapProductMasterGeneralDatum
	// SapProductMasterGeneralDatumHook is the signature for custom SapProductMasterGeneralDatum hook methods
	SapProductMasterGeneralDatumHook func(context.Context, boil.ContextExecutor, *SapProductMasterGeneralDatum) error

	sapProductMasterGeneralDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	sapProductMasterGeneralDatumType                 = reflect.TypeOf(&SapProductMasterGeneralDatum{})
	sapProductMasterGeneralDatumMapping              = queries.MakeStructMapping(sapProductMasterGeneralDatumType)
	sapProductMasterGeneralDatumPrimaryKeyMapping, _ = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, sapProductMasterGeneralDatumPrimaryKeyColumns)
	sapProductMasterGeneralDatumInsertCacheMut       sync.RWMutex
	sapProductMasterGeneralDatumInsertCache          = make(map[string]insertCache)
	sapProductMasterGeneralDatumUpdateCacheMut       sync.RWMutex
	sapProductMasterGeneralDatumUpdateCache          = make(map[string]updateCache)
	sapProductMasterGeneralDatumUpsertCacheMut       sync.RWMutex
	sapProductMasterGeneralDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var sapProductMasterGeneralDatumAfterSelectHooks []SapProductMasterGeneralDatumHook

var sapProductMasterGeneralDatumBeforeInsertHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterInsertHooks []SapProductMasterGeneralDatumHook

var sapProductMasterGeneralDatumBeforeUpdateHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterUpdateHooks []SapProductMasterGeneralDatumHook

var sapProductMasterGeneralDatumBeforeDeleteHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterDeleteHooks []SapProductMasterGeneralDatumHook

var sapProductMasterGeneralDatumBeforeUpsertHooks []SapProductMasterGeneralDatumHook
var sapProductMasterGeneralDatumAfterUpsertHooks []SapProductMasterGeneralDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SapProductMasterGeneralDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SapProductMasterGeneralDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SapProductMasterGeneralDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SapProductMasterGeneralDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SapProductMasterGeneralDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SapProductMasterGeneralDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range sapProductMasterGeneralDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSapProductMasterGeneralDatumHook registers your hook function for all future operations.
func AddSapProductMasterGeneralDatumHook(hookPoint boil.HookPoint, sapProductMasterGeneralDatumHook SapProductMasterGeneralDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		sapProductMasterGeneralDatumAfterSelectHooks = append(sapProductMasterGeneralDatumAfterSelectHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeInsertHook:
		sapProductMasterGeneralDatumBeforeInsertHooks = append(sapProductMasterGeneralDatumBeforeInsertHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterInsertHook:
		sapProductMasterGeneralDatumAfterInsertHooks = append(sapProductMasterGeneralDatumAfterInsertHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeUpdateHook:
		sapProductMasterGeneralDatumBeforeUpdateHooks = append(sapProductMasterGeneralDatumBeforeUpdateHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterUpdateHook:
		sapProductMasterGeneralDatumAfterUpdateHooks = append(sapProductMasterGeneralDatumAfterUpdateHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeDeleteHook:
		sapProductMasterGeneralDatumBeforeDeleteHooks = append(sapProductMasterGeneralDatumBeforeDeleteHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterDeleteHook:
		sapProductMasterGeneralDatumAfterDeleteHooks = append(sapProductMasterGeneralDatumAfterDeleteHooks, sapProductMasterGeneralDatumHook)
	case boil.BeforeUpsertHook:
		sapProductMasterGeneralDatumBeforeUpsertHooks = append(sapProductMasterGeneralDatumBeforeUpsertHooks, sapProductMasterGeneralDatumHook)
	case boil.AfterUpsertHook:
		sapProductMasterGeneralDatumAfterUpsertHooks = append(sapProductMasterGeneralDatumAfterUpsertHooks, sapProductMasterGeneralDatumHook)
	}
}

// One returns a single sapProductMasterGeneralDatum record from the query.
func (q sapProductMasterGeneralDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SapProductMasterGeneralDatum, error) {
	o := &SapProductMasterGeneralDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sap_product_master_general_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SapProductMasterGeneralDatum records from the query.
func (q sapProductMasterGeneralDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (SapProductMasterGeneralDatumSlice, error) {
	var o []*SapProductMasterGeneralDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to SapProductMasterGeneralDatum slice")
	}

	if len(sapProductMasterGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SapProductMasterGeneralDatum records in the query.
func (q sapProductMasterGeneralDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sap_product_master_general_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q sapProductMasterGeneralDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sap_product_master_general_data exists")
	}

	return count > 0, nil
}

// SapProductMasterGeneralData retrieves all the records using an executor.
func SapProductMasterGeneralData(mods ...qm.QueryMod) sapProductMasterGeneralDatumQuery {
	mods = append(mods, qm.From("`sap_product_master_general_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`sap_product_master_general_data`.*"})
	}

	return sapProductMasterGeneralDatumQuery{q}
}

// FindSapProductMasterGeneralDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSapProductMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, product string, selectCols ...string) (*SapProductMasterGeneralDatum, error) {
	sapProductMasterGeneralDatumObj := &SapProductMasterGeneralDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `sap_product_master_general_data` where `Product`=?", sel,
	)

	q := queries.Raw(query, product)

	err := q.Bind(ctx, exec, sapProductMasterGeneralDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sap_product_master_general_data")
	}

	if err = sapProductMasterGeneralDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return sapProductMasterGeneralDatumObj, err
	}

	return sapProductMasterGeneralDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SapProductMasterGeneralDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_product_master_general_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapProductMasterGeneralDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	sapProductMasterGeneralDatumInsertCacheMut.RLock()
	cache, cached := sapProductMasterGeneralDatumInsertCache[key]
	sapProductMasterGeneralDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumColumnsWithDefault,
			sapProductMasterGeneralDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `sap_product_master_general_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `sap_product_master_general_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `sap_product_master_general_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, sapProductMasterGeneralDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sap_product_master_general_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.Product,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_product_master_general_data")
	}

CacheNoHooks:
	if !cached {
		sapProductMasterGeneralDatumInsertCacheMut.Lock()
		sapProductMasterGeneralDatumInsertCache[key] = cache
		sapProductMasterGeneralDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SapProductMasterGeneralDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SapProductMasterGeneralDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	sapProductMasterGeneralDatumUpdateCacheMut.RLock()
	cache, cached := sapProductMasterGeneralDatumUpdateCache[key]
	sapProductMasterGeneralDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sap_product_master_general_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `sap_product_master_general_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, sapProductMasterGeneralDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, append(wl, sapProductMasterGeneralDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sap_product_master_general_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sap_product_master_general_data")
	}

	if !cached {
		sapProductMasterGeneralDatumUpdateCacheMut.Lock()
		sapProductMasterGeneralDatumUpdateCache[key] = cache
		sapProductMasterGeneralDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q sapProductMasterGeneralDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sap_product_master_general_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sap_product_master_general_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SapProductMasterGeneralDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `sap_product_master_general_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductMasterGeneralDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sapProductMasterGeneralDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sapProductMasterGeneralDatum")
	}
	return rowsAff, nil
}

var mySQLSapProductMasterGeneralDatumUniqueColumns = []string{
	"Product",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SapProductMasterGeneralDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sap_product_master_general_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(sapProductMasterGeneralDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSapProductMasterGeneralDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	sapProductMasterGeneralDatumUpsertCacheMut.RLock()
	cache, cached := sapProductMasterGeneralDatumUpsertCache[key]
	sapProductMasterGeneralDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumColumnsWithDefault,
			sapProductMasterGeneralDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			sapProductMasterGeneralDatumAllColumns,
			sapProductMasterGeneralDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert sap_product_master_general_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`sap_product_master_general_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `sap_product_master_general_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for sap_product_master_general_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(sapProductMasterGeneralDatumType, sapProductMasterGeneralDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for sap_product_master_general_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for sap_product_master_general_data")
	}

CacheNoHooks:
	if !cached {
		sapProductMasterGeneralDatumUpsertCacheMut.Lock()
		sapProductMasterGeneralDatumUpsertCache[key] = cache
		sapProductMasterGeneralDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SapProductMasterGeneralDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SapProductMasterGeneralDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no SapProductMasterGeneralDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), sapProductMasterGeneralDatumPrimaryKeyMapping)
	sql := "DELETE FROM `sap_product_master_general_data` WHERE `Product`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sap_product_master_general_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sap_product_master_general_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q sapProductMasterGeneralDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no sapProductMasterGeneralDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sap_product_master_general_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_product_master_general_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SapProductMasterGeneralDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(sapProductMasterGeneralDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `sap_product_master_general_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductMasterGeneralDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sapProductMasterGeneralDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sap_product_master_general_data")
	}

	if len(sapProductMasterGeneralDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SapProductMasterGeneralDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSapProductMasterGeneralDatum(ctx, exec, o.Product)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SapProductMasterGeneralDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SapProductMasterGeneralDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), sapProductMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `sap_product_master_general_data`.* FROM `sap_product_master_general_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, sapProductMasterGeneralDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SapProductMasterGeneralDatumSlice")
	}

	*o = slice

	return nil
}

// SapProductMasterGeneralDatumExists checks if the SapProductMasterGeneralDatum row exists.
func SapProductMasterGeneralDatumExists(ctx context.Context, exec boil.ContextExecutor, product string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `sap_product_master_general_data` where `Product`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, product)
	}
	row := exec.QueryRowContext(ctx, sql, product)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sap_product_master_general_data exists")
	}

	return exists, nil
}

// Exists checks if the SapProductMasterGeneralDatum row exists.
func (o *SapProductMasterGeneralDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return SapProductMasterGeneralDatumExists(ctx, exec, o.Product)
}
