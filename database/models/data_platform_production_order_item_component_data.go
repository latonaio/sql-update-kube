// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformProductionOrderItemComponentDatum is an object representing the database table.
type DataPlatformProductionOrderItemComponentDatum struct {
	ProductionOrder                                int          `boil:"ProductionOrder" json:"ProductionOrder" toml:"ProductionOrder" yaml:"ProductionOrder"`
	ProductionOrderItem                            int          `boil:"ProductionOrderItem" json:"ProductionOrderItem" toml:"ProductionOrderItem" yaml:"ProductionOrderItem"`
	BillOfMaterial                                 int          `boil:"BillOfMaterial" json:"BillOfMaterial" toml:"BillOfMaterial" yaml:"BillOfMaterial"`
	BillOfMaterialItem                             int          `boil:"BillOfMaterialItem" json:"BillOfMaterialItem" toml:"BillOfMaterialItem" yaml:"BillOfMaterialItem"`
	SupplyChainRelationshipID                      int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipDeliveryID              int          `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID"`
	SupplyChainRelationshipDeliveryPlantID         int          `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID"`
	SupplyChainRelationshipStockConfPlantID        int          `boil:"SupplyChainRelationshipStockConfPlantID" json:"SupplyChainRelationshipStockConfPlantID" toml:"SupplyChainRelationshipStockConfPlantID" yaml:"SupplyChainRelationshipStockConfPlantID"`
	ProductionPlantBusinessPartner                 int          `boil:"ProductionPlantBusinessPartner" json:"ProductionPlantBusinessPartner" toml:"ProductionPlantBusinessPartner" yaml:"ProductionPlantBusinessPartner"`
	ProductionPlant                                string       `boil:"ProductionPlant" json:"ProductionPlant" toml:"ProductionPlant" yaml:"ProductionPlant"`
	MRPArea                                        null.String  `boil:"MRPArea" json:"MRPArea,omitempty" toml:"MRPArea" yaml:"MRPArea,omitempty"`
	MRPController                                  null.String  `boil:"MRPController" json:"MRPController,omitempty" toml:"MRPController" yaml:"MRPController,omitempty"`
	ProductionVersion                              null.Int     `boil:"ProductionVersion" json:"ProductionVersion,omitempty" toml:"ProductionVersion" yaml:"ProductionVersion,omitempty"`
	ProductionVersionItem                          null.Int     `boil:"ProductionVersionItem" json:"ProductionVersionItem,omitempty" toml:"ProductionVersionItem" yaml:"ProductionVersionItem,omitempty"`
	ComponentProduct                               string       `boil:"ComponentProduct" json:"ComponentProduct" toml:"ComponentProduct" yaml:"ComponentProduct"`
	ComponentProductBuyer                          int          `boil:"ComponentProductBuyer" json:"ComponentProductBuyer" toml:"ComponentProductBuyer" yaml:"ComponentProductBuyer"`
	ComponentProductSeller                         int          `boil:"ComponentProductSeller" json:"ComponentProductSeller" toml:"ComponentProductSeller" yaml:"ComponentProductSeller"`
	ComponentProductDeliverToParty                 int          `boil:"ComponentProductDeliverToParty" json:"ComponentProductDeliverToParty" toml:"ComponentProductDeliverToParty" yaml:"ComponentProductDeliverToParty"`
	ComponentProductDeliverToPlant                 string       `boil:"ComponentProductDeliverToPlant" json:"ComponentProductDeliverToPlant" toml:"ComponentProductDeliverToPlant" yaml:"ComponentProductDeliverToPlant"`
	ComponentProductDeliverFromParty               int          `boil:"ComponentProductDeliverFromParty" json:"ComponentProductDeliverFromParty" toml:"ComponentProductDeliverFromParty" yaml:"ComponentProductDeliverFromParty"`
	ComponentProductDeliverFromPlant               string       `boil:"ComponentProductDeliverFromPlant" json:"ComponentProductDeliverFromPlant" toml:"ComponentProductDeliverFromPlant" yaml:"ComponentProductDeliverFromPlant"`
	ComponentProductBaseUnit                       string       `boil:"ComponentProductBaseUnit" json:"ComponentProductBaseUnit" toml:"ComponentProductBaseUnit" yaml:"ComponentProductBaseUnit"`
	ComponentProductDeliveryUnit                   string       `boil:"ComponentProductDeliveryUnit" json:"ComponentProductDeliveryUnit" toml:"ComponentProductDeliveryUnit" yaml:"ComponentProductDeliveryUnit"`
	ComponentProductRequirementDate                string       `boil:"ComponentProductRequirementDate" json:"ComponentProductRequirementDate" toml:"ComponentProductRequirementDate" yaml:"ComponentProductRequirementDate"`
	ComponentProductRequirementTime                string       `boil:"ComponentProductRequirementTime" json:"ComponentProductRequirementTime" toml:"ComponentProductRequirementTime" yaml:"ComponentProductRequirementTime"`
	ComponentProductRequiredQuantityInBaseUnit     float32      `boil:"ComponentProductRequiredQuantityInBaseUnit" json:"ComponentProductRequiredQuantityInBaseUnit" toml:"ComponentProductRequiredQuantityInBaseUnit" yaml:"ComponentProductRequiredQuantityInBaseUnit"`
	ComponentProductRequiredQuantityInDeliveryUnit float32      `boil:"ComponentProductRequiredQuantityInDeliveryUnit" json:"ComponentProductRequiredQuantityInDeliveryUnit" toml:"ComponentProductRequiredQuantityInDeliveryUnit" yaml:"ComponentProductRequiredQuantityInDeliveryUnit"`
	ComponentProductPlannedScrapInPercent          null.Float32 `boil:"ComponentProductPlannedScrapInPercent" json:"ComponentProductPlannedScrapInPercent,omitempty" toml:"ComponentProductPlannedScrapInPercent" yaml:"ComponentProductPlannedScrapInPercent,omitempty"`
	ComponentProductIsMarkedForBackflush           null.Bool    `boil:"ComponentProductIsMarkedForBackflush" json:"ComponentProductIsMarkedForBackflush,omitempty" toml:"ComponentProductIsMarkedForBackflush" yaml:"ComponentProductIsMarkedForBackflush,omitempty"`
	StockConfirmationBusinessPartner               int          `boil:"StockConfirmationBusinessPartner" json:"StockConfirmationBusinessPartner" toml:"StockConfirmationBusinessPartner" yaml:"StockConfirmationBusinessPartner"`
	StockConfirmationPlant                         string       `boil:"StockConfirmationPlant" json:"StockConfirmationPlant" toml:"StockConfirmationPlant" yaml:"StockConfirmationPlant"`
	StockConfirmationPlantStorageLocation          string       `boil:"StockConfirmationPlantStorageLocation" json:"StockConfirmationPlantStorageLocation" toml:"StockConfirmationPlantStorageLocation" yaml:"StockConfirmationPlantStorageLocation"`
	PlannedOrder                                   null.Int     `boil:"PlannedOrder" json:"PlannedOrder,omitempty" toml:"PlannedOrder" yaml:"PlannedOrder,omitempty"`
	PlannedOrderItem                               null.Int     `boil:"PlannedOrderItem" json:"PlannedOrderItem,omitempty" toml:"PlannedOrderItem" yaml:"PlannedOrderItem,omitempty"`
	BillOfMaterialItemText                         null.String  `boil:"BillOfMaterialItemText" json:"BillOfMaterialItemText,omitempty" toml:"BillOfMaterialItemText" yaml:"BillOfMaterialItemText,omitempty"`
	ComponentProductBatch                          null.String  `boil:"ComponentProductBatch" json:"ComponentProductBatch,omitempty" toml:"ComponentProductBatch" yaml:"ComponentProductBatch,omitempty"`
	ComponentProductBatchValidityStartDate         null.String  `boil:"ComponentProductBatchValidityStartDate" json:"ComponentProductBatchValidityStartDate,omitempty" toml:"ComponentProductBatchValidityStartDate" yaml:"ComponentProductBatchValidityStartDate,omitempty"`
	ComponentProductBatchValidityStartTime         null.String  `boil:"ComponentProductBatchValidityStartTime" json:"ComponentProductBatchValidityStartTime,omitempty" toml:"ComponentProductBatchValidityStartTime" yaml:"ComponentProductBatchValidityStartTime,omitempty"`
	ComponentProductBatchValidityEndDate           null.String  `boil:"ComponentProductBatchValidityEndDate" json:"ComponentProductBatchValidityEndDate,omitempty" toml:"ComponentProductBatchValidityEndDate" yaml:"ComponentProductBatchValidityEndDate,omitempty"`
	ComponentProductBatchValidityEndTime           null.String  `boil:"ComponentProductBatchValidityEndTime" json:"ComponentProductBatchValidityEndTime,omitempty" toml:"ComponentProductBatchValidityEndTime" yaml:"ComponentProductBatchValidityEndTime,omitempty"`
	ComponentProductCostingPolicy                  null.String  `boil:"ComponentProductCostingPolicy" json:"ComponentProductCostingPolicy,omitempty" toml:"ComponentProductCostingPolicy" yaml:"ComponentProductCostingPolicy,omitempty"`
	ComponentProductPriceUnitQuantity              null.Int     `boil:"ComponentProductPriceUnitQuantity" json:"ComponentProductPriceUnitQuantity,omitempty" toml:"ComponentProductPriceUnitQuantity" yaml:"ComponentProductPriceUnitQuantity,omitempty"`
	ComponentProductStandardPrice                  null.Float32 `boil:"ComponentProductStandardPrice" json:"ComponentProductStandardPrice,omitempty" toml:"ComponentProductStandardPrice" yaml:"ComponentProductStandardPrice,omitempty"`
	ComponentProductMovingAveragePrice             null.Float32 `boil:"ComponentProductMovingAveragePrice" json:"ComponentProductMovingAveragePrice,omitempty" toml:"ComponentProductMovingAveragePrice" yaml:"ComponentProductMovingAveragePrice,omitempty"`
	ComponentProductWithdrawnQuantity              null.Float32 `boil:"ComponentProductWithdrawnQuantity" json:"ComponentProductWithdrawnQuantity,omitempty" toml:"ComponentProductWithdrawnQuantity" yaml:"ComponentProductWithdrawnQuantity,omitempty"`
	CreationDate                                   string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                                   string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                                 string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                                 string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	ComponentProductAvailabilityIsNotChecked       null.Bool    `boil:"ComponentProductAvailabilityIsNotChecked" json:"ComponentProductAvailabilityIsNotChecked,omitempty" toml:"ComponentProductAvailabilityIsNotChecked" yaml:"ComponentProductAvailabilityIsNotChecked,omitempty"`
	IsReleased                                     null.Bool    `boil:"IsReleased" json:"IsReleased,omitempty" toml:"IsReleased" yaml:"IsReleased,omitempty"`
	IsLocked                                       null.Bool    `boil:"IsLocked" json:"IsLocked,omitempty" toml:"IsLocked" yaml:"IsLocked,omitempty"`
	IsCancelled                                    null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                            null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformProductionOrderItemComponentDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformProductionOrderItemComponentDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformProductionOrderItemComponentDatumColumns = struct {
	ProductionOrder                                string
	ProductionOrderItem                            string
	BillOfMaterial                                 string
	BillOfMaterialItem                             string
	SupplyChainRelationshipID                      string
	SupplyChainRelationshipDeliveryID              string
	SupplyChainRelationshipDeliveryPlantID         string
	SupplyChainRelationshipStockConfPlantID        string
	ProductionPlantBusinessPartner                 string
	ProductionPlant                                string
	MRPArea                                        string
	MRPController                                  string
	ProductionVersion                              string
	ProductionVersionItem                          string
	ComponentProduct                               string
	ComponentProductBuyer                          string
	ComponentProductSeller                         string
	ComponentProductDeliverToParty                 string
	ComponentProductDeliverToPlant                 string
	ComponentProductDeliverFromParty               string
	ComponentProductDeliverFromPlant               string
	ComponentProductBaseUnit                       string
	ComponentProductDeliveryUnit                   string
	ComponentProductRequirementDate                string
	ComponentProductRequirementTime                string
	ComponentProductRequiredQuantityInBaseUnit     string
	ComponentProductRequiredQuantityInDeliveryUnit string
	ComponentProductPlannedScrapInPercent          string
	ComponentProductIsMarkedForBackflush           string
	StockConfirmationBusinessPartner               string
	StockConfirmationPlant                         string
	StockConfirmationPlantStorageLocation          string
	PlannedOrder                                   string
	PlannedOrderItem                               string
	BillOfMaterialItemText                         string
	ComponentProductBatch                          string
	ComponentProductBatchValidityStartDate         string
	ComponentProductBatchValidityStartTime         string
	ComponentProductBatchValidityEndDate           string
	ComponentProductBatchValidityEndTime           string
	ComponentProductCostingPolicy                  string
	ComponentProductPriceUnitQuantity              string
	ComponentProductStandardPrice                  string
	ComponentProductMovingAveragePrice             string
	ComponentProductWithdrawnQuantity              string
	CreationDate                                   string
	CreationTime                                   string
	LastChangeDate                                 string
	LastChangeTime                                 string
	ComponentProductAvailabilityIsNotChecked       string
	IsReleased                                     string
	IsLocked                                       string
	IsCancelled                                    string
	IsMarkedForDeletion                            string
}{
	ProductionOrder:                                "ProductionOrder",
	ProductionOrderItem:                            "ProductionOrderItem",
	BillOfMaterial:                                 "BillOfMaterial",
	BillOfMaterialItem:                             "BillOfMaterialItem",
	SupplyChainRelationshipID:                      "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:              "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:         "SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipStockConfPlantID:        "SupplyChainRelationshipStockConfPlantID",
	ProductionPlantBusinessPartner:                 "ProductionPlantBusinessPartner",
	ProductionPlant:                                "ProductionPlant",
	MRPArea:                                        "MRPArea",
	MRPController:                                  "MRPController",
	ProductionVersion:                              "ProductionVersion",
	ProductionVersionItem:                          "ProductionVersionItem",
	ComponentProduct:                               "ComponentProduct",
	ComponentProductBuyer:                          "ComponentProductBuyer",
	ComponentProductSeller:                         "ComponentProductSeller",
	ComponentProductDeliverToParty:                 "ComponentProductDeliverToParty",
	ComponentProductDeliverToPlant:                 "ComponentProductDeliverToPlant",
	ComponentProductDeliverFromParty:               "ComponentProductDeliverFromParty",
	ComponentProductDeliverFromPlant:               "ComponentProductDeliverFromPlant",
	ComponentProductBaseUnit:                       "ComponentProductBaseUnit",
	ComponentProductDeliveryUnit:                   "ComponentProductDeliveryUnit",
	ComponentProductRequirementDate:                "ComponentProductRequirementDate",
	ComponentProductRequirementTime:                "ComponentProductRequirementTime",
	ComponentProductRequiredQuantityInBaseUnit:     "ComponentProductRequiredQuantityInBaseUnit",
	ComponentProductRequiredQuantityInDeliveryUnit: "ComponentProductRequiredQuantityInDeliveryUnit",
	ComponentProductPlannedScrapInPercent:          "ComponentProductPlannedScrapInPercent",
	ComponentProductIsMarkedForBackflush:           "ComponentProductIsMarkedForBackflush",
	StockConfirmationBusinessPartner:               "StockConfirmationBusinessPartner",
	StockConfirmationPlant:                         "StockConfirmationPlant",
	StockConfirmationPlantStorageLocation:          "StockConfirmationPlantStorageLocation",
	PlannedOrder:                                   "PlannedOrder",
	PlannedOrderItem:                               "PlannedOrderItem",
	BillOfMaterialItemText:                         "BillOfMaterialItemText",
	ComponentProductBatch:                          "ComponentProductBatch",
	ComponentProductBatchValidityStartDate:         "ComponentProductBatchValidityStartDate",
	ComponentProductBatchValidityStartTime:         "ComponentProductBatchValidityStartTime",
	ComponentProductBatchValidityEndDate:           "ComponentProductBatchValidityEndDate",
	ComponentProductBatchValidityEndTime:           "ComponentProductBatchValidityEndTime",
	ComponentProductCostingPolicy:                  "ComponentProductCostingPolicy",
	ComponentProductPriceUnitQuantity:              "ComponentProductPriceUnitQuantity",
	ComponentProductStandardPrice:                  "ComponentProductStandardPrice",
	ComponentProductMovingAveragePrice:             "ComponentProductMovingAveragePrice",
	ComponentProductWithdrawnQuantity:              "ComponentProductWithdrawnQuantity",
	CreationDate:                                   "CreationDate",
	CreationTime:                                   "CreationTime",
	LastChangeDate:                                 "LastChangeDate",
	LastChangeTime:                                 "LastChangeTime",
	ComponentProductAvailabilityIsNotChecked:       "ComponentProductAvailabilityIsNotChecked",
	IsReleased:                                     "IsReleased",
	IsLocked:                                       "IsLocked",
	IsCancelled:                                    "IsCancelled",
	IsMarkedForDeletion:                            "IsMarkedForDeletion",
}

var DataPlatformProductionOrderItemComponentDatumTableColumns = struct {
	ProductionOrder                                string
	ProductionOrderItem                            string
	BillOfMaterial                                 string
	BillOfMaterialItem                             string
	SupplyChainRelationshipID                      string
	SupplyChainRelationshipDeliveryID              string
	SupplyChainRelationshipDeliveryPlantID         string
	SupplyChainRelationshipStockConfPlantID        string
	ProductionPlantBusinessPartner                 string
	ProductionPlant                                string
	MRPArea                                        string
	MRPController                                  string
	ProductionVersion                              string
	ProductionVersionItem                          string
	ComponentProduct                               string
	ComponentProductBuyer                          string
	ComponentProductSeller                         string
	ComponentProductDeliverToParty                 string
	ComponentProductDeliverToPlant                 string
	ComponentProductDeliverFromParty               string
	ComponentProductDeliverFromPlant               string
	ComponentProductBaseUnit                       string
	ComponentProductDeliveryUnit                   string
	ComponentProductRequirementDate                string
	ComponentProductRequirementTime                string
	ComponentProductRequiredQuantityInBaseUnit     string
	ComponentProductRequiredQuantityInDeliveryUnit string
	ComponentProductPlannedScrapInPercent          string
	ComponentProductIsMarkedForBackflush           string
	StockConfirmationBusinessPartner               string
	StockConfirmationPlant                         string
	StockConfirmationPlantStorageLocation          string
	PlannedOrder                                   string
	PlannedOrderItem                               string
	BillOfMaterialItemText                         string
	ComponentProductBatch                          string
	ComponentProductBatchValidityStartDate         string
	ComponentProductBatchValidityStartTime         string
	ComponentProductBatchValidityEndDate           string
	ComponentProductBatchValidityEndTime           string
	ComponentProductCostingPolicy                  string
	ComponentProductPriceUnitQuantity              string
	ComponentProductStandardPrice                  string
	ComponentProductMovingAveragePrice             string
	ComponentProductWithdrawnQuantity              string
	CreationDate                                   string
	CreationTime                                   string
	LastChangeDate                                 string
	LastChangeTime                                 string
	ComponentProductAvailabilityIsNotChecked       string
	IsReleased                                     string
	IsLocked                                       string
	IsCancelled                                    string
	IsMarkedForDeletion                            string
}{
	ProductionOrder:                                "data_platform_production_order_item_component_data.ProductionOrder",
	ProductionOrderItem:                            "data_platform_production_order_item_component_data.ProductionOrderItem",
	BillOfMaterial:                                 "data_platform_production_order_item_component_data.BillOfMaterial",
	BillOfMaterialItem:                             "data_platform_production_order_item_component_data.BillOfMaterialItem",
	SupplyChainRelationshipID:                      "data_platform_production_order_item_component_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:              "data_platform_production_order_item_component_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:         "data_platform_production_order_item_component_data.SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipStockConfPlantID:        "data_platform_production_order_item_component_data.SupplyChainRelationshipStockConfPlantID",
	ProductionPlantBusinessPartner:                 "data_platform_production_order_item_component_data.ProductionPlantBusinessPartner",
	ProductionPlant:                                "data_platform_production_order_item_component_data.ProductionPlant",
	MRPArea:                                        "data_platform_production_order_item_component_data.MRPArea",
	MRPController:                                  "data_platform_production_order_item_component_data.MRPController",
	ProductionVersion:                              "data_platform_production_order_item_component_data.ProductionVersion",
	ProductionVersionItem:                          "data_platform_production_order_item_component_data.ProductionVersionItem",
	ComponentProduct:                               "data_platform_production_order_item_component_data.ComponentProduct",
	ComponentProductBuyer:                          "data_platform_production_order_item_component_data.ComponentProductBuyer",
	ComponentProductSeller:                         "data_platform_production_order_item_component_data.ComponentProductSeller",
	ComponentProductDeliverToParty:                 "data_platform_production_order_item_component_data.ComponentProductDeliverToParty",
	ComponentProductDeliverToPlant:                 "data_platform_production_order_item_component_data.ComponentProductDeliverToPlant",
	ComponentProductDeliverFromParty:               "data_platform_production_order_item_component_data.ComponentProductDeliverFromParty",
	ComponentProductDeliverFromPlant:               "data_platform_production_order_item_component_data.ComponentProductDeliverFromPlant",
	ComponentProductBaseUnit:                       "data_platform_production_order_item_component_data.ComponentProductBaseUnit",
	ComponentProductDeliveryUnit:                   "data_platform_production_order_item_component_data.ComponentProductDeliveryUnit",
	ComponentProductRequirementDate:                "data_platform_production_order_item_component_data.ComponentProductRequirementDate",
	ComponentProductRequirementTime:                "data_platform_production_order_item_component_data.ComponentProductRequirementTime",
	ComponentProductRequiredQuantityInBaseUnit:     "data_platform_production_order_item_component_data.ComponentProductRequiredQuantityInBaseUnit",
	ComponentProductRequiredQuantityInDeliveryUnit: "data_platform_production_order_item_component_data.ComponentProductRequiredQuantityInDeliveryUnit",
	ComponentProductPlannedScrapInPercent:          "data_platform_production_order_item_component_data.ComponentProductPlannedScrapInPercent",
	ComponentProductIsMarkedForBackflush:           "data_platform_production_order_item_component_data.ComponentProductIsMarkedForBackflush",
	StockConfirmationBusinessPartner:               "data_platform_production_order_item_component_data.StockConfirmationBusinessPartner",
	StockConfirmationPlant:                         "data_platform_production_order_item_component_data.StockConfirmationPlant",
	StockConfirmationPlantStorageLocation:          "data_platform_production_order_item_component_data.StockConfirmationPlantStorageLocation",
	PlannedOrder:                                   "data_platform_production_order_item_component_data.PlannedOrder",
	PlannedOrderItem:                               "data_platform_production_order_item_component_data.PlannedOrderItem",
	BillOfMaterialItemText:                         "data_platform_production_order_item_component_data.BillOfMaterialItemText",
	ComponentProductBatch:                          "data_platform_production_order_item_component_data.ComponentProductBatch",
	ComponentProductBatchValidityStartDate:         "data_platform_production_order_item_component_data.ComponentProductBatchValidityStartDate",
	ComponentProductBatchValidityStartTime:         "data_platform_production_order_item_component_data.ComponentProductBatchValidityStartTime",
	ComponentProductBatchValidityEndDate:           "data_platform_production_order_item_component_data.ComponentProductBatchValidityEndDate",
	ComponentProductBatchValidityEndTime:           "data_platform_production_order_item_component_data.ComponentProductBatchValidityEndTime",
	ComponentProductCostingPolicy:                  "data_platform_production_order_item_component_data.ComponentProductCostingPolicy",
	ComponentProductPriceUnitQuantity:              "data_platform_production_order_item_component_data.ComponentProductPriceUnitQuantity",
	ComponentProductStandardPrice:                  "data_platform_production_order_item_component_data.ComponentProductStandardPrice",
	ComponentProductMovingAveragePrice:             "data_platform_production_order_item_component_data.ComponentProductMovingAveragePrice",
	ComponentProductWithdrawnQuantity:              "data_platform_production_order_item_component_data.ComponentProductWithdrawnQuantity",
	CreationDate:                                   "data_platform_production_order_item_component_data.CreationDate",
	CreationTime:                                   "data_platform_production_order_item_component_data.CreationTime",
	LastChangeDate:                                 "data_platform_production_order_item_component_data.LastChangeDate",
	LastChangeTime:                                 "data_platform_production_order_item_component_data.LastChangeTime",
	ComponentProductAvailabilityIsNotChecked:       "data_platform_production_order_item_component_data.ComponentProductAvailabilityIsNotChecked",
	IsReleased:                                     "data_platform_production_order_item_component_data.IsReleased",
	IsLocked:                                       "data_platform_production_order_item_component_data.IsLocked",
	IsCancelled:                                    "data_platform_production_order_item_component_data.IsCancelled",
	IsMarkedForDeletion:                            "data_platform_production_order_item_component_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformProductionOrderItemComponentDatumWhere = struct {
	ProductionOrder                                whereHelperint
	ProductionOrderItem                            whereHelperint
	BillOfMaterial                                 whereHelperint
	BillOfMaterialItem                             whereHelperint
	SupplyChainRelationshipID                      whereHelperint
	SupplyChainRelationshipDeliveryID              whereHelperint
	SupplyChainRelationshipDeliveryPlantID         whereHelperint
	SupplyChainRelationshipStockConfPlantID        whereHelperint
	ProductionPlantBusinessPartner                 whereHelperint
	ProductionPlant                                whereHelperstring
	MRPArea                                        whereHelpernull_String
	MRPController                                  whereHelpernull_String
	ProductionVersion                              whereHelpernull_Int
	ProductionVersionItem                          whereHelpernull_Int
	ComponentProduct                               whereHelperstring
	ComponentProductBuyer                          whereHelperint
	ComponentProductSeller                         whereHelperint
	ComponentProductDeliverToParty                 whereHelperint
	ComponentProductDeliverToPlant                 whereHelperstring
	ComponentProductDeliverFromParty               whereHelperint
	ComponentProductDeliverFromPlant               whereHelperstring
	ComponentProductBaseUnit                       whereHelperstring
	ComponentProductDeliveryUnit                   whereHelperstring
	ComponentProductRequirementDate                whereHelperstring
	ComponentProductRequirementTime                whereHelperstring
	ComponentProductRequiredQuantityInBaseUnit     whereHelperfloat32
	ComponentProductRequiredQuantityInDeliveryUnit whereHelperfloat32
	ComponentProductPlannedScrapInPercent          whereHelpernull_Float32
	ComponentProductIsMarkedForBackflush           whereHelpernull_Bool
	StockConfirmationBusinessPartner               whereHelperint
	StockConfirmationPlant                         whereHelperstring
	StockConfirmationPlantStorageLocation          whereHelperstring
	PlannedOrder                                   whereHelpernull_Int
	PlannedOrderItem                               whereHelpernull_Int
	BillOfMaterialItemText                         whereHelpernull_String
	ComponentProductBatch                          whereHelpernull_String
	ComponentProductBatchValidityStartDate         whereHelpernull_String
	ComponentProductBatchValidityStartTime         whereHelpernull_String
	ComponentProductBatchValidityEndDate           whereHelpernull_String
	ComponentProductBatchValidityEndTime           whereHelpernull_String
	ComponentProductCostingPolicy                  whereHelpernull_String
	ComponentProductPriceUnitQuantity              whereHelpernull_Int
	ComponentProductStandardPrice                  whereHelpernull_Float32
	ComponentProductMovingAveragePrice             whereHelpernull_Float32
	ComponentProductWithdrawnQuantity              whereHelpernull_Float32
	CreationDate                                   whereHelperstring
	CreationTime                                   whereHelperstring
	LastChangeDate                                 whereHelperstring
	LastChangeTime                                 whereHelperstring
	ComponentProductAvailabilityIsNotChecked       whereHelpernull_Bool
	IsReleased                                     whereHelpernull_Bool
	IsLocked                                       whereHelpernull_Bool
	IsCancelled                                    whereHelpernull_Bool
	IsMarkedForDeletion                            whereHelpernull_Bool
}{
	ProductionOrder:                                whereHelperint{field: "`data_platform_production_order_item_component_data`.`ProductionOrder`"},
	ProductionOrderItem:                            whereHelperint{field: "`data_platform_production_order_item_component_data`.`ProductionOrderItem`"},
	BillOfMaterial:                                 whereHelperint{field: "`data_platform_production_order_item_component_data`.`BillOfMaterial`"},
	BillOfMaterialItem:                             whereHelperint{field: "`data_platform_production_order_item_component_data`.`BillOfMaterialItem`"},
	SupplyChainRelationshipID:                      whereHelperint{field: "`data_platform_production_order_item_component_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:              whereHelperint{field: "`data_platform_production_order_item_component_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID:         whereHelperint{field: "`data_platform_production_order_item_component_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	SupplyChainRelationshipStockConfPlantID:        whereHelperint{field: "`data_platform_production_order_item_component_data`.`SupplyChainRelationshipStockConfPlantID`"},
	ProductionPlantBusinessPartner:                 whereHelperint{field: "`data_platform_production_order_item_component_data`.`ProductionPlantBusinessPartner`"},
	ProductionPlant:                                whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ProductionPlant`"},
	MRPArea:                                        whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`MRPArea`"},
	MRPController:                                  whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`MRPController`"},
	ProductionVersion:                              whereHelpernull_Int{field: "`data_platform_production_order_item_component_data`.`ProductionVersion`"},
	ProductionVersionItem:                          whereHelpernull_Int{field: "`data_platform_production_order_item_component_data`.`ProductionVersionItem`"},
	ComponentProduct:                               whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProduct`"},
	ComponentProductBuyer:                          whereHelperint{field: "`data_platform_production_order_item_component_data`.`ComponentProductBuyer`"},
	ComponentProductSeller:                         whereHelperint{field: "`data_platform_production_order_item_component_data`.`ComponentProductSeller`"},
	ComponentProductDeliverToParty:                 whereHelperint{field: "`data_platform_production_order_item_component_data`.`ComponentProductDeliverToParty`"},
	ComponentProductDeliverToPlant:                 whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProductDeliverToPlant`"},
	ComponentProductDeliverFromParty:               whereHelperint{field: "`data_platform_production_order_item_component_data`.`ComponentProductDeliverFromParty`"},
	ComponentProductDeliverFromPlant:               whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProductDeliverFromPlant`"},
	ComponentProductBaseUnit:                       whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProductBaseUnit`"},
	ComponentProductDeliveryUnit:                   whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProductDeliveryUnit`"},
	ComponentProductRequirementDate:                whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProductRequirementDate`"},
	ComponentProductRequirementTime:                whereHelperstring{field: "`data_platform_production_order_item_component_data`.`ComponentProductRequirementTime`"},
	ComponentProductRequiredQuantityInBaseUnit:     whereHelperfloat32{field: "`data_platform_production_order_item_component_data`.`ComponentProductRequiredQuantityInBaseUnit`"},
	ComponentProductRequiredQuantityInDeliveryUnit: whereHelperfloat32{field: "`data_platform_production_order_item_component_data`.`ComponentProductRequiredQuantityInDeliveryUnit`"},
	ComponentProductPlannedScrapInPercent:          whereHelpernull_Float32{field: "`data_platform_production_order_item_component_data`.`ComponentProductPlannedScrapInPercent`"},
	ComponentProductIsMarkedForBackflush:           whereHelpernull_Bool{field: "`data_platform_production_order_item_component_data`.`ComponentProductIsMarkedForBackflush`"},
	StockConfirmationBusinessPartner:               whereHelperint{field: "`data_platform_production_order_item_component_data`.`StockConfirmationBusinessPartner`"},
	StockConfirmationPlant:                         whereHelperstring{field: "`data_platform_production_order_item_component_data`.`StockConfirmationPlant`"},
	StockConfirmationPlantStorageLocation:          whereHelperstring{field: "`data_platform_production_order_item_component_data`.`StockConfirmationPlantStorageLocation`"},
	PlannedOrder:                                   whereHelpernull_Int{field: "`data_platform_production_order_item_component_data`.`PlannedOrder`"},
	PlannedOrderItem:                               whereHelpernull_Int{field: "`data_platform_production_order_item_component_data`.`PlannedOrderItem`"},
	BillOfMaterialItemText:                         whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`BillOfMaterialItemText`"},
	ComponentProductBatch:                          whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`ComponentProductBatch`"},
	ComponentProductBatchValidityStartDate:         whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`ComponentProductBatchValidityStartDate`"},
	ComponentProductBatchValidityStartTime:         whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`ComponentProductBatchValidityStartTime`"},
	ComponentProductBatchValidityEndDate:           whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`ComponentProductBatchValidityEndDate`"},
	ComponentProductBatchValidityEndTime:           whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`ComponentProductBatchValidityEndTime`"},
	ComponentProductCostingPolicy:                  whereHelpernull_String{field: "`data_platform_production_order_item_component_data`.`ComponentProductCostingPolicy`"},
	ComponentProductPriceUnitQuantity:              whereHelpernull_Int{field: "`data_platform_production_order_item_component_data`.`ComponentProductPriceUnitQuantity`"},
	ComponentProductStandardPrice:                  whereHelpernull_Float32{field: "`data_platform_production_order_item_component_data`.`ComponentProductStandardPrice`"},
	ComponentProductMovingAveragePrice:             whereHelpernull_Float32{field: "`data_platform_production_order_item_component_data`.`ComponentProductMovingAveragePrice`"},
	ComponentProductWithdrawnQuantity:              whereHelpernull_Float32{field: "`data_platform_production_order_item_component_data`.`ComponentProductWithdrawnQuantity`"},
	CreationDate:                                   whereHelperstring{field: "`data_platform_production_order_item_component_data`.`CreationDate`"},
	CreationTime:                                   whereHelperstring{field: "`data_platform_production_order_item_component_data`.`CreationTime`"},
	LastChangeDate:                                 whereHelperstring{field: "`data_platform_production_order_item_component_data`.`LastChangeDate`"},
	LastChangeTime:                                 whereHelperstring{field: "`data_platform_production_order_item_component_data`.`LastChangeTime`"},
	ComponentProductAvailabilityIsNotChecked:       whereHelpernull_Bool{field: "`data_platform_production_order_item_component_data`.`ComponentProductAvailabilityIsNotChecked`"},
	IsReleased:                                     whereHelpernull_Bool{field: "`data_platform_production_order_item_component_data`.`IsReleased`"},
	IsLocked:                                       whereHelpernull_Bool{field: "`data_platform_production_order_item_component_data`.`IsLocked`"},
	IsCancelled:                                    whereHelpernull_Bool{field: "`data_platform_production_order_item_component_data`.`IsCancelled`"},
	IsMarkedForDeletion:                            whereHelpernull_Bool{field: "`data_platform_production_order_item_component_data`.`IsMarkedForDeletion`"},
}

// DataPlatformProductionOrderItemComponentDatumRels is where relationship names are stored.
var DataPlatformProductionOrderItemComponentDatumRels = struct {
	BillOfMaterialDataPlatformBillOfMaterialItemDatum                     string
	ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum     string
	ComponentProductDataPlatformBatchMasterRecordBatchDatum               string
	ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum string
	ComponentProductDataPlatformProductMasterBPPlantDatum                 string
	StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum string
	ProductionOrderDataPlatformProductionOrderItemDatum                   string
	BillOfMaterialDataPlatformProductionOrderItemComponentCostingData     string
	BillOfMaterialDataPlatformProductionOrderItemOperationComponentData   string
}{
	BillOfMaterialDataPlatformBillOfMaterialItemDatum:                     "BillOfMaterialDataPlatformBillOfMaterialItemDatum",
	ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum:     "ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum",
	ComponentProductDataPlatformBatchMasterRecordBatchDatum:               "ComponentProductDataPlatformBatchMasterRecordBatchDatum",
	ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: "ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum",
	ComponentProductDataPlatformProductMasterBPPlantDatum:                 "ComponentProductDataPlatformProductMasterBPPlantDatum",
	StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum: "StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum",
	ProductionOrderDataPlatformProductionOrderItemDatum:                   "ProductionOrderDataPlatformProductionOrderItemDatum",
	BillOfMaterialDataPlatformProductionOrderItemComponentCostingData:     "BillOfMaterialDataPlatformProductionOrderItemComponentCostingData",
	BillOfMaterialDataPlatformProductionOrderItemOperationComponentData:   "BillOfMaterialDataPlatformProductionOrderItemOperationComponentData",
}

// dataPlatformProductionOrderItemComponentDatumR is where relationships are stored.
type dataPlatformProductionOrderItemComponentDatumR struct {
	BillOfMaterialDataPlatformBillOfMaterialItemDatum                     *DataPlatformBillOfMaterialItemDatum                        `boil:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" json:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" toml:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" yaml:"BillOfMaterialDataPlatformBillOfMaterialItemDatum"`
	ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum     *DataPlatformQuantityUnitQuantityUnitDatum                  `boil:"ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	ComponentProductDataPlatformBatchMasterRecordBatchDatum               *DataPlatformBatchMasterRecordBatchDatum                    `boil:"ComponentProductDataPlatformBatchMasterRecordBatchDatum" json:"ComponentProductDataPlatformBatchMasterRecordBatchDatum" toml:"ComponentProductDataPlatformBatchMasterRecordBatchDatum" yaml:"ComponentProductDataPlatformBatchMasterRecordBatchDatum"`
	ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum                  `boil:"ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	ComponentProductDataPlatformProductMasterBPPlantDatum                 *DataPlatformProductMasterBPPlantDatum                      `boil:"ComponentProductDataPlatformProductMasterBPPlantDatum" json:"ComponentProductDataPlatformProductMasterBPPlantDatum" toml:"ComponentProductDataPlatformProductMasterBPPlantDatum" yaml:"ComponentProductDataPlatformProductMasterBPPlantDatum"`
	StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum *DataPlatformPlantStorageLocationDatum                      `boil:"StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum" json:"StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum" toml:"StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum" yaml:"StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum"`
	ProductionOrderDataPlatformProductionOrderItemDatum                   *DataPlatformProductionOrderItemDatum                       `boil:"ProductionOrderDataPlatformProductionOrderItemDatum" json:"ProductionOrderDataPlatformProductionOrderItemDatum" toml:"ProductionOrderDataPlatformProductionOrderItemDatum" yaml:"ProductionOrderDataPlatformProductionOrderItemDatum"`
	BillOfMaterialDataPlatformProductionOrderItemComponentCostingData     DataPlatformProductionOrderItemComponentCostingDatumSlice   `boil:"BillOfMaterialDataPlatformProductionOrderItemComponentCostingData" json:"BillOfMaterialDataPlatformProductionOrderItemComponentCostingData" toml:"BillOfMaterialDataPlatformProductionOrderItemComponentCostingData" yaml:"BillOfMaterialDataPlatformProductionOrderItemComponentCostingData"`
	BillOfMaterialDataPlatformProductionOrderItemOperationComponentData   DataPlatformProductionOrderItemOperationComponentDatumSlice `boil:"BillOfMaterialDataPlatformProductionOrderItemOperationComponentData" json:"BillOfMaterialDataPlatformProductionOrderItemOperationComponentData" toml:"BillOfMaterialDataPlatformProductionOrderItemOperationComponentData" yaml:"BillOfMaterialDataPlatformProductionOrderItemOperationComponentData"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformProductionOrderItemComponentDatumR) NewStruct() *dataPlatformProductionOrderItemComponentDatumR {
	return &dataPlatformProductionOrderItemComponentDatumR{}
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetBillOfMaterialDataPlatformBillOfMaterialItemDatum() *DataPlatformBillOfMaterialItemDatum {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformBillOfMaterialItemDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetComponentProductDataPlatformBatchMasterRecordBatchDatum() *DataPlatformBatchMasterRecordBatchDatum {
	if r == nil {
		return nil
	}
	return r.ComponentProductDataPlatformBatchMasterRecordBatchDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetComponentProductDataPlatformProductMasterBPPlantDatum() *DataPlatformProductMasterBPPlantDatum {
	if r == nil {
		return nil
	}
	return r.ComponentProductDataPlatformProductMasterBPPlantDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetStockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetProductionOrderDataPlatformProductionOrderItemDatum() *DataPlatformProductionOrderItemDatum {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemDatum
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetBillOfMaterialDataPlatformProductionOrderItemComponentCostingData() DataPlatformProductionOrderItemComponentCostingDatumSlice {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData
}

func (r *dataPlatformProductionOrderItemComponentDatumR) GetBillOfMaterialDataPlatformProductionOrderItemOperationComponentData() DataPlatformProductionOrderItemOperationComponentDatumSlice {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData
}

// dataPlatformProductionOrderItemComponentDatumL is where Load methods for each relationship are stored.
type dataPlatformProductionOrderItemComponentDatumL struct{}

var (
	dataPlatformProductionOrderItemComponentDatumAllColumns            = []string{"ProductionOrder", "ProductionOrderItem", "BillOfMaterial", "BillOfMaterialItem", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipStockConfPlantID", "ProductionPlantBusinessPartner", "ProductionPlant", "MRPArea", "MRPController", "ProductionVersion", "ProductionVersionItem", "ComponentProduct", "ComponentProductBuyer", "ComponentProductSeller", "ComponentProductDeliverToParty", "ComponentProductDeliverToPlant", "ComponentProductDeliverFromParty", "ComponentProductDeliverFromPlant", "ComponentProductBaseUnit", "ComponentProductDeliveryUnit", "ComponentProductRequirementDate", "ComponentProductRequirementTime", "ComponentProductRequiredQuantityInBaseUnit", "ComponentProductRequiredQuantityInDeliveryUnit", "ComponentProductPlannedScrapInPercent", "ComponentProductIsMarkedForBackflush", "StockConfirmationBusinessPartner", "StockConfirmationPlant", "StockConfirmationPlantStorageLocation", "PlannedOrder", "PlannedOrderItem", "BillOfMaterialItemText", "ComponentProductBatch", "ComponentProductBatchValidityStartDate", "ComponentProductBatchValidityStartTime", "ComponentProductBatchValidityEndDate", "ComponentProductBatchValidityEndTime", "ComponentProductCostingPolicy", "ComponentProductPriceUnitQuantity", "ComponentProductStandardPrice", "ComponentProductMovingAveragePrice", "ComponentProductWithdrawnQuantity", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "ComponentProductAvailabilityIsNotChecked", "IsReleased", "IsLocked", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformProductionOrderItemComponentDatumColumnsWithoutDefault = []string{"ProductionOrder", "ProductionOrderItem", "BillOfMaterial", "BillOfMaterialItem", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipStockConfPlantID", "ProductionPlantBusinessPartner", "ProductionPlant", "MRPArea", "MRPController", "ProductionVersion", "ProductionVersionItem", "ComponentProduct", "ComponentProductBuyer", "ComponentProductSeller", "ComponentProductDeliverToParty", "ComponentProductDeliverToPlant", "ComponentProductDeliverFromParty", "ComponentProductDeliverFromPlant", "ComponentProductBaseUnit", "ComponentProductDeliveryUnit", "ComponentProductRequirementDate", "ComponentProductRequirementTime", "ComponentProductRequiredQuantityInBaseUnit", "ComponentProductRequiredQuantityInDeliveryUnit", "ComponentProductPlannedScrapInPercent", "ComponentProductIsMarkedForBackflush", "StockConfirmationBusinessPartner", "StockConfirmationPlant", "StockConfirmationPlantStorageLocation", "PlannedOrder", "PlannedOrderItem", "BillOfMaterialItemText", "ComponentProductBatch", "ComponentProductBatchValidityStartDate", "ComponentProductBatchValidityStartTime", "ComponentProductBatchValidityEndDate", "ComponentProductBatchValidityEndTime", "ComponentProductCostingPolicy", "ComponentProductPriceUnitQuantity", "ComponentProductStandardPrice", "ComponentProductMovingAveragePrice", "ComponentProductWithdrawnQuantity", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "ComponentProductAvailabilityIsNotChecked", "IsReleased", "IsLocked", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformProductionOrderItemComponentDatumColumnsWithDefault    = []string{}
	dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns     = []string{"ProductionOrder", "ProductionOrderItem", "BillOfMaterial", "BillOfMaterialItem"}
	dataPlatformProductionOrderItemComponentDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformProductionOrderItemComponentDatumSlice is an alias for a slice of pointers to DataPlatformProductionOrderItemComponentDatum.
	// This should almost always be used instead of []DataPlatformProductionOrderItemComponentDatum.
	DataPlatformProductionOrderItemComponentDatumSlice []*DataPlatformProductionOrderItemComponentDatum

	dataPlatformProductionOrderItemComponentDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformProductionOrderItemComponentDatumType                 = reflect.TypeOf(&DataPlatformProductionOrderItemComponentDatum{})
	dataPlatformProductionOrderItemComponentDatumMapping              = queries.MakeStructMapping(dataPlatformProductionOrderItemComponentDatumType)
	dataPlatformProductionOrderItemComponentDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns)
	dataPlatformProductionOrderItemComponentDatumInsertCacheMut       sync.RWMutex
	dataPlatformProductionOrderItemComponentDatumInsertCache          = make(map[string]insertCache)
	dataPlatformProductionOrderItemComponentDatumUpdateCacheMut       sync.RWMutex
	dataPlatformProductionOrderItemComponentDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformProductionOrderItemComponentDatumUpsertCacheMut       sync.RWMutex
	dataPlatformProductionOrderItemComponentDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformProductionOrderItemComponentDatum record from the query.
func (q dataPlatformProductionOrderItemComponentDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformProductionOrderItemComponentDatum, error) {
	o := &DataPlatformProductionOrderItemComponentDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_production_order_item_component_data")
	}

	return o, nil
}

// All returns all DataPlatformProductionOrderItemComponentDatum records from the query.
func (q dataPlatformProductionOrderItemComponentDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformProductionOrderItemComponentDatumSlice, error) {
	var o []*DataPlatformProductionOrderItemComponentDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformProductionOrderItemComponentDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformProductionOrderItemComponentDatum records in the query.
func (q dataPlatformProductionOrderItemComponentDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_production_order_item_component_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformProductionOrderItemComponentDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_production_order_item_component_data exists")
	}

	return count > 0, nil
}

// BillOfMaterialDataPlatformBillOfMaterialItemDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) BillOfMaterialDataPlatformBillOfMaterialItemDatum(mods ...qm.QueryMod) dataPlatformBillOfMaterialItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillOfMaterial` = ?", o.BillOfMaterial),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBillOfMaterialItemData(queryMods...)
}

// ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ComponentProductBaseUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// ComponentProductDataPlatformBatchMasterRecordBatchDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) ComponentProductDataPlatformBatchMasterRecordBatchDatum(mods ...qm.QueryMod) dataPlatformBatchMasterRecordBatchDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.ComponentProduct),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBatchMasterRecordBatchData(queryMods...)
}

// ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ComponentProductDeliveryUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// ComponentProductDataPlatformProductMasterBPPlantDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) ComponentProductDataPlatformProductMasterBPPlantDatum(mods ...qm.QueryMod) dataPlatformProductMasterBPPlantDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.ComponentProduct),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductMasterBPPlantData(queryMods...)
}

// StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.StockConfirmationBusinessPartner),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemComponentDatum) ProductionOrderDataPlatformProductionOrderItemDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionOrder` = ?", o.ProductionOrder),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemData(queryMods...)
}

// BillOfMaterialDataPlatformProductionOrderItemComponentCostingData retrieves all the data_platform_production_order_item_component_costing_datum's DataPlatformProductionOrderItemComponentCostingData with an executor via BillOfMaterial column.
func (o *DataPlatformProductionOrderItemComponentDatum) BillOfMaterialDataPlatformProductionOrderItemComponentCostingData(mods ...qm.QueryMod) dataPlatformProductionOrderItemComponentCostingDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_production_order_item_component_costing_data`.`BillOfMaterial`=?", o.BillOfMaterial),
	)

	return DataPlatformProductionOrderItemComponentCostingData(queryMods...)
}

// BillOfMaterialDataPlatformProductionOrderItemOperationComponentData retrieves all the data_platform_production_order_item_operation_component_datum's DataPlatformProductionOrderItemOperationComponentData with an executor via BillOfMaterial column.
func (o *DataPlatformProductionOrderItemComponentDatum) BillOfMaterialDataPlatformProductionOrderItemOperationComponentData(mods ...qm.QueryMod) dataPlatformProductionOrderItemOperationComponentDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_production_order_item_operation_component_data`.`BillOfMaterial`=?", o.BillOfMaterial),
	)

	return DataPlatformProductionOrderItemOperationComponentData(queryMods...)
}

// LoadBillOfMaterialDataPlatformBillOfMaterialItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.BillOfMaterial)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.BillOfMaterial {
					continue Outer
				}
			}

			args = append(args, obj.BillOfMaterial)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_bill_of_material_item_data`),
		qm.WhereIn(`data_platform_bill_of_material_item_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBillOfMaterialItemDatum")
	}

	var resultSlice []*DataPlatformBillOfMaterialItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBillOfMaterialItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_bill_of_material_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_bill_of_material_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BillOfMaterial == foreign.BillOfMaterial {
				local.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.ComponentProductBaseUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ComponentProductBaseUnit {
					continue Outer
				}
			}

			args = append(args, obj.ComponentProductBaseUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ComponentProductBaseUnit == foreign.QuantityUnit {
				local.R.ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadComponentProductDataPlatformBatchMasterRecordBatchDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadComponentProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.ComponentProduct)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ComponentProduct {
					continue Outer
				}
			}

			args = append(args, obj.ComponentProduct)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_batch_master_record_batch_data`),
		qm.WhereIn(`data_platform_batch_master_record_batch_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBatchMasterRecordBatchDatum")
	}

	var resultSlice []*DataPlatformBatchMasterRecordBatchDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBatchMasterRecordBatchDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_batch_master_record_batch_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_batch_master_record_batch_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ComponentProductDataPlatformBatchMasterRecordBatchDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ComponentProduct == foreign.Product {
				local.R.ComponentProductDataPlatformBatchMasterRecordBatchDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.ComponentProductDeliveryUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ComponentProductDeliveryUnit {
					continue Outer
				}
			}

			args = append(args, obj.ComponentProductDeliveryUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ComponentProductDeliveryUnit == foreign.QuantityUnit {
				local.R.ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadComponentProductDataPlatformProductMasterBPPlantDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadComponentProductDataPlatformProductMasterBPPlantDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.ComponentProduct)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ComponentProduct {
					continue Outer
				}
			}

			args = append(args, obj.ComponentProduct)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_product_master_bp_plant_data`),
		qm.WhereIn(`data_platform_product_master_bp_plant_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductMasterBPPlantDatum")
	}

	var resultSlice []*DataPlatformProductMasterBPPlantDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductMasterBPPlantDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_product_master_bp_plant_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_product_master_bp_plant_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ComponentProductDataPlatformProductMasterBPPlantDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ComponentProduct == foreign.Product {
				local.R.ComponentProductDataPlatformProductMasterBPPlantDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadStockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadStockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.StockConfirmationBusinessPartner)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.StockConfirmationBusinessPartner {
					continue Outer
				}
			}

			args = append(args, obj.StockConfirmationBusinessPartner)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.StockConfirmationBusinessPartner == foreign.BusinessPartner {
				local.R.StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.ProductionOrder)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductionOrder {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_data`),
		qm.WhereIn(`data_platform_production_order_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductionOrder == foreign.ProductionOrder {
				local.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillOfMaterialDataPlatformProductionOrderItemComponentCostingData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadBillOfMaterialDataPlatformProductionOrderItemComponentCostingData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.BillOfMaterial)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.BillOfMaterial {
					continue Outer
				}
			}

			args = append(args, obj.BillOfMaterial)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_component_costing_data`),
		qm.WhereIn(`data_platform_production_order_item_component_costing_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_production_order_item_component_costing_data")
	}

	var resultSlice []*DataPlatformProductionOrderItemComponentCostingDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_production_order_item_component_costing_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_production_order_item_component_costing_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_component_costing_data")
	}

	if singular {
		object.R.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BillOfMaterial == foreign.BillOfMaterial {
				local.R.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData = append(local.R.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadBillOfMaterialDataPlatformProductionOrderItemOperationComponentData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemComponentDatumL) LoadBillOfMaterialDataPlatformProductionOrderItemOperationComponentData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemComponentDatum
	var object *DataPlatformProductionOrderItemComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemComponentDatum.(*DataPlatformProductionOrderItemComponentDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemComponentDatum.(*[]*DataPlatformProductionOrderItemComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemComponentDatumR{}
		}
		args = append(args, object.BillOfMaterial)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.BillOfMaterial {
					continue Outer
				}
			}

			args = append(args, obj.BillOfMaterial)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_operation_component_data`),
		qm.WhereIn(`data_platform_production_order_item_operation_component_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_production_order_item_operation_component_data")
	}

	var resultSlice []*DataPlatformProductionOrderItemOperationComponentDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_production_order_item_operation_component_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_production_order_item_operation_component_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_operation_component_data")
	}

	if singular {
		object.R.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.BillOfMaterial == foreign.BillOfMaterial {
				local.R.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData = append(local.R.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData, foreign)
				break
			}
		}
	}

	return nil
}

// SetBillOfMaterialDataPlatformBillOfMaterialItemDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBillOfMaterialItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillOfMaterial, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BillOfMaterial = related.BillOfMaterial
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			BillOfMaterialDataPlatformBillOfMaterialItemDatum: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = related
	}

	return nil
}

// SetComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ComponentProductBaseUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ComponentProductBaseUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ComponentProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetComponentProductDataPlatformBatchMasterRecordBatchDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.ComponentProductDataPlatformBatchMasterRecordBatchDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetComponentProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ComponentProduct"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ComponentProduct = related.Product
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			ComponentProductDataPlatformBatchMasterRecordBatchDatum: related,
		}
	} else {
		o.R.ComponentProductDataPlatformBatchMasterRecordBatchDatum = related
	}

	return nil
}

// SetComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ComponentProductDeliveryUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ComponentProductDeliveryUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ComponentProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetComponentProductDataPlatformProductMasterBPPlantDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.ComponentProductDataPlatformProductMasterBPPlantDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetComponentProductDataPlatformProductMasterBPPlantDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductMasterBPPlantDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ComponentProduct"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ComponentProduct = related.Product
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			ComponentProductDataPlatformProductMasterBPPlantDatum: related,
		}
	} else {
		o.R.ComponentProductDataPlatformProductMasterBPPlantDatum = related
	}

	return nil
}

// SetStockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetStockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"StockConfirmationBusinessPartner"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.StockConfirmationBusinessPartner = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.StockConfirmationBusinessPartnerDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// SetProductionOrderDataPlatformProductionOrderItemDatum of the dataPlatformProductionOrderItemComponentDatum to the related item.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to related.
func (o *DataPlatformProductionOrderItemComponentDatum) SetProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionOrder, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductionOrder = related.ProductionOrder
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			ProductionOrderDataPlatformProductionOrderItemDatum: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = related
	}

	return nil
}

// AddBillOfMaterialDataPlatformProductionOrderItemComponentCostingData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_component_datum, optionally inserting them as new records.
// Appends related to o.R.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData.
func (o *DataPlatformProductionOrderItemComponentDatum) AddBillOfMaterialDataPlatformProductionOrderItemComponentCostingData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderItemComponentCostingDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BillOfMaterial = o.BillOfMaterial
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_production_order_item_component_costing_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentCostingDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.BillOfMaterial, rel.ProductionOrder, rel.ProductionOrderItem, rel.BillOfMaterial, rel.BillOfMaterialItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BillOfMaterial = o.BillOfMaterial
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			BillOfMaterialDataPlatformProductionOrderItemComponentCostingData: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData = append(o.R.BillOfMaterialDataPlatformProductionOrderItemComponentCostingData, related...)
	}

	return nil
}

// AddBillOfMaterialDataPlatformProductionOrderItemOperationComponentData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_component_datum, optionally inserting them as new records.
// Appends related to o.R.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData.
func (o *DataPlatformProductionOrderItemComponentDatum) AddBillOfMaterialDataPlatformProductionOrderItemOperationComponentData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderItemOperationComponentDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.BillOfMaterial = o.BillOfMaterial
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_production_order_item_operation_component_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemOperationComponentDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.BillOfMaterial, rel.ProductionOrder, rel.ProductionOrderItem, rel.Operations, rel.OperationsItem, rel.OperationID, rel.BillOfMaterial, rel.BillOfMaterialItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.BillOfMaterial = o.BillOfMaterial
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemComponentDatumR{
			BillOfMaterialDataPlatformProductionOrderItemOperationComponentData: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData = append(o.R.BillOfMaterialDataPlatformProductionOrderItemOperationComponentData, related...)
	}

	return nil
}

// DataPlatformProductionOrderItemComponentData retrieves all the records using an executor.
func DataPlatformProductionOrderItemComponentData(mods ...qm.QueryMod) dataPlatformProductionOrderItemComponentDatumQuery {
	mods = append(mods, qm.From("`data_platform_production_order_item_component_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_production_order_item_component_data`.*"})
	}

	return dataPlatformProductionOrderItemComponentDatumQuery{q}
}

// FindDataPlatformProductionOrderItemComponentDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformProductionOrderItemComponentDatum(ctx context.Context, exec boil.ContextExecutor, productionOrder int, productionOrderItem int, billOfMaterial int, billOfMaterialItem int, selectCols ...string) (*DataPlatformProductionOrderItemComponentDatum, error) {
	dataPlatformProductionOrderItemComponentDatumObj := &DataPlatformProductionOrderItemComponentDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_production_order_item_component_data` where `ProductionOrder`=? AND `ProductionOrderItem`=? AND `BillOfMaterial`=? AND `BillOfMaterialItem`=?", sel,
	)

	q := queries.Raw(query, productionOrder, productionOrderItem, billOfMaterial, billOfMaterialItem)

	err := q.Bind(ctx, exec, dataPlatformProductionOrderItemComponentDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_production_order_item_component_data")
	}

	return dataPlatformProductionOrderItemComponentDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformProductionOrderItemComponentDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_production_order_item_component_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformProductionOrderItemComponentDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformProductionOrderItemComponentDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformProductionOrderItemComponentDatumInsertCache[key]
	dataPlatformProductionOrderItemComponentDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformProductionOrderItemComponentDatumAllColumns,
			dataPlatformProductionOrderItemComponentDatumColumnsWithDefault,
			dataPlatformProductionOrderItemComponentDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_production_order_item_component_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_production_order_item_component_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_production_order_item_component_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_production_order_item_component_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ProductionOrder,
		o.ProductionOrderItem,
		o.BillOfMaterial,
		o.BillOfMaterialItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_production_order_item_component_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformProductionOrderItemComponentDatumInsertCacheMut.Lock()
		dataPlatformProductionOrderItemComponentDatumInsertCache[key] = cache
		dataPlatformProductionOrderItemComponentDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformProductionOrderItemComponentDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformProductionOrderItemComponentDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformProductionOrderItemComponentDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformProductionOrderItemComponentDatumUpdateCache[key]
	dataPlatformProductionOrderItemComponentDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformProductionOrderItemComponentDatumAllColumns,
			dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_production_order_item_component_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, append(wl, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_production_order_item_component_data row")
	}

	if !cached {
		dataPlatformProductionOrderItemComponentDatumUpdateCacheMut.Lock()
		dataPlatformProductionOrderItemComponentDatumUpdateCache[key] = cache
		dataPlatformProductionOrderItemComponentDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformProductionOrderItemComponentDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_production_order_item_component_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformProductionOrderItemComponentDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductionOrderItemComponentDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformProductionOrderItemComponentDatum slice")
	}

	return nil
}

var mySQLDataPlatformProductionOrderItemComponentDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformProductionOrderItemComponentDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_production_order_item_component_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformProductionOrderItemComponentDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformProductionOrderItemComponentDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformProductionOrderItemComponentDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformProductionOrderItemComponentDatumUpsertCache[key]
	dataPlatformProductionOrderItemComponentDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformProductionOrderItemComponentDatumAllColumns,
			dataPlatformProductionOrderItemComponentDatumColumnsWithDefault,
			dataPlatformProductionOrderItemComponentDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformProductionOrderItemComponentDatumAllColumns,
			dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_production_order_item_component_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_production_order_item_component_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_production_order_item_component_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_production_order_item_component_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformProductionOrderItemComponentDatumType, dataPlatformProductionOrderItemComponentDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_production_order_item_component_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_production_order_item_component_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformProductionOrderItemComponentDatumUpsertCacheMut.Lock()
		dataPlatformProductionOrderItemComponentDatumUpsertCache[key] = cache
		dataPlatformProductionOrderItemComponentDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformProductionOrderItemComponentDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformProductionOrderItemComponentDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformProductionOrderItemComponentDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformProductionOrderItemComponentDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_production_order_item_component_data` WHERE `ProductionOrder`=? AND `ProductionOrderItem`=? AND `BillOfMaterial`=? AND `BillOfMaterialItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_production_order_item_component_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformProductionOrderItemComponentDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformProductionOrderItemComponentDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_production_order_item_component_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformProductionOrderItemComponentDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductionOrderItemComponentDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_production_order_item_component_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformProductionOrderItemComponentDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformProductionOrderItemComponentDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformProductionOrderItemComponentDatum(ctx, exec, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformProductionOrderItemComponentDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformProductionOrderItemComponentDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductionOrderItemComponentDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_production_order_item_component_data`.* FROM `data_platform_production_order_item_component_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformProductionOrderItemComponentDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformProductionOrderItemComponentDatumExists checks if the DataPlatformProductionOrderItemComponentDatum row exists.
func DataPlatformProductionOrderItemComponentDatumExists(ctx context.Context, exec boil.ContextExecutor, productionOrder int, productionOrderItem int, billOfMaterial int, billOfMaterialItem int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_production_order_item_component_data` where `ProductionOrder`=? AND `ProductionOrderItem`=? AND `BillOfMaterial`=? AND `BillOfMaterialItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, productionOrder, productionOrderItem, billOfMaterial, billOfMaterialItem)
	}
	row := exec.QueryRowContext(ctx, sql, productionOrder, productionOrderItem, billOfMaterial, billOfMaterialItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_production_order_item_component_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformProductionOrderItemComponentDatum row exists.
func (o *DataPlatformProductionOrderItemComponentDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformProductionOrderItemComponentDatumExists(ctx, exec, o.ProductionOrder, o.ProductionOrderItem, o.BillOfMaterial, o.BillOfMaterialItem)
}
