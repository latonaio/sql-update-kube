// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformContractItemDatum is an object representing the database table.
type DataPlatformContractItemDatum struct {
	Contract                                 int          `boil:"Contract" json:"Contract" toml:"Contract" yaml:"Contract"`
	ContractItem                             int          `boil:"ContractItem" json:"ContractItem" toml:"ContractItem" yaml:"ContractItem"`
	ContractItemCategory                     string       `boil:"ContractItemCategory" json:"ContractItemCategory" toml:"ContractItemCategory" yaml:"ContractItemCategory"`
	ContractStatus                           string       `boil:"ContractStatus" json:"ContractStatus" toml:"ContractStatus" yaml:"ContractStatus"`
	SupplyChainRelationshipID                int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipDeliveryID        null.Int     `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID,omitempty" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID,omitempty"`
	SupplyChainRelationshipDeliveryPlantID   null.Int     `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID,omitempty" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID,omitempty"`
	SupplyChainRelationshipProductionPlantID null.Int     `boil:"SupplyChainRelationshipProductionPlantID" json:"SupplyChainRelationshipProductionPlantID,omitempty" toml:"SupplyChainRelationshipProductionPlantID" yaml:"SupplyChainRelationshipProductionPlantID,omitempty"`
	Buyer                                    int          `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Seller                                   int          `boil:"Seller" json:"Seller" toml:"Seller" yaml:"Seller"`
	DeliverToParty                           null.Int     `boil:"DeliverToParty" json:"DeliverToParty,omitempty" toml:"DeliverToParty" yaml:"DeliverToParty,omitempty"`
	DeliverFromParty                         null.Int     `boil:"DeliverFromParty" json:"DeliverFromParty,omitempty" toml:"DeliverFromParty" yaml:"DeliverFromParty,omitempty"`
	DeliverToPlant                           null.String  `boil:"DeliverToPlant" json:"DeliverToPlant,omitempty" toml:"DeliverToPlant" yaml:"DeliverToPlant,omitempty"`
	DeliverFromPlant                         null.String  `boil:"DeliverFromPlant" json:"DeliverFromPlant,omitempty" toml:"DeliverFromPlant" yaml:"DeliverFromPlant,omitempty"`
	ContractItemText                         string       `boil:"ContractItemText" json:"ContractItemText" toml:"ContractItemText" yaml:"ContractItemText"`
	ContractItemTextByBuyer                  string       `boil:"ContractItemTextByBuyer" json:"ContractItemTextByBuyer" toml:"ContractItemTextByBuyer" yaml:"ContractItemTextByBuyer"`
	ContractItemTextBySeller                 string       `boil:"ContractItemTextBySeller" json:"ContractItemTextBySeller" toml:"ContractItemTextBySeller" yaml:"ContractItemTextBySeller"`
	Product                                  string       `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	ProductStandardID                        null.String  `boil:"ProductStandardID" json:"ProductStandardID,omitempty" toml:"ProductStandardID" yaml:"ProductStandardID,omitempty"`
	ProductGroup                             null.String  `boil:"ProductGroup" json:"ProductGroup,omitempty" toml:"ProductGroup" yaml:"ProductGroup,omitempty"`
	ProductSpecification                     null.String  `boil:"ProductSpecification" json:"ProductSpecification,omitempty" toml:"ProductSpecification" yaml:"ProductSpecification,omitempty"`
	MarkingOfMaterial                        null.String  `boil:"MarkingOfMaterial" json:"MarkingOfMaterial,omitempty" toml:"MarkingOfMaterial" yaml:"MarkingOfMaterial,omitempty"`
	BaseUnit                                 string       `boil:"BaseUnit" json:"BaseUnit" toml:"BaseUnit" yaml:"BaseUnit"`
	DeliveryUnit                             null.String  `boil:"DeliveryUnit" json:"DeliveryUnit,omitempty" toml:"DeliveryUnit" yaml:"DeliveryUnit,omitempty"`
	BillOfMaterial                           null.Int     `boil:"BillOfMaterial" json:"BillOfMaterial,omitempty" toml:"BillOfMaterial" yaml:"BillOfMaterial,omitempty"`
	BillOfMaterialItem                       null.Int     `boil:"BillOfMaterialItem" json:"BillOfMaterialItem,omitempty" toml:"BillOfMaterialItem" yaml:"BillOfMaterialItem,omitempty"`
	PricingDate                              null.String  `boil:"PricingDate" json:"PricingDate,omitempty" toml:"PricingDate" yaml:"PricingDate,omitempty"`
	PriceDetnExchangeRate                    null.Float32 `boil:"PriceDetnExchangeRate" json:"PriceDetnExchangeRate,omitempty" toml:"PriceDetnExchangeRate" yaml:"PriceDetnExchangeRate,omitempty"`
	ServicesRenderingDate                    null.String  `boil:"ServicesRenderingDate" json:"ServicesRenderingDate,omitempty" toml:"ServicesRenderingDate" yaml:"ServicesRenderingDate,omitempty"`
	ContractQuantityInBaseUnit               null.Float32 `boil:"ContractQuantityInBaseUnit" json:"ContractQuantityInBaseUnit,omitempty" toml:"ContractQuantityInBaseUnit" yaml:"ContractQuantityInBaseUnit,omitempty"`
	ContractQuantityInDeliveryUnit           null.Float32 `boil:"ContractQuantityInDeliveryUnit" json:"ContractQuantityInDeliveryUnit,omitempty" toml:"ContractQuantityInDeliveryUnit" yaml:"ContractQuantityInDeliveryUnit,omitempty"`
	QuantityPerPackage                       null.Float32 `boil:"QuantityPerPackage" json:"QuantityPerPackage,omitempty" toml:"QuantityPerPackage" yaml:"QuantityPerPackage,omitempty"`
	InternalCapacityQuantity                 null.Float32 `boil:"InternalCapacityQuantity" json:"InternalCapacityQuantity,omitempty" toml:"InternalCapacityQuantity" yaml:"InternalCapacityQuantity,omitempty"`
	InternalCapacityQuantityUnit             null.String  `boil:"InternalCapacityQuantityUnit" json:"InternalCapacityQuantityUnit,omitempty" toml:"InternalCapacityQuantityUnit" yaml:"InternalCapacityQuantityUnit,omitempty"`
	NetAmount                                float32      `boil:"NetAmount" json:"NetAmount" toml:"NetAmount" yaml:"NetAmount"`
	TaxAmount                                float32      `boil:"TaxAmount" json:"TaxAmount" toml:"TaxAmount" yaml:"TaxAmount"`
	GrossAmount                              float32      `boil:"GrossAmount" json:"GrossAmount" toml:"GrossAmount" yaml:"GrossAmount"`
	InvoiceDocumentDate                      null.String  `boil:"InvoiceDocumentDate" json:"InvoiceDocumentDate,omitempty" toml:"InvoiceDocumentDate" yaml:"InvoiceDocumentDate,omitempty"`
	ProductionPlantBusinessPartner           null.Int     `boil:"ProductionPlantBusinessPartner" json:"ProductionPlantBusinessPartner,omitempty" toml:"ProductionPlantBusinessPartner" yaml:"ProductionPlantBusinessPartner,omitempty"`
	ProductionPlant                          null.String  `boil:"ProductionPlant" json:"ProductionPlant,omitempty" toml:"ProductionPlant" yaml:"ProductionPlant,omitempty"`
	InspectionPlantBusinessPartner           null.Int     `boil:"InspectionPlantBusinessPartner" json:"InspectionPlantBusinessPartner,omitempty" toml:"InspectionPlantBusinessPartner" yaml:"InspectionPlantBusinessPartner,omitempty"`
	InspectionPlant                          null.String  `boil:"InspectionPlant" json:"InspectionPlant,omitempty" toml:"InspectionPlant" yaml:"InspectionPlant,omitempty"`
	InspectionPlan                           null.Int     `boil:"InspectionPlan" json:"InspectionPlan,omitempty" toml:"InspectionPlan" yaml:"InspectionPlan,omitempty"`
	InspectionLot                            null.Int     `boil:"InspectionLot" json:"InspectionLot,omitempty" toml:"InspectionLot" yaml:"InspectionLot,omitempty"`
	TransactionTaxClassification             string       `boil:"TransactionTaxClassification" json:"TransactionTaxClassification" toml:"TransactionTaxClassification" yaml:"TransactionTaxClassification"`
	ProductTaxClassificationBillToCountry    string       `boil:"ProductTaxClassificationBillToCountry" json:"ProductTaxClassificationBillToCountry" toml:"ProductTaxClassificationBillToCountry" yaml:"ProductTaxClassificationBillToCountry"`
	ProductTaxClassificationBillFromCountry  string       `boil:"ProductTaxClassificationBillFromCountry" json:"ProductTaxClassificationBillFromCountry" toml:"ProductTaxClassificationBillFromCountry" yaml:"ProductTaxClassificationBillFromCountry"`
	DefinedTaxClassification                 string       `boil:"DefinedTaxClassification" json:"DefinedTaxClassification" toml:"DefinedTaxClassification" yaml:"DefinedTaxClassification"`
	AccountAssignmentGroup                   string       `boil:"AccountAssignmentGroup" json:"AccountAssignmentGroup" toml:"AccountAssignmentGroup" yaml:"AccountAssignmentGroup"`
	ProductAccountAssignmentGroup            string       `boil:"ProductAccountAssignmentGroup" json:"ProductAccountAssignmentGroup" toml:"ProductAccountAssignmentGroup" yaml:"ProductAccountAssignmentGroup"`
	PaymentTerms                             string       `boil:"PaymentTerms" json:"PaymentTerms" toml:"PaymentTerms" yaml:"PaymentTerms"`
	DueCalculationBaseDate                   null.String  `boil:"DueCalculationBaseDate" json:"DueCalculationBaseDate,omitempty" toml:"DueCalculationBaseDate" yaml:"DueCalculationBaseDate,omitempty"`
	PaymentDueDate                           null.String  `boil:"PaymentDueDate" json:"PaymentDueDate,omitempty" toml:"PaymentDueDate" yaml:"PaymentDueDate,omitempty"`
	NetPaymentDays                           null.Int     `boil:"NetPaymentDays" json:"NetPaymentDays,omitempty" toml:"NetPaymentDays" yaml:"NetPaymentDays,omitempty"`
	PaymentMethod                            string       `boil:"PaymentMethod" json:"PaymentMethod" toml:"PaymentMethod" yaml:"PaymentMethod"`
	Project                                  null.Int     `boil:"Project" json:"Project,omitempty" toml:"Project" yaml:"Project,omitempty"`
	WBSElement                               null.Int     `boil:"WBSElement" json:"WBSElement,omitempty" toml:"WBSElement" yaml:"WBSElement,omitempty"`
	AccountingExchangeRate                   null.Float32 `boil:"AccountingExchangeRate" json:"AccountingExchangeRate,omitempty" toml:"AccountingExchangeRate" yaml:"AccountingExchangeRate,omitempty"`
	TaxCode                                  null.String  `boil:"TaxCode" json:"TaxCode,omitempty" toml:"TaxCode" yaml:"TaxCode,omitempty"`
	TaxRate                                  null.Float32 `boil:"TaxRate" json:"TaxRate,omitempty" toml:"TaxRate" yaml:"TaxRate,omitempty"`
	CountryOfOrigin                          null.String  `boil:"CountryOfOrigin" json:"CountryOfOrigin,omitempty" toml:"CountryOfOrigin" yaml:"CountryOfOrigin,omitempty"`
	CountryOfOriginLanguage                  null.String  `boil:"CountryOfOriginLanguage" json:"CountryOfOriginLanguage,omitempty" toml:"CountryOfOriginLanguage" yaml:"CountryOfOriginLanguage,omitempty"`
	Equipment                                null.Int     `boil:"Equipment" json:"Equipment,omitempty" toml:"Equipment" yaml:"Equipment,omitempty"`
	ItemBlockStatus                          null.Bool    `boil:"ItemBlockStatus" json:"ItemBlockStatus,omitempty" toml:"ItemBlockStatus" yaml:"ItemBlockStatus,omitempty"`
	ExternalReferenceDocument                null.String  `boil:"ExternalReferenceDocument" json:"ExternalReferenceDocument,omitempty" toml:"ExternalReferenceDocument" yaml:"ExternalReferenceDocument,omitempty"`
	ExternalReferenceDocumentItem            null.String  `boil:"ExternalReferenceDocumentItem" json:"ExternalReferenceDocumentItem,omitempty" toml:"ExternalReferenceDocumentItem" yaml:"ExternalReferenceDocumentItem,omitempty"`
	CreationDate                             string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                             string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                           string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                           string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsCancelled                              null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                      null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformContractItemDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformContractItemDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformContractItemDatumColumns = struct {
	Contract                                 string
	ContractItem                             string
	ContractItemCategory                     string
	ContractStatus                           string
	SupplyChainRelationshipID                string
	SupplyChainRelationshipDeliveryID        string
	SupplyChainRelationshipDeliveryPlantID   string
	SupplyChainRelationshipProductionPlantID string
	Buyer                                    string
	Seller                                   string
	DeliverToParty                           string
	DeliverFromParty                         string
	DeliverToPlant                           string
	DeliverFromPlant                         string
	ContractItemText                         string
	ContractItemTextByBuyer                  string
	ContractItemTextBySeller                 string
	Product                                  string
	ProductStandardID                        string
	ProductGroup                             string
	ProductSpecification                     string
	MarkingOfMaterial                        string
	BaseUnit                                 string
	DeliveryUnit                             string
	BillOfMaterial                           string
	BillOfMaterialItem                       string
	PricingDate                              string
	PriceDetnExchangeRate                    string
	ServicesRenderingDate                    string
	ContractQuantityInBaseUnit               string
	ContractQuantityInDeliveryUnit           string
	QuantityPerPackage                       string
	InternalCapacityQuantity                 string
	InternalCapacityQuantityUnit             string
	NetAmount                                string
	TaxAmount                                string
	GrossAmount                              string
	InvoiceDocumentDate                      string
	ProductionPlantBusinessPartner           string
	ProductionPlant                          string
	InspectionPlantBusinessPartner           string
	InspectionPlant                          string
	InspectionPlan                           string
	InspectionLot                            string
	TransactionTaxClassification             string
	ProductTaxClassificationBillToCountry    string
	ProductTaxClassificationBillFromCountry  string
	DefinedTaxClassification                 string
	AccountAssignmentGroup                   string
	ProductAccountAssignmentGroup            string
	PaymentTerms                             string
	DueCalculationBaseDate                   string
	PaymentDueDate                           string
	NetPaymentDays                           string
	PaymentMethod                            string
	Project                                  string
	WBSElement                               string
	AccountingExchangeRate                   string
	TaxCode                                  string
	TaxRate                                  string
	CountryOfOrigin                          string
	CountryOfOriginLanguage                  string
	Equipment                                string
	ItemBlockStatus                          string
	ExternalReferenceDocument                string
	ExternalReferenceDocumentItem            string
	CreationDate                             string
	CreationTime                             string
	LastChangeDate                           string
	LastChangeTime                           string
	IsCancelled                              string
	IsMarkedForDeletion                      string
}{
	Contract:                                 "Contract",
	ContractItem:                             "ContractItem",
	ContractItemCategory:                     "ContractItemCategory",
	ContractStatus:                           "ContractStatus",
	SupplyChainRelationshipID:                "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:        "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:   "SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipProductionPlantID: "SupplyChainRelationshipProductionPlantID",
	Buyer:                                    "Buyer",
	Seller:                                   "Seller",
	DeliverToParty:                           "DeliverToParty",
	DeliverFromParty:                         "DeliverFromParty",
	DeliverToPlant:                           "DeliverToPlant",
	DeliverFromPlant:                         "DeliverFromPlant",
	ContractItemText:                         "ContractItemText",
	ContractItemTextByBuyer:                  "ContractItemTextByBuyer",
	ContractItemTextBySeller:                 "ContractItemTextBySeller",
	Product:                                  "Product",
	ProductStandardID:                        "ProductStandardID",
	ProductGroup:                             "ProductGroup",
	ProductSpecification:                     "ProductSpecification",
	MarkingOfMaterial:                        "MarkingOfMaterial",
	BaseUnit:                                 "BaseUnit",
	DeliveryUnit:                             "DeliveryUnit",
	BillOfMaterial:                           "BillOfMaterial",
	BillOfMaterialItem:                       "BillOfMaterialItem",
	PricingDate:                              "PricingDate",
	PriceDetnExchangeRate:                    "PriceDetnExchangeRate",
	ServicesRenderingDate:                    "ServicesRenderingDate",
	ContractQuantityInBaseUnit:               "ContractQuantityInBaseUnit",
	ContractQuantityInDeliveryUnit:           "ContractQuantityInDeliveryUnit",
	QuantityPerPackage:                       "QuantityPerPackage",
	InternalCapacityQuantity:                 "InternalCapacityQuantity",
	InternalCapacityQuantityUnit:             "InternalCapacityQuantityUnit",
	NetAmount:                                "NetAmount",
	TaxAmount:                                "TaxAmount",
	GrossAmount:                              "GrossAmount",
	InvoiceDocumentDate:                      "InvoiceDocumentDate",
	ProductionPlantBusinessPartner:           "ProductionPlantBusinessPartner",
	ProductionPlant:                          "ProductionPlant",
	InspectionPlantBusinessPartner:           "InspectionPlantBusinessPartner",
	InspectionPlant:                          "InspectionPlant",
	InspectionPlan:                           "InspectionPlan",
	InspectionLot:                            "InspectionLot",
	TransactionTaxClassification:             "TransactionTaxClassification",
	ProductTaxClassificationBillToCountry:    "ProductTaxClassificationBillToCountry",
	ProductTaxClassificationBillFromCountry:  "ProductTaxClassificationBillFromCountry",
	DefinedTaxClassification:                 "DefinedTaxClassification",
	AccountAssignmentGroup:                   "AccountAssignmentGroup",
	ProductAccountAssignmentGroup:            "ProductAccountAssignmentGroup",
	PaymentTerms:                             "PaymentTerms",
	DueCalculationBaseDate:                   "DueCalculationBaseDate",
	PaymentDueDate:                           "PaymentDueDate",
	NetPaymentDays:                           "NetPaymentDays",
	PaymentMethod:                            "PaymentMethod",
	Project:                                  "Project",
	WBSElement:                               "WBSElement",
	AccountingExchangeRate:                   "AccountingExchangeRate",
	TaxCode:                                  "TaxCode",
	TaxRate:                                  "TaxRate",
	CountryOfOrigin:                          "CountryOfOrigin",
	CountryOfOriginLanguage:                  "CountryOfOriginLanguage",
	Equipment:                                "Equipment",
	ItemBlockStatus:                          "ItemBlockStatus",
	ExternalReferenceDocument:                "ExternalReferenceDocument",
	ExternalReferenceDocumentItem:            "ExternalReferenceDocumentItem",
	CreationDate:                             "CreationDate",
	CreationTime:                             "CreationTime",
	LastChangeDate:                           "LastChangeDate",
	LastChangeTime:                           "LastChangeTime",
	IsCancelled:                              "IsCancelled",
	IsMarkedForDeletion:                      "IsMarkedForDeletion",
}

var DataPlatformContractItemDatumTableColumns = struct {
	Contract                                 string
	ContractItem                             string
	ContractItemCategory                     string
	ContractStatus                           string
	SupplyChainRelationshipID                string
	SupplyChainRelationshipDeliveryID        string
	SupplyChainRelationshipDeliveryPlantID   string
	SupplyChainRelationshipProductionPlantID string
	Buyer                                    string
	Seller                                   string
	DeliverToParty                           string
	DeliverFromParty                         string
	DeliverToPlant                           string
	DeliverFromPlant                         string
	ContractItemText                         string
	ContractItemTextByBuyer                  string
	ContractItemTextBySeller                 string
	Product                                  string
	ProductStandardID                        string
	ProductGroup                             string
	ProductSpecification                     string
	MarkingOfMaterial                        string
	BaseUnit                                 string
	DeliveryUnit                             string
	BillOfMaterial                           string
	BillOfMaterialItem                       string
	PricingDate                              string
	PriceDetnExchangeRate                    string
	ServicesRenderingDate                    string
	ContractQuantityInBaseUnit               string
	ContractQuantityInDeliveryUnit           string
	QuantityPerPackage                       string
	InternalCapacityQuantity                 string
	InternalCapacityQuantityUnit             string
	NetAmount                                string
	TaxAmount                                string
	GrossAmount                              string
	InvoiceDocumentDate                      string
	ProductionPlantBusinessPartner           string
	ProductionPlant                          string
	InspectionPlantBusinessPartner           string
	InspectionPlant                          string
	InspectionPlan                           string
	InspectionLot                            string
	TransactionTaxClassification             string
	ProductTaxClassificationBillToCountry    string
	ProductTaxClassificationBillFromCountry  string
	DefinedTaxClassification                 string
	AccountAssignmentGroup                   string
	ProductAccountAssignmentGroup            string
	PaymentTerms                             string
	DueCalculationBaseDate                   string
	PaymentDueDate                           string
	NetPaymentDays                           string
	PaymentMethod                            string
	Project                                  string
	WBSElement                               string
	AccountingExchangeRate                   string
	TaxCode                                  string
	TaxRate                                  string
	CountryOfOrigin                          string
	CountryOfOriginLanguage                  string
	Equipment                                string
	ItemBlockStatus                          string
	ExternalReferenceDocument                string
	ExternalReferenceDocumentItem            string
	CreationDate                             string
	CreationTime                             string
	LastChangeDate                           string
	LastChangeTime                           string
	IsCancelled                              string
	IsMarkedForDeletion                      string
}{
	Contract:                                 "data_platform_contract_item_data.Contract",
	ContractItem:                             "data_platform_contract_item_data.ContractItem",
	ContractItemCategory:                     "data_platform_contract_item_data.ContractItemCategory",
	ContractStatus:                           "data_platform_contract_item_data.ContractStatus",
	SupplyChainRelationshipID:                "data_platform_contract_item_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:        "data_platform_contract_item_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:   "data_platform_contract_item_data.SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipProductionPlantID: "data_platform_contract_item_data.SupplyChainRelationshipProductionPlantID",
	Buyer:                                    "data_platform_contract_item_data.Buyer",
	Seller:                                   "data_platform_contract_item_data.Seller",
	DeliverToParty:                           "data_platform_contract_item_data.DeliverToParty",
	DeliverFromParty:                         "data_platform_contract_item_data.DeliverFromParty",
	DeliverToPlant:                           "data_platform_contract_item_data.DeliverToPlant",
	DeliverFromPlant:                         "data_platform_contract_item_data.DeliverFromPlant",
	ContractItemText:                         "data_platform_contract_item_data.ContractItemText",
	ContractItemTextByBuyer:                  "data_platform_contract_item_data.ContractItemTextByBuyer",
	ContractItemTextBySeller:                 "data_platform_contract_item_data.ContractItemTextBySeller",
	Product:                                  "data_platform_contract_item_data.Product",
	ProductStandardID:                        "data_platform_contract_item_data.ProductStandardID",
	ProductGroup:                             "data_platform_contract_item_data.ProductGroup",
	ProductSpecification:                     "data_platform_contract_item_data.ProductSpecification",
	MarkingOfMaterial:                        "data_platform_contract_item_data.MarkingOfMaterial",
	BaseUnit:                                 "data_platform_contract_item_data.BaseUnit",
	DeliveryUnit:                             "data_platform_contract_item_data.DeliveryUnit",
	BillOfMaterial:                           "data_platform_contract_item_data.BillOfMaterial",
	BillOfMaterialItem:                       "data_platform_contract_item_data.BillOfMaterialItem",
	PricingDate:                              "data_platform_contract_item_data.PricingDate",
	PriceDetnExchangeRate:                    "data_platform_contract_item_data.PriceDetnExchangeRate",
	ServicesRenderingDate:                    "data_platform_contract_item_data.ServicesRenderingDate",
	ContractQuantityInBaseUnit:               "data_platform_contract_item_data.ContractQuantityInBaseUnit",
	ContractQuantityInDeliveryUnit:           "data_platform_contract_item_data.ContractQuantityInDeliveryUnit",
	QuantityPerPackage:                       "data_platform_contract_item_data.QuantityPerPackage",
	InternalCapacityQuantity:                 "data_platform_contract_item_data.InternalCapacityQuantity",
	InternalCapacityQuantityUnit:             "data_platform_contract_item_data.InternalCapacityQuantityUnit",
	NetAmount:                                "data_platform_contract_item_data.NetAmount",
	TaxAmount:                                "data_platform_contract_item_data.TaxAmount",
	GrossAmount:                              "data_platform_contract_item_data.GrossAmount",
	InvoiceDocumentDate:                      "data_platform_contract_item_data.InvoiceDocumentDate",
	ProductionPlantBusinessPartner:           "data_platform_contract_item_data.ProductionPlantBusinessPartner",
	ProductionPlant:                          "data_platform_contract_item_data.ProductionPlant",
	InspectionPlantBusinessPartner:           "data_platform_contract_item_data.InspectionPlantBusinessPartner",
	InspectionPlant:                          "data_platform_contract_item_data.InspectionPlant",
	InspectionPlan:                           "data_platform_contract_item_data.InspectionPlan",
	InspectionLot:                            "data_platform_contract_item_data.InspectionLot",
	TransactionTaxClassification:             "data_platform_contract_item_data.TransactionTaxClassification",
	ProductTaxClassificationBillToCountry:    "data_platform_contract_item_data.ProductTaxClassificationBillToCountry",
	ProductTaxClassificationBillFromCountry:  "data_platform_contract_item_data.ProductTaxClassificationBillFromCountry",
	DefinedTaxClassification:                 "data_platform_contract_item_data.DefinedTaxClassification",
	AccountAssignmentGroup:                   "data_platform_contract_item_data.AccountAssignmentGroup",
	ProductAccountAssignmentGroup:            "data_platform_contract_item_data.ProductAccountAssignmentGroup",
	PaymentTerms:                             "data_platform_contract_item_data.PaymentTerms",
	DueCalculationBaseDate:                   "data_platform_contract_item_data.DueCalculationBaseDate",
	PaymentDueDate:                           "data_platform_contract_item_data.PaymentDueDate",
	NetPaymentDays:                           "data_platform_contract_item_data.NetPaymentDays",
	PaymentMethod:                            "data_platform_contract_item_data.PaymentMethod",
	Project:                                  "data_platform_contract_item_data.Project",
	WBSElement:                               "data_platform_contract_item_data.WBSElement",
	AccountingExchangeRate:                   "data_platform_contract_item_data.AccountingExchangeRate",
	TaxCode:                                  "data_platform_contract_item_data.TaxCode",
	TaxRate:                                  "data_platform_contract_item_data.TaxRate",
	CountryOfOrigin:                          "data_platform_contract_item_data.CountryOfOrigin",
	CountryOfOriginLanguage:                  "data_platform_contract_item_data.CountryOfOriginLanguage",
	Equipment:                                "data_platform_contract_item_data.Equipment",
	ItemBlockStatus:                          "data_platform_contract_item_data.ItemBlockStatus",
	ExternalReferenceDocument:                "data_platform_contract_item_data.ExternalReferenceDocument",
	ExternalReferenceDocumentItem:            "data_platform_contract_item_data.ExternalReferenceDocumentItem",
	CreationDate:                             "data_platform_contract_item_data.CreationDate",
	CreationTime:                             "data_platform_contract_item_data.CreationTime",
	LastChangeDate:                           "data_platform_contract_item_data.LastChangeDate",
	LastChangeTime:                           "data_platform_contract_item_data.LastChangeTime",
	IsCancelled:                              "data_platform_contract_item_data.IsCancelled",
	IsMarkedForDeletion:                      "data_platform_contract_item_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformContractItemDatumWhere = struct {
	Contract                                 whereHelperint
	ContractItem                             whereHelperint
	ContractItemCategory                     whereHelperstring
	ContractStatus                           whereHelperstring
	SupplyChainRelationshipID                whereHelperint
	SupplyChainRelationshipDeliveryID        whereHelpernull_Int
	SupplyChainRelationshipDeliveryPlantID   whereHelpernull_Int
	SupplyChainRelationshipProductionPlantID whereHelpernull_Int
	Buyer                                    whereHelperint
	Seller                                   whereHelperint
	DeliverToParty                           whereHelpernull_Int
	DeliverFromParty                         whereHelpernull_Int
	DeliverToPlant                           whereHelpernull_String
	DeliverFromPlant                         whereHelpernull_String
	ContractItemText                         whereHelperstring
	ContractItemTextByBuyer                  whereHelperstring
	ContractItemTextBySeller                 whereHelperstring
	Product                                  whereHelperstring
	ProductStandardID                        whereHelpernull_String
	ProductGroup                             whereHelpernull_String
	ProductSpecification                     whereHelpernull_String
	MarkingOfMaterial                        whereHelpernull_String
	BaseUnit                                 whereHelperstring
	DeliveryUnit                             whereHelpernull_String
	BillOfMaterial                           whereHelpernull_Int
	BillOfMaterialItem                       whereHelpernull_Int
	PricingDate                              whereHelpernull_String
	PriceDetnExchangeRate                    whereHelpernull_Float32
	ServicesRenderingDate                    whereHelpernull_String
	ContractQuantityInBaseUnit               whereHelpernull_Float32
	ContractQuantityInDeliveryUnit           whereHelpernull_Float32
	QuantityPerPackage                       whereHelpernull_Float32
	InternalCapacityQuantity                 whereHelpernull_Float32
	InternalCapacityQuantityUnit             whereHelpernull_String
	NetAmount                                whereHelperfloat32
	TaxAmount                                whereHelperfloat32
	GrossAmount                              whereHelperfloat32
	InvoiceDocumentDate                      whereHelpernull_String
	ProductionPlantBusinessPartner           whereHelpernull_Int
	ProductionPlant                          whereHelpernull_String
	InspectionPlantBusinessPartner           whereHelpernull_Int
	InspectionPlant                          whereHelpernull_String
	InspectionPlan                           whereHelpernull_Int
	InspectionLot                            whereHelpernull_Int
	TransactionTaxClassification             whereHelperstring
	ProductTaxClassificationBillToCountry    whereHelperstring
	ProductTaxClassificationBillFromCountry  whereHelperstring
	DefinedTaxClassification                 whereHelperstring
	AccountAssignmentGroup                   whereHelperstring
	ProductAccountAssignmentGroup            whereHelperstring
	PaymentTerms                             whereHelperstring
	DueCalculationBaseDate                   whereHelpernull_String
	PaymentDueDate                           whereHelpernull_String
	NetPaymentDays                           whereHelpernull_Int
	PaymentMethod                            whereHelperstring
	Project                                  whereHelpernull_Int
	WBSElement                               whereHelpernull_Int
	AccountingExchangeRate                   whereHelpernull_Float32
	TaxCode                                  whereHelpernull_String
	TaxRate                                  whereHelpernull_Float32
	CountryOfOrigin                          whereHelpernull_String
	CountryOfOriginLanguage                  whereHelpernull_String
	Equipment                                whereHelpernull_Int
	ItemBlockStatus                          whereHelpernull_Bool
	ExternalReferenceDocument                whereHelpernull_String
	ExternalReferenceDocumentItem            whereHelpernull_String
	CreationDate                             whereHelperstring
	CreationTime                             whereHelperstring
	LastChangeDate                           whereHelperstring
	LastChangeTime                           whereHelperstring
	IsCancelled                              whereHelpernull_Bool
	IsMarkedForDeletion                      whereHelpernull_Bool
}{
	Contract:                                 whereHelperint{field: "`data_platform_contract_item_data`.`Contract`"},
	ContractItem:                             whereHelperint{field: "`data_platform_contract_item_data`.`ContractItem`"},
	ContractItemCategory:                     whereHelperstring{field: "`data_platform_contract_item_data`.`ContractItemCategory`"},
	ContractStatus:                           whereHelperstring{field: "`data_platform_contract_item_data`.`ContractStatus`"},
	SupplyChainRelationshipID:                whereHelperint{field: "`data_platform_contract_item_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:        whereHelpernull_Int{field: "`data_platform_contract_item_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID:   whereHelpernull_Int{field: "`data_platform_contract_item_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	SupplyChainRelationshipProductionPlantID: whereHelpernull_Int{field: "`data_platform_contract_item_data`.`SupplyChainRelationshipProductionPlantID`"},
	Buyer:                                    whereHelperint{field: "`data_platform_contract_item_data`.`Buyer`"},
	Seller:                                   whereHelperint{field: "`data_platform_contract_item_data`.`Seller`"},
	DeliverToParty:                           whereHelpernull_Int{field: "`data_platform_contract_item_data`.`DeliverToParty`"},
	DeliverFromParty:                         whereHelpernull_Int{field: "`data_platform_contract_item_data`.`DeliverFromParty`"},
	DeliverToPlant:                           whereHelpernull_String{field: "`data_platform_contract_item_data`.`DeliverToPlant`"},
	DeliverFromPlant:                         whereHelpernull_String{field: "`data_platform_contract_item_data`.`DeliverFromPlant`"},
	ContractItemText:                         whereHelperstring{field: "`data_platform_contract_item_data`.`ContractItemText`"},
	ContractItemTextByBuyer:                  whereHelperstring{field: "`data_platform_contract_item_data`.`ContractItemTextByBuyer`"},
	ContractItemTextBySeller:                 whereHelperstring{field: "`data_platform_contract_item_data`.`ContractItemTextBySeller`"},
	Product:                                  whereHelperstring{field: "`data_platform_contract_item_data`.`Product`"},
	ProductStandardID:                        whereHelpernull_String{field: "`data_platform_contract_item_data`.`ProductStandardID`"},
	ProductGroup:                             whereHelpernull_String{field: "`data_platform_contract_item_data`.`ProductGroup`"},
	ProductSpecification:                     whereHelpernull_String{field: "`data_platform_contract_item_data`.`ProductSpecification`"},
	MarkingOfMaterial:                        whereHelpernull_String{field: "`data_platform_contract_item_data`.`MarkingOfMaterial`"},
	BaseUnit:                                 whereHelperstring{field: "`data_platform_contract_item_data`.`BaseUnit`"},
	DeliveryUnit:                             whereHelpernull_String{field: "`data_platform_contract_item_data`.`DeliveryUnit`"},
	BillOfMaterial:                           whereHelpernull_Int{field: "`data_platform_contract_item_data`.`BillOfMaterial`"},
	BillOfMaterialItem:                       whereHelpernull_Int{field: "`data_platform_contract_item_data`.`BillOfMaterialItem`"},
	PricingDate:                              whereHelpernull_String{field: "`data_platform_contract_item_data`.`PricingDate`"},
	PriceDetnExchangeRate:                    whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`PriceDetnExchangeRate`"},
	ServicesRenderingDate:                    whereHelpernull_String{field: "`data_platform_contract_item_data`.`ServicesRenderingDate`"},
	ContractQuantityInBaseUnit:               whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`ContractQuantityInBaseUnit`"},
	ContractQuantityInDeliveryUnit:           whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`ContractQuantityInDeliveryUnit`"},
	QuantityPerPackage:                       whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`QuantityPerPackage`"},
	InternalCapacityQuantity:                 whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`InternalCapacityQuantity`"},
	InternalCapacityQuantityUnit:             whereHelpernull_String{field: "`data_platform_contract_item_data`.`InternalCapacityQuantityUnit`"},
	NetAmount:                                whereHelperfloat32{field: "`data_platform_contract_item_data`.`NetAmount`"},
	TaxAmount:                                whereHelperfloat32{field: "`data_platform_contract_item_data`.`TaxAmount`"},
	GrossAmount:                              whereHelperfloat32{field: "`data_platform_contract_item_data`.`GrossAmount`"},
	InvoiceDocumentDate:                      whereHelpernull_String{field: "`data_platform_contract_item_data`.`InvoiceDocumentDate`"},
	ProductionPlantBusinessPartner:           whereHelpernull_Int{field: "`data_platform_contract_item_data`.`ProductionPlantBusinessPartner`"},
	ProductionPlant:                          whereHelpernull_String{field: "`data_platform_contract_item_data`.`ProductionPlant`"},
	InspectionPlantBusinessPartner:           whereHelpernull_Int{field: "`data_platform_contract_item_data`.`InspectionPlantBusinessPartner`"},
	InspectionPlant:                          whereHelpernull_String{field: "`data_platform_contract_item_data`.`InspectionPlant`"},
	InspectionPlan:                           whereHelpernull_Int{field: "`data_platform_contract_item_data`.`InspectionPlan`"},
	InspectionLot:                            whereHelpernull_Int{field: "`data_platform_contract_item_data`.`InspectionLot`"},
	TransactionTaxClassification:             whereHelperstring{field: "`data_platform_contract_item_data`.`TransactionTaxClassification`"},
	ProductTaxClassificationBillToCountry:    whereHelperstring{field: "`data_platform_contract_item_data`.`ProductTaxClassificationBillToCountry`"},
	ProductTaxClassificationBillFromCountry:  whereHelperstring{field: "`data_platform_contract_item_data`.`ProductTaxClassificationBillFromCountry`"},
	DefinedTaxClassification:                 whereHelperstring{field: "`data_platform_contract_item_data`.`DefinedTaxClassification`"},
	AccountAssignmentGroup:                   whereHelperstring{field: "`data_platform_contract_item_data`.`AccountAssignmentGroup`"},
	ProductAccountAssignmentGroup:            whereHelperstring{field: "`data_platform_contract_item_data`.`ProductAccountAssignmentGroup`"},
	PaymentTerms:                             whereHelperstring{field: "`data_platform_contract_item_data`.`PaymentTerms`"},
	DueCalculationBaseDate:                   whereHelpernull_String{field: "`data_platform_contract_item_data`.`DueCalculationBaseDate`"},
	PaymentDueDate:                           whereHelpernull_String{field: "`data_platform_contract_item_data`.`PaymentDueDate`"},
	NetPaymentDays:                           whereHelpernull_Int{field: "`data_platform_contract_item_data`.`NetPaymentDays`"},
	PaymentMethod:                            whereHelperstring{field: "`data_platform_contract_item_data`.`PaymentMethod`"},
	Project:                                  whereHelpernull_Int{field: "`data_platform_contract_item_data`.`Project`"},
	WBSElement:                               whereHelpernull_Int{field: "`data_platform_contract_item_data`.`WBSElement`"},
	AccountingExchangeRate:                   whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`AccountingExchangeRate`"},
	TaxCode:                                  whereHelpernull_String{field: "`data_platform_contract_item_data`.`TaxCode`"},
	TaxRate:                                  whereHelpernull_Float32{field: "`data_platform_contract_item_data`.`TaxRate`"},
	CountryOfOrigin:                          whereHelpernull_String{field: "`data_platform_contract_item_data`.`CountryOfOrigin`"},
	CountryOfOriginLanguage:                  whereHelpernull_String{field: "`data_platform_contract_item_data`.`CountryOfOriginLanguage`"},
	Equipment:                                whereHelpernull_Int{field: "`data_platform_contract_item_data`.`Equipment`"},
	ItemBlockStatus:                          whereHelpernull_Bool{field: "`data_platform_contract_item_data`.`ItemBlockStatus`"},
	ExternalReferenceDocument:                whereHelpernull_String{field: "`data_platform_contract_item_data`.`ExternalReferenceDocument`"},
	ExternalReferenceDocumentItem:            whereHelpernull_String{field: "`data_platform_contract_item_data`.`ExternalReferenceDocumentItem`"},
	CreationDate:                             whereHelperstring{field: "`data_platform_contract_item_data`.`CreationDate`"},
	CreationTime:                             whereHelperstring{field: "`data_platform_contract_item_data`.`CreationTime`"},
	LastChangeDate:                           whereHelperstring{field: "`data_platform_contract_item_data`.`LastChangeDate`"},
	LastChangeTime:                           whereHelperstring{field: "`data_platform_contract_item_data`.`LastChangeTime`"},
	IsCancelled:                              whereHelpernull_Bool{field: "`data_platform_contract_item_data`.`IsCancelled`"},
	IsMarkedForDeletion:                      whereHelpernull_Bool{field: "`data_platform_contract_item_data`.`IsMarkedForDeletion`"},
}

// DataPlatformContractItemDatumRels is where relationship names are stored.
var DataPlatformContractItemDatumRels = struct {
	ContractDataPlatformDeliveryDocumentHeaderData string
	ContractDataPlatformDeliveryDocumentItemData   string
	ContractDataPlatformOrdersHeaderData           string
	ContractDataPlatformOrdersItemData             string
}{
	ContractDataPlatformDeliveryDocumentHeaderData: "ContractDataPlatformDeliveryDocumentHeaderData",
	ContractDataPlatformDeliveryDocumentItemData:   "ContractDataPlatformDeliveryDocumentItemData",
	ContractDataPlatformOrdersHeaderData:           "ContractDataPlatformOrdersHeaderData",
	ContractDataPlatformOrdersItemData:             "ContractDataPlatformOrdersItemData",
}

// dataPlatformContractItemDatumR is where relationships are stored.
type dataPlatformContractItemDatumR struct {
	ContractDataPlatformDeliveryDocumentHeaderData DataPlatformDeliveryDocumentHeaderDatumSlice `boil:"ContractDataPlatformDeliveryDocumentHeaderData" json:"ContractDataPlatformDeliveryDocumentHeaderData" toml:"ContractDataPlatformDeliveryDocumentHeaderData" yaml:"ContractDataPlatformDeliveryDocumentHeaderData"`
	ContractDataPlatformDeliveryDocumentItemData   DataPlatformDeliveryDocumentItemDatumSlice   `boil:"ContractDataPlatformDeliveryDocumentItemData" json:"ContractDataPlatformDeliveryDocumentItemData" toml:"ContractDataPlatformDeliveryDocumentItemData" yaml:"ContractDataPlatformDeliveryDocumentItemData"`
	ContractDataPlatformOrdersHeaderData           DataPlatformOrdersHeaderDatumSlice           `boil:"ContractDataPlatformOrdersHeaderData" json:"ContractDataPlatformOrdersHeaderData" toml:"ContractDataPlatformOrdersHeaderData" yaml:"ContractDataPlatformOrdersHeaderData"`
	ContractDataPlatformOrdersItemData             DataPlatformOrdersItemDatumSlice             `boil:"ContractDataPlatformOrdersItemData" json:"ContractDataPlatformOrdersItemData" toml:"ContractDataPlatformOrdersItemData" yaml:"ContractDataPlatformOrdersItemData"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformContractItemDatumR) NewStruct() *dataPlatformContractItemDatumR {
	return &dataPlatformContractItemDatumR{}
}

func (r *dataPlatformContractItemDatumR) GetContractDataPlatformDeliveryDocumentHeaderData() DataPlatformDeliveryDocumentHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformDeliveryDocumentHeaderData
}

func (r *dataPlatformContractItemDatumR) GetContractDataPlatformDeliveryDocumentItemData() DataPlatformDeliveryDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformDeliveryDocumentItemData
}

func (r *dataPlatformContractItemDatumR) GetContractDataPlatformOrdersHeaderData() DataPlatformOrdersHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformOrdersHeaderData
}

func (r *dataPlatformContractItemDatumR) GetContractDataPlatformOrdersItemData() DataPlatformOrdersItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformOrdersItemData
}

// dataPlatformContractItemDatumL is where Load methods for each relationship are stored.
type dataPlatformContractItemDatumL struct{}

var (
	dataPlatformContractItemDatumAllColumns            = []string{"Contract", "ContractItem", "ContractItemCategory", "ContractStatus", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipProductionPlantID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "ContractItemText", "ContractItemTextByBuyer", "ContractItemTextBySeller", "Product", "ProductStandardID", "ProductGroup", "ProductSpecification", "MarkingOfMaterial", "BaseUnit", "DeliveryUnit", "BillOfMaterial", "BillOfMaterialItem", "PricingDate", "PriceDetnExchangeRate", "ServicesRenderingDate", "ContractQuantityInBaseUnit", "ContractQuantityInDeliveryUnit", "QuantityPerPackage", "InternalCapacityQuantity", "InternalCapacityQuantityUnit", "NetAmount", "TaxAmount", "GrossAmount", "InvoiceDocumentDate", "ProductionPlantBusinessPartner", "ProductionPlant", "InspectionPlantBusinessPartner", "InspectionPlant", "InspectionPlan", "InspectionLot", "TransactionTaxClassification", "ProductTaxClassificationBillToCountry", "ProductTaxClassificationBillFromCountry", "DefinedTaxClassification", "AccountAssignmentGroup", "ProductAccountAssignmentGroup", "PaymentTerms", "DueCalculationBaseDate", "PaymentDueDate", "NetPaymentDays", "PaymentMethod", "Project", "WBSElement", "AccountingExchangeRate", "TaxCode", "TaxRate", "CountryOfOrigin", "CountryOfOriginLanguage", "Equipment", "ItemBlockStatus", "ExternalReferenceDocument", "ExternalReferenceDocumentItem", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformContractItemDatumColumnsWithoutDefault = []string{"Contract", "ContractItem", "ContractItemCategory", "ContractStatus", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipProductionPlantID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "ContractItemText", "ContractItemTextByBuyer", "ContractItemTextBySeller", "Product", "ProductStandardID", "ProductGroup", "ProductSpecification", "MarkingOfMaterial", "BaseUnit", "DeliveryUnit", "BillOfMaterial", "BillOfMaterialItem", "PricingDate", "PriceDetnExchangeRate", "ServicesRenderingDate", "ContractQuantityInBaseUnit", "ContractQuantityInDeliveryUnit", "QuantityPerPackage", "InternalCapacityQuantity", "InternalCapacityQuantityUnit", "NetAmount", "TaxAmount", "GrossAmount", "InvoiceDocumentDate", "ProductionPlantBusinessPartner", "ProductionPlant", "InspectionPlantBusinessPartner", "InspectionPlant", "InspectionPlan", "InspectionLot", "TransactionTaxClassification", "ProductTaxClassificationBillToCountry", "ProductTaxClassificationBillFromCountry", "DefinedTaxClassification", "AccountAssignmentGroup", "ProductAccountAssignmentGroup", "PaymentTerms", "DueCalculationBaseDate", "PaymentDueDate", "NetPaymentDays", "PaymentMethod", "Project", "WBSElement", "AccountingExchangeRate", "TaxCode", "TaxRate", "CountryOfOrigin", "CountryOfOriginLanguage", "Equipment", "ItemBlockStatus", "ExternalReferenceDocument", "ExternalReferenceDocumentItem", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformContractItemDatumColumnsWithDefault    = []string{}
	dataPlatformContractItemDatumPrimaryKeyColumns     = []string{"Contract", "ContractItem"}
	dataPlatformContractItemDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformContractItemDatumSlice is an alias for a slice of pointers to DataPlatformContractItemDatum.
	// This should almost always be used instead of []DataPlatformContractItemDatum.
	DataPlatformContractItemDatumSlice []*DataPlatformContractItemDatum

	dataPlatformContractItemDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformContractItemDatumType                 = reflect.TypeOf(&DataPlatformContractItemDatum{})
	dataPlatformContractItemDatumMapping              = queries.MakeStructMapping(dataPlatformContractItemDatumType)
	dataPlatformContractItemDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, dataPlatformContractItemDatumPrimaryKeyColumns)
	dataPlatformContractItemDatumInsertCacheMut       sync.RWMutex
	dataPlatformContractItemDatumInsertCache          = make(map[string]insertCache)
	dataPlatformContractItemDatumUpdateCacheMut       sync.RWMutex
	dataPlatformContractItemDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformContractItemDatumUpsertCacheMut       sync.RWMutex
	dataPlatformContractItemDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformContractItemDatum record from the query.
func (q dataPlatformContractItemDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformContractItemDatum, error) {
	o := &DataPlatformContractItemDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_contract_item_data")
	}

	return o, nil
}

// All returns all DataPlatformContractItemDatum records from the query.
func (q dataPlatformContractItemDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformContractItemDatumSlice, error) {
	var o []*DataPlatformContractItemDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformContractItemDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformContractItemDatum records in the query.
func (q dataPlatformContractItemDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_contract_item_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformContractItemDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_contract_item_data exists")
	}

	return count > 0, nil
}

// ContractDataPlatformDeliveryDocumentHeaderData retrieves all the data_platform_delivery_document_header_datum's DataPlatformDeliveryDocumentHeaderData with an executor via Contract column.
func (o *DataPlatformContractItemDatum) ContractDataPlatformDeliveryDocumentHeaderData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_header_data`.`Contract`=?", o.Contract),
	)

	return DataPlatformDeliveryDocumentHeaderData(queryMods...)
}

// ContractDataPlatformDeliveryDocumentItemData retrieves all the data_platform_delivery_document_item_datum's DataPlatformDeliveryDocumentItemData with an executor via Contract column.
func (o *DataPlatformContractItemDatum) ContractDataPlatformDeliveryDocumentItemData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_item_data`.`Contract`=?", o.Contract),
	)

	return DataPlatformDeliveryDocumentItemData(queryMods...)
}

// ContractDataPlatformOrdersHeaderData retrieves all the data_platform_orders_header_datum's DataPlatformOrdersHeaderData with an executor via Contract column.
func (o *DataPlatformContractItemDatum) ContractDataPlatformOrdersHeaderData(mods ...qm.QueryMod) dataPlatformOrdersHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_header_data`.`Contract`=?", o.Contract),
	)

	return DataPlatformOrdersHeaderData(queryMods...)
}

// ContractDataPlatformOrdersItemData retrieves all the data_platform_orders_item_datum's DataPlatformOrdersItemData with an executor via Contract column.
func (o *DataPlatformContractItemDatum) ContractDataPlatformOrdersItemData(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_data`.`Contract`=?", o.Contract),
	)

	return DataPlatformOrdersItemData(queryMods...)
}

// LoadContractDataPlatformDeliveryDocumentHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformContractItemDatumL) LoadContractDataPlatformDeliveryDocumentHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformContractItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformContractItemDatum
	var object *DataPlatformContractItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformContractItemDatum.(*DataPlatformContractItemDatum)
		if !ok {
			object = new(DataPlatformContractItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformContractItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformContractItemDatum.(*[]*DataPlatformContractItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformContractItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformContractItemDatumR{}
		}
		args = append(args, object.Contract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformContractItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			args = append(args, obj.Contract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_header_data`),
		qm.WhereIn(`data_platform_delivery_document_header_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_header_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_header_data")
	}

	if singular {
		object.R.ContractDataPlatformDeliveryDocumentHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformDeliveryDocumentHeaderData = append(local.R.ContractDataPlatformDeliveryDocumentHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformDeliveryDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformContractItemDatumL) LoadContractDataPlatformDeliveryDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformContractItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformContractItemDatum
	var object *DataPlatformContractItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformContractItemDatum.(*DataPlatformContractItemDatum)
		if !ok {
			object = new(DataPlatformContractItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformContractItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformContractItemDatum.(*[]*DataPlatformContractItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformContractItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformContractItemDatumR{}
		}
		args = append(args, object.Contract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformContractItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			args = append(args, obj.Contract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_item_data`),
		qm.WhereIn(`data_platform_delivery_document_item_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_item_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_item_data")
	}

	if singular {
		object.R.ContractDataPlatformDeliveryDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformDeliveryDocumentItemData = append(local.R.ContractDataPlatformDeliveryDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformOrdersHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformContractItemDatumL) LoadContractDataPlatformOrdersHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformContractItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformContractItemDatum
	var object *DataPlatformContractItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformContractItemDatum.(*DataPlatformContractItemDatum)
		if !ok {
			object = new(DataPlatformContractItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformContractItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformContractItemDatum.(*[]*DataPlatformContractItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformContractItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformContractItemDatumR{}
		}
		args = append(args, object.Contract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformContractItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			args = append(args, obj.Contract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_header_data`),
		qm.WhereIn(`data_platform_orders_header_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_header_data")
	}

	var resultSlice []*DataPlatformOrdersHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_header_data")
	}

	if singular {
		object.R.ContractDataPlatformOrdersHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformOrdersHeaderData = append(local.R.ContractDataPlatformOrdersHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformOrdersItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformContractItemDatumL) LoadContractDataPlatformOrdersItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformContractItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformContractItemDatum
	var object *DataPlatformContractItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformContractItemDatum.(*DataPlatformContractItemDatum)
		if !ok {
			object = new(DataPlatformContractItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformContractItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformContractItemDatum.(*[]*DataPlatformContractItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformContractItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformContractItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformContractItemDatumR{}
		}
		args = append(args, object.Contract)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformContractItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			args = append(args, obj.Contract)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_data")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if singular {
		object.R.ContractDataPlatformOrdersItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformOrdersItemData = append(local.R.ContractDataPlatformOrdersItemData, foreign)
				break
			}
		}
	}

	return nil
}

// AddContractDataPlatformDeliveryDocumentHeaderData adds the given related objects to the existing relationships
// of the data_platform_contract_item_datum, optionally inserting them as new records.
// Appends related to o.R.ContractDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformContractItemDatum) AddContractDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Contract, o.Contract)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Contract, rel.DeliveryDocument}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Contract, o.Contract)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformContractItemDatumR{
			ContractDataPlatformDeliveryDocumentHeaderData: related,
		}
	} else {
		o.R.ContractDataPlatformDeliveryDocumentHeaderData = append(o.R.ContractDataPlatformDeliveryDocumentHeaderData, related...)
	}

	return nil
}

// SetContractDataPlatformDeliveryDocumentHeaderData removes all previously related items of the
// data_platform_contract_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ContractDataPlatformContractItemDatum's ContractDataPlatformDeliveryDocumentHeaderData accordingly.
// Replaces o.R.ContractDataPlatformDeliveryDocumentHeaderData with related.
func (o *DataPlatformContractItemDatum) SetContractDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	query := "update `data_platform_delivery_document_header_data` set `Contract` = null where `Contract` = ?"
	values := []interface{}{o.Contract}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ContractDataPlatformDeliveryDocumentHeaderData = nil
	}

	return o.AddContractDataPlatformDeliveryDocumentHeaderData(ctx, exec, insert, related...)
}

// RemoveContractDataPlatformDeliveryDocumentHeaderData relationships from objects passed in.
// Removes related items from R.ContractDataPlatformDeliveryDocumentHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformContractItemDatum) RemoveContractDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Contract, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ContractDataPlatformDeliveryDocumentHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ContractDataPlatformDeliveryDocumentHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.ContractDataPlatformDeliveryDocumentHeaderData[i] = o.R.ContractDataPlatformDeliveryDocumentHeaderData[ln-1]
			}
			o.R.ContractDataPlatformDeliveryDocumentHeaderData = o.R.ContractDataPlatformDeliveryDocumentHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddContractDataPlatformDeliveryDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_contract_item_datum, optionally inserting them as new records.
// Appends related to o.R.ContractDataPlatformDeliveryDocumentItemData.
func (o *DataPlatformContractItemDatum) AddContractDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Contract, o.Contract)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Contract, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Contract, o.Contract)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformContractItemDatumR{
			ContractDataPlatformDeliveryDocumentItemData: related,
		}
	} else {
		o.R.ContractDataPlatformDeliveryDocumentItemData = append(o.R.ContractDataPlatformDeliveryDocumentItemData, related...)
	}

	return nil
}

// SetContractDataPlatformDeliveryDocumentItemData removes all previously related items of the
// data_platform_contract_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ContractDataPlatformContractItemDatum's ContractDataPlatformDeliveryDocumentItemData accordingly.
// Replaces o.R.ContractDataPlatformDeliveryDocumentItemData with related.
func (o *DataPlatformContractItemDatum) SetContractDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	query := "update `data_platform_delivery_document_item_data` set `Contract` = null where `Contract` = ?"
	values := []interface{}{o.Contract}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ContractDataPlatformDeliveryDocumentItemData = nil
	}

	return o.AddContractDataPlatformDeliveryDocumentItemData(ctx, exec, insert, related...)
}

// RemoveContractDataPlatformDeliveryDocumentItemData relationships from objects passed in.
// Removes related items from R.ContractDataPlatformDeliveryDocumentItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformContractItemDatum) RemoveContractDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Contract, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ContractDataPlatformDeliveryDocumentItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ContractDataPlatformDeliveryDocumentItemData)
			if ln > 1 && i < ln-1 {
				o.R.ContractDataPlatformDeliveryDocumentItemData[i] = o.R.ContractDataPlatformDeliveryDocumentItemData[ln-1]
			}
			o.R.ContractDataPlatformDeliveryDocumentItemData = o.R.ContractDataPlatformDeliveryDocumentItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddContractDataPlatformOrdersHeaderData adds the given related objects to the existing relationships
// of the data_platform_contract_item_datum, optionally inserting them as new records.
// Appends related to o.R.ContractDataPlatformOrdersHeaderData.
func (o *DataPlatformContractItemDatum) AddContractDataPlatformOrdersHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Contract, o.Contract)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Contract, rel.OrderID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Contract, o.Contract)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformContractItemDatumR{
			ContractDataPlatformOrdersHeaderData: related,
		}
	} else {
		o.R.ContractDataPlatformOrdersHeaderData = append(o.R.ContractDataPlatformOrdersHeaderData, related...)
	}

	return nil
}

// SetContractDataPlatformOrdersHeaderData removes all previously related items of the
// data_platform_contract_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ContractDataPlatformContractItemDatum's ContractDataPlatformOrdersHeaderData accordingly.
// Replaces o.R.ContractDataPlatformOrdersHeaderData with related.
func (o *DataPlatformContractItemDatum) SetContractDataPlatformOrdersHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersHeaderDatum) error {
	query := "update `data_platform_orders_header_data` set `Contract` = null where `Contract` = ?"
	values := []interface{}{o.Contract}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ContractDataPlatformOrdersHeaderData = nil
	}

	return o.AddContractDataPlatformOrdersHeaderData(ctx, exec, insert, related...)
}

// RemoveContractDataPlatformOrdersHeaderData relationships from objects passed in.
// Removes related items from R.ContractDataPlatformOrdersHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformContractItemDatum) RemoveContractDataPlatformOrdersHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformOrdersHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Contract, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ContractDataPlatformOrdersHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ContractDataPlatformOrdersHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.ContractDataPlatformOrdersHeaderData[i] = o.R.ContractDataPlatformOrdersHeaderData[ln-1]
			}
			o.R.ContractDataPlatformOrdersHeaderData = o.R.ContractDataPlatformOrdersHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddContractDataPlatformOrdersItemData adds the given related objects to the existing relationships
// of the data_platform_contract_item_datum, optionally inserting them as new records.
// Appends related to o.R.ContractDataPlatformOrdersItemData.
func (o *DataPlatformContractItemDatum) AddContractDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Contract, o.Contract)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Contract, rel.OrderID, rel.OrderItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Contract, o.Contract)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformContractItemDatumR{
			ContractDataPlatformOrdersItemData: related,
		}
	} else {
		o.R.ContractDataPlatformOrdersItemData = append(o.R.ContractDataPlatformOrdersItemData, related...)
	}

	return nil
}

// SetContractDataPlatformOrdersItemData removes all previously related items of the
// data_platform_contract_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ContractDataPlatformContractItemDatum's ContractDataPlatformOrdersItemData accordingly.
// Replaces o.R.ContractDataPlatformOrdersItemData with related.
func (o *DataPlatformContractItemDatum) SetContractDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDatum) error {
	query := "update `data_platform_orders_item_data` set `Contract` = null where `Contract` = ?"
	values := []interface{}{o.Contract}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ContractDataPlatformOrdersItemData = nil
	}

	return o.AddContractDataPlatformOrdersItemData(ctx, exec, insert, related...)
}

// RemoveContractDataPlatformOrdersItemData relationships from objects passed in.
// Removes related items from R.ContractDataPlatformOrdersItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformContractItemDatum) RemoveContractDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformOrdersItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Contract, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ContractDataPlatformOrdersItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ContractDataPlatformOrdersItemData)
			if ln > 1 && i < ln-1 {
				o.R.ContractDataPlatformOrdersItemData[i] = o.R.ContractDataPlatformOrdersItemData[ln-1]
			}
			o.R.ContractDataPlatformOrdersItemData = o.R.ContractDataPlatformOrdersItemData[:ln-1]
			break
		}
	}

	return nil
}

// DataPlatformContractItemData retrieves all the records using an executor.
func DataPlatformContractItemData(mods ...qm.QueryMod) dataPlatformContractItemDatumQuery {
	mods = append(mods, qm.From("`data_platform_contract_item_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_contract_item_data`.*"})
	}

	return dataPlatformContractItemDatumQuery{q}
}

// FindDataPlatformContractItemDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformContractItemDatum(ctx context.Context, exec boil.ContextExecutor, contract int, contractItem int, selectCols ...string) (*DataPlatformContractItemDatum, error) {
	dataPlatformContractItemDatumObj := &DataPlatformContractItemDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_contract_item_data` where `Contract`=? AND `ContractItem`=?", sel,
	)

	q := queries.Raw(query, contract, contractItem)

	err := q.Bind(ctx, exec, dataPlatformContractItemDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_contract_item_data")
	}

	return dataPlatformContractItemDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformContractItemDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_contract_item_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformContractItemDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformContractItemDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformContractItemDatumInsertCache[key]
	dataPlatformContractItemDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformContractItemDatumAllColumns,
			dataPlatformContractItemDatumColumnsWithDefault,
			dataPlatformContractItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_contract_item_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_contract_item_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_contract_item_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformContractItemDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_contract_item_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.Contract,
		o.ContractItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_contract_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformContractItemDatumInsertCacheMut.Lock()
		dataPlatformContractItemDatumInsertCache[key] = cache
		dataPlatformContractItemDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformContractItemDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformContractItemDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformContractItemDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformContractItemDatumUpdateCache[key]
	dataPlatformContractItemDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformContractItemDatumAllColumns,
			dataPlatformContractItemDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_contract_item_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_contract_item_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformContractItemDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, append(wl, dataPlatformContractItemDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_contract_item_data row")
	}

	if !cached {
		dataPlatformContractItemDatumUpdateCacheMut.Lock()
		dataPlatformContractItemDatumUpdateCache[key] = cache
		dataPlatformContractItemDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformContractItemDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_contract_item_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformContractItemDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformContractItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_contract_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformContractItemDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformContractItemDatum slice")
	}

	return nil
}

var mySQLDataPlatformContractItemDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformContractItemDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_contract_item_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformContractItemDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformContractItemDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformContractItemDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformContractItemDatumUpsertCache[key]
	dataPlatformContractItemDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformContractItemDatumAllColumns,
			dataPlatformContractItemDatumColumnsWithDefault,
			dataPlatformContractItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformContractItemDatumAllColumns,
			dataPlatformContractItemDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_contract_item_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_contract_item_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_contract_item_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_contract_item_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformContractItemDatumType, dataPlatformContractItemDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_contract_item_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_contract_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformContractItemDatumUpsertCacheMut.Lock()
		dataPlatformContractItemDatumUpsertCache[key] = cache
		dataPlatformContractItemDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformContractItemDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformContractItemDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformContractItemDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformContractItemDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_contract_item_data` WHERE `Contract`=? AND `ContractItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_contract_item_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformContractItemDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformContractItemDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_contract_item_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformContractItemDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformContractItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_contract_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformContractItemDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformContractItemDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformContractItemDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformContractItemDatum(ctx, exec, o.Contract, o.ContractItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformContractItemDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformContractItemDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformContractItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_contract_item_data`.* FROM `data_platform_contract_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformContractItemDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformContractItemDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformContractItemDatumExists checks if the DataPlatformContractItemDatum row exists.
func DataPlatformContractItemDatumExists(ctx context.Context, exec boil.ContextExecutor, contract int, contractItem int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_contract_item_data` where `Contract`=? AND `ContractItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, contract, contractItem)
	}
	row := exec.QueryRowContext(ctx, sql, contract, contractItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_contract_item_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformContractItemDatum row exists.
func (o *DataPlatformContractItemDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformContractItemDatumExists(ctx, exec, o.Contract, o.ContractItem)
}
