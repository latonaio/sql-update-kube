// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformPlannedOrderItemOperationComponentDatum is an object representing the database table.
type DataPlatformPlannedOrderItemOperationComponentDatum struct {
	PlannedOrder                                             int          `boil:"PlannedOrder" json:"PlannedOrder" toml:"PlannedOrder" yaml:"PlannedOrder"`
	PlannedOrderItem                                         int          `boil:"PlannedOrderItem" json:"PlannedOrderItem" toml:"PlannedOrderItem" yaml:"PlannedOrderItem"`
	Operations                                               int          `boil:"Operations" json:"Operations" toml:"Operations" yaml:"Operations"`
	OperationsItem                                           int          `boil:"OperationsItem" json:"OperationsItem" toml:"OperationsItem" yaml:"OperationsItem"`
	OperationID                                              int          `boil:"OperationID" json:"OperationID" toml:"OperationID" yaml:"OperationID"`
	BillOfMaterial                                           int          `boil:"BillOfMaterial" json:"BillOfMaterial" toml:"BillOfMaterial" yaml:"BillOfMaterial"`
	BillOfMaterialItem                                       int          `boil:"BillOfMaterialItem" json:"BillOfMaterialItem" toml:"BillOfMaterialItem" yaml:"BillOfMaterialItem"`
	SupplyChainRelationshipID                                int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipDeliveryID                        int          `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID"`
	SupplyChainRelationshipDeliveryPlantID                   int          `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID"`
	ProductionPlantBusinessPartner                           int          `boil:"ProductionPlantBusinessPartner" json:"ProductionPlantBusinessPartner" toml:"ProductionPlantBusinessPartner" yaml:"ProductionPlantBusinessPartner"`
	ProductionPlant                                          string       `boil:"ProductionPlant" json:"ProductionPlant" toml:"ProductionPlant" yaml:"ProductionPlant"`
	ComponentProduct                                         string       `boil:"ComponentProduct" json:"ComponentProduct" toml:"ComponentProduct" yaml:"ComponentProduct"`
	ComponentProductBuyer                                    int          `boil:"ComponentProductBuyer" json:"ComponentProductBuyer" toml:"ComponentProductBuyer" yaml:"ComponentProductBuyer"`
	ComponentProductSeller                                   int          `boil:"ComponentProductSeller" json:"ComponentProductSeller" toml:"ComponentProductSeller" yaml:"ComponentProductSeller"`
	ComponentProductDeliverToParty                           int          `boil:"ComponentProductDeliverToParty" json:"ComponentProductDeliverToParty" toml:"ComponentProductDeliverToParty" yaml:"ComponentProductDeliverToParty"`
	ComponentProductDeliverToPlant                           string       `boil:"ComponentProductDeliverToPlant" json:"ComponentProductDeliverToPlant" toml:"ComponentProductDeliverToPlant" yaml:"ComponentProductDeliverToPlant"`
	ComponentProductDeliverFromParty                         int          `boil:"ComponentProductDeliverFromParty" json:"ComponentProductDeliverFromParty" toml:"ComponentProductDeliverFromParty" yaml:"ComponentProductDeliverFromParty"`
	ComponentProductDeliverFromPlant                         string       `boil:"ComponentProductDeliverFromPlant" json:"ComponentProductDeliverFromPlant" toml:"ComponentProductDeliverFromPlant" yaml:"ComponentProductDeliverFromPlant"`
	ComponentProductDeliverToPartyInOperation                int          `boil:"ComponentProductDeliverToPartyInOperation" json:"ComponentProductDeliverToPartyInOperation" toml:"ComponentProductDeliverToPartyInOperation" yaml:"ComponentProductDeliverToPartyInOperation"`
	ComponentProductDeliverToPlantInOperation                string       `boil:"ComponentProductDeliverToPlantInOperation" json:"ComponentProductDeliverToPlantInOperation" toml:"ComponentProductDeliverToPlantInOperation" yaml:"ComponentProductDeliverToPlantInOperation"`
	ComponentProductDeliverFromPartyInOperation              int          `boil:"ComponentProductDeliverFromPartyInOperation" json:"ComponentProductDeliverFromPartyInOperation" toml:"ComponentProductDeliverFromPartyInOperation" yaml:"ComponentProductDeliverFromPartyInOperation"`
	ComponentProductDeliverFromPlantInOperation              string       `boil:"ComponentProductDeliverFromPlantInOperation" json:"ComponentProductDeliverFromPlantInOperation" toml:"ComponentProductDeliverFromPlantInOperation" yaml:"ComponentProductDeliverFromPlantInOperation"`
	ComponentProductRequirementDateInOperation               string       `boil:"ComponentProductRequirementDateInOperation" json:"ComponentProductRequirementDateInOperation" toml:"ComponentProductRequirementDateInOperation" yaml:"ComponentProductRequirementDateInOperation"`
	ComponentProductRequirementTimeInOperation               string       `boil:"ComponentProductRequirementTimeInOperation" json:"ComponentProductRequirementTimeInOperation" toml:"ComponentProductRequirementTimeInOperation" yaml:"ComponentProductRequirementTimeInOperation"`
	ComponentProductPlannedQuantityInBaseUnitInOperation     float32      `boil:"ComponentProductPlannedQuantityInBaseUnitInOperation" json:"ComponentProductPlannedQuantityInBaseUnitInOperation" toml:"ComponentProductPlannedQuantityInBaseUnitInOperation" yaml:"ComponentProductPlannedQuantityInBaseUnitInOperation"`
	ComponentProductPlannedQuantityInDeliveryUnitInOperation float32      `boil:"ComponentProductPlannedQuantityInDeliveryUnitInOperation" json:"ComponentProductPlannedQuantityInDeliveryUnitInOperation" toml:"ComponentProductPlannedQuantityInDeliveryUnitInOperation" yaml:"ComponentProductPlannedQuantityInDeliveryUnitInOperation"`
	ComponentProductPlannedScrapInPercentInOperation         null.Float32 `boil:"ComponentProductPlannedScrapInPercentInOperation" json:"ComponentProductPlannedScrapInPercentInOperation,omitempty" toml:"ComponentProductPlannedScrapInPercentInOperation" yaml:"ComponentProductPlannedScrapInPercentInOperation,omitempty"`
	ComponentProductBaseUnit                                 string       `boil:"ComponentProductBaseUnit" json:"ComponentProductBaseUnit" toml:"ComponentProductBaseUnit" yaml:"ComponentProductBaseUnit"`
	ComponentProductDeliveryUnit                             string       `boil:"ComponentProductDeliveryUnit" json:"ComponentProductDeliveryUnit" toml:"ComponentProductDeliveryUnit" yaml:"ComponentProductDeliveryUnit"`
	ComponentProductIsMarkedForBackflush                     null.Bool    `boil:"ComponentProductIsMarkedForBackflush" json:"ComponentProductIsMarkedForBackflush,omitempty" toml:"ComponentProductIsMarkedForBackflush" yaml:"ComponentProductIsMarkedForBackflush,omitempty"`
	MRPArea                                                  null.String  `boil:"MRPArea" json:"MRPArea,omitempty" toml:"MRPArea" yaml:"MRPArea,omitempty"`
	MRPController                                            null.String  `boil:"MRPController" json:"MRPController,omitempty" toml:"MRPController" yaml:"MRPController,omitempty"`
	ProductionVersion                                        null.Int     `boil:"ProductionVersion" json:"ProductionVersion,omitempty" toml:"ProductionVersion" yaml:"ProductionVersion,omitempty"`
	ProductionVersionItem                                    null.Int     `boil:"ProductionVersionItem" json:"ProductionVersionItem,omitempty" toml:"ProductionVersionItem" yaml:"ProductionVersionItem,omitempty"`
	ComponentProductReservation                              null.Int     `boil:"ComponentProductReservation" json:"ComponentProductReservation,omitempty" toml:"ComponentProductReservation" yaml:"ComponentProductReservation,omitempty"`
	ComponentProductReservationItem                          null.Int     `boil:"ComponentProductReservationItem" json:"ComponentProductReservationItem,omitempty" toml:"ComponentProductReservationItem" yaml:"ComponentProductReservationItem,omitempty"`
	PlannedOrderIsReleased                                   null.Bool    `boil:"PlannedOrderIsReleased" json:"PlannedOrderIsReleased,omitempty" toml:"PlannedOrderIsReleased" yaml:"PlannedOrderIsReleased,omitempty"`
	CreationDate                                             string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                                             string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                                           string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                                           string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsMarkedForDeletion                                      null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformPlannedOrderItemOperationComponentDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformPlannedOrderItemOperationComponentDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformPlannedOrderItemOperationComponentDatumColumns = struct {
	PlannedOrder                                             string
	PlannedOrderItem                                         string
	Operations                                               string
	OperationsItem                                           string
	OperationID                                              string
	BillOfMaterial                                           string
	BillOfMaterialItem                                       string
	SupplyChainRelationshipID                                string
	SupplyChainRelationshipDeliveryID                        string
	SupplyChainRelationshipDeliveryPlantID                   string
	ProductionPlantBusinessPartner                           string
	ProductionPlant                                          string
	ComponentProduct                                         string
	ComponentProductBuyer                                    string
	ComponentProductSeller                                   string
	ComponentProductDeliverToParty                           string
	ComponentProductDeliverToPlant                           string
	ComponentProductDeliverFromParty                         string
	ComponentProductDeliverFromPlant                         string
	ComponentProductDeliverToPartyInOperation                string
	ComponentProductDeliverToPlantInOperation                string
	ComponentProductDeliverFromPartyInOperation              string
	ComponentProductDeliverFromPlantInOperation              string
	ComponentProductRequirementDateInOperation               string
	ComponentProductRequirementTimeInOperation               string
	ComponentProductPlannedQuantityInBaseUnitInOperation     string
	ComponentProductPlannedQuantityInDeliveryUnitInOperation string
	ComponentProductPlannedScrapInPercentInOperation         string
	ComponentProductBaseUnit                                 string
	ComponentProductDeliveryUnit                             string
	ComponentProductIsMarkedForBackflush                     string
	MRPArea                                                  string
	MRPController                                            string
	ProductionVersion                                        string
	ProductionVersionItem                                    string
	ComponentProductReservation                              string
	ComponentProductReservationItem                          string
	PlannedOrderIsReleased                                   string
	CreationDate                                             string
	CreationTime                                             string
	LastChangeDate                                           string
	LastChangeTime                                           string
	IsMarkedForDeletion                                      string
}{
	PlannedOrder:                                             "PlannedOrder",
	PlannedOrderItem:                                         "PlannedOrderItem",
	Operations:                                               "Operations",
	OperationsItem:                                           "OperationsItem",
	OperationID:                                              "OperationID",
	BillOfMaterial:                                           "BillOfMaterial",
	BillOfMaterialItem:                                       "BillOfMaterialItem",
	SupplyChainRelationshipID:                                "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:                        "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:                   "SupplyChainRelationshipDeliveryPlantID",
	ProductionPlantBusinessPartner:                           "ProductionPlantBusinessPartner",
	ProductionPlant:                                          "ProductionPlant",
	ComponentProduct:                                         "ComponentProduct",
	ComponentProductBuyer:                                    "ComponentProductBuyer",
	ComponentProductSeller:                                   "ComponentProductSeller",
	ComponentProductDeliverToParty:                           "ComponentProductDeliverToParty",
	ComponentProductDeliverToPlant:                           "ComponentProductDeliverToPlant",
	ComponentProductDeliverFromParty:                         "ComponentProductDeliverFromParty",
	ComponentProductDeliverFromPlant:                         "ComponentProductDeliverFromPlant",
	ComponentProductDeliverToPartyInOperation:                "ComponentProductDeliverToPartyInOperation",
	ComponentProductDeliverToPlantInOperation:                "ComponentProductDeliverToPlantInOperation",
	ComponentProductDeliverFromPartyInOperation:              "ComponentProductDeliverFromPartyInOperation",
	ComponentProductDeliverFromPlantInOperation:              "ComponentProductDeliverFromPlantInOperation",
	ComponentProductRequirementDateInOperation:               "ComponentProductRequirementDateInOperation",
	ComponentProductRequirementTimeInOperation:               "ComponentProductRequirementTimeInOperation",
	ComponentProductPlannedQuantityInBaseUnitInOperation:     "ComponentProductPlannedQuantityInBaseUnitInOperation",
	ComponentProductPlannedQuantityInDeliveryUnitInOperation: "ComponentProductPlannedQuantityInDeliveryUnitInOperation",
	ComponentProductPlannedScrapInPercentInOperation:         "ComponentProductPlannedScrapInPercentInOperation",
	ComponentProductBaseUnit:                                 "ComponentProductBaseUnit",
	ComponentProductDeliveryUnit:                             "ComponentProductDeliveryUnit",
	ComponentProductIsMarkedForBackflush:                     "ComponentProductIsMarkedForBackflush",
	MRPArea:                                                  "MRPArea",
	MRPController:                                            "MRPController",
	ProductionVersion:                                        "ProductionVersion",
	ProductionVersionItem:                                    "ProductionVersionItem",
	ComponentProductReservation:                              "ComponentProductReservation",
	ComponentProductReservationItem:                          "ComponentProductReservationItem",
	PlannedOrderIsReleased:                                   "PlannedOrderIsReleased",
	CreationDate:                                             "CreationDate",
	CreationTime:                                             "CreationTime",
	LastChangeDate:                                           "LastChangeDate",
	LastChangeTime:                                           "LastChangeTime",
	IsMarkedForDeletion:                                      "IsMarkedForDeletion",
}

var DataPlatformPlannedOrderItemOperationComponentDatumTableColumns = struct {
	PlannedOrder                                             string
	PlannedOrderItem                                         string
	Operations                                               string
	OperationsItem                                           string
	OperationID                                              string
	BillOfMaterial                                           string
	BillOfMaterialItem                                       string
	SupplyChainRelationshipID                                string
	SupplyChainRelationshipDeliveryID                        string
	SupplyChainRelationshipDeliveryPlantID                   string
	ProductionPlantBusinessPartner                           string
	ProductionPlant                                          string
	ComponentProduct                                         string
	ComponentProductBuyer                                    string
	ComponentProductSeller                                   string
	ComponentProductDeliverToParty                           string
	ComponentProductDeliverToPlant                           string
	ComponentProductDeliverFromParty                         string
	ComponentProductDeliverFromPlant                         string
	ComponentProductDeliverToPartyInOperation                string
	ComponentProductDeliverToPlantInOperation                string
	ComponentProductDeliverFromPartyInOperation              string
	ComponentProductDeliverFromPlantInOperation              string
	ComponentProductRequirementDateInOperation               string
	ComponentProductRequirementTimeInOperation               string
	ComponentProductPlannedQuantityInBaseUnitInOperation     string
	ComponentProductPlannedQuantityInDeliveryUnitInOperation string
	ComponentProductPlannedScrapInPercentInOperation         string
	ComponentProductBaseUnit                                 string
	ComponentProductDeliveryUnit                             string
	ComponentProductIsMarkedForBackflush                     string
	MRPArea                                                  string
	MRPController                                            string
	ProductionVersion                                        string
	ProductionVersionItem                                    string
	ComponentProductReservation                              string
	ComponentProductReservationItem                          string
	PlannedOrderIsReleased                                   string
	CreationDate                                             string
	CreationTime                                             string
	LastChangeDate                                           string
	LastChangeTime                                           string
	IsMarkedForDeletion                                      string
}{
	PlannedOrder:                                             "data_platform_planned_order_item_operation_component_data.PlannedOrder",
	PlannedOrderItem:                                         "data_platform_planned_order_item_operation_component_data.PlannedOrderItem",
	Operations:                                               "data_platform_planned_order_item_operation_component_data.Operations",
	OperationsItem:                                           "data_platform_planned_order_item_operation_component_data.OperationsItem",
	OperationID:                                              "data_platform_planned_order_item_operation_component_data.OperationID",
	BillOfMaterial:                                           "data_platform_planned_order_item_operation_component_data.BillOfMaterial",
	BillOfMaterialItem:                                       "data_platform_planned_order_item_operation_component_data.BillOfMaterialItem",
	SupplyChainRelationshipID:                                "data_platform_planned_order_item_operation_component_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:                        "data_platform_planned_order_item_operation_component_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:                   "data_platform_planned_order_item_operation_component_data.SupplyChainRelationshipDeliveryPlantID",
	ProductionPlantBusinessPartner:                           "data_platform_planned_order_item_operation_component_data.ProductionPlantBusinessPartner",
	ProductionPlant:                                          "data_platform_planned_order_item_operation_component_data.ProductionPlant",
	ComponentProduct:                                         "data_platform_planned_order_item_operation_component_data.ComponentProduct",
	ComponentProductBuyer:                                    "data_platform_planned_order_item_operation_component_data.ComponentProductBuyer",
	ComponentProductSeller:                                   "data_platform_planned_order_item_operation_component_data.ComponentProductSeller",
	ComponentProductDeliverToParty:                           "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverToParty",
	ComponentProductDeliverToPlant:                           "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverToPlant",
	ComponentProductDeliverFromParty:                         "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverFromParty",
	ComponentProductDeliverFromPlant:                         "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverFromPlant",
	ComponentProductDeliverToPartyInOperation:                "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverToPartyInOperation",
	ComponentProductDeliverToPlantInOperation:                "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverToPlantInOperation",
	ComponentProductDeliverFromPartyInOperation:              "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverFromPartyInOperation",
	ComponentProductDeliverFromPlantInOperation:              "data_platform_planned_order_item_operation_component_data.ComponentProductDeliverFromPlantInOperation",
	ComponentProductRequirementDateInOperation:               "data_platform_planned_order_item_operation_component_data.ComponentProductRequirementDateInOperation",
	ComponentProductRequirementTimeInOperation:               "data_platform_planned_order_item_operation_component_data.ComponentProductRequirementTimeInOperation",
	ComponentProductPlannedQuantityInBaseUnitInOperation:     "data_platform_planned_order_item_operation_component_data.ComponentProductPlannedQuantityInBaseUnitInOperation",
	ComponentProductPlannedQuantityInDeliveryUnitInOperation: "data_platform_planned_order_item_operation_component_data.ComponentProductPlannedQuantityInDeliveryUnitInOperation",
	ComponentProductPlannedScrapInPercentInOperation:         "data_platform_planned_order_item_operation_component_data.ComponentProductPlannedScrapInPercentInOperation",
	ComponentProductBaseUnit:                                 "data_platform_planned_order_item_operation_component_data.ComponentProductBaseUnit",
	ComponentProductDeliveryUnit:                             "data_platform_planned_order_item_operation_component_data.ComponentProductDeliveryUnit",
	ComponentProductIsMarkedForBackflush:                     "data_platform_planned_order_item_operation_component_data.ComponentProductIsMarkedForBackflush",
	MRPArea:                                                  "data_platform_planned_order_item_operation_component_data.MRPArea",
	MRPController:                                            "data_platform_planned_order_item_operation_component_data.MRPController",
	ProductionVersion:                                        "data_platform_planned_order_item_operation_component_data.ProductionVersion",
	ProductionVersionItem:                                    "data_platform_planned_order_item_operation_component_data.ProductionVersionItem",
	ComponentProductReservation:                              "data_platform_planned_order_item_operation_component_data.ComponentProductReservation",
	ComponentProductReservationItem:                          "data_platform_planned_order_item_operation_component_data.ComponentProductReservationItem",
	PlannedOrderIsReleased:                                   "data_platform_planned_order_item_operation_component_data.PlannedOrderIsReleased",
	CreationDate:                                             "data_platform_planned_order_item_operation_component_data.CreationDate",
	CreationTime:                                             "data_platform_planned_order_item_operation_component_data.CreationTime",
	LastChangeDate:                                           "data_platform_planned_order_item_operation_component_data.LastChangeDate",
	LastChangeTime:                                           "data_platform_planned_order_item_operation_component_data.LastChangeTime",
	IsMarkedForDeletion:                                      "data_platform_planned_order_item_operation_component_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformPlannedOrderItemOperationComponentDatumWhere = struct {
	PlannedOrder                                             whereHelperint
	PlannedOrderItem                                         whereHelperint
	Operations                                               whereHelperint
	OperationsItem                                           whereHelperint
	OperationID                                              whereHelperint
	BillOfMaterial                                           whereHelperint
	BillOfMaterialItem                                       whereHelperint
	SupplyChainRelationshipID                                whereHelperint
	SupplyChainRelationshipDeliveryID                        whereHelperint
	SupplyChainRelationshipDeliveryPlantID                   whereHelperint
	ProductionPlantBusinessPartner                           whereHelperint
	ProductionPlant                                          whereHelperstring
	ComponentProduct                                         whereHelperstring
	ComponentProductBuyer                                    whereHelperint
	ComponentProductSeller                                   whereHelperint
	ComponentProductDeliverToParty                           whereHelperint
	ComponentProductDeliverToPlant                           whereHelperstring
	ComponentProductDeliverFromParty                         whereHelperint
	ComponentProductDeliverFromPlant                         whereHelperstring
	ComponentProductDeliverToPartyInOperation                whereHelperint
	ComponentProductDeliverToPlantInOperation                whereHelperstring
	ComponentProductDeliverFromPartyInOperation              whereHelperint
	ComponentProductDeliverFromPlantInOperation              whereHelperstring
	ComponentProductRequirementDateInOperation               whereHelperstring
	ComponentProductRequirementTimeInOperation               whereHelperstring
	ComponentProductPlannedQuantityInBaseUnitInOperation     whereHelperfloat32
	ComponentProductPlannedQuantityInDeliveryUnitInOperation whereHelperfloat32
	ComponentProductPlannedScrapInPercentInOperation         whereHelpernull_Float32
	ComponentProductBaseUnit                                 whereHelperstring
	ComponentProductDeliveryUnit                             whereHelperstring
	ComponentProductIsMarkedForBackflush                     whereHelpernull_Bool
	MRPArea                                                  whereHelpernull_String
	MRPController                                            whereHelpernull_String
	ProductionVersion                                        whereHelpernull_Int
	ProductionVersionItem                                    whereHelpernull_Int
	ComponentProductReservation                              whereHelpernull_Int
	ComponentProductReservationItem                          whereHelpernull_Int
	PlannedOrderIsReleased                                   whereHelpernull_Bool
	CreationDate                                             whereHelperstring
	CreationTime                                             whereHelperstring
	LastChangeDate                                           whereHelperstring
	LastChangeTime                                           whereHelperstring
	IsMarkedForDeletion                                      whereHelpernull_Bool
}{
	PlannedOrder:                                             whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`PlannedOrder`"},
	PlannedOrderItem:                                         whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`PlannedOrderItem`"},
	Operations:                                               whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`Operations`"},
	OperationsItem:                                           whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`OperationsItem`"},
	OperationID:                                              whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`OperationID`"},
	BillOfMaterial:                                           whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`BillOfMaterial`"},
	BillOfMaterialItem:                                       whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`BillOfMaterialItem`"},
	SupplyChainRelationshipID:                                whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:                        whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID:                   whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	ProductionPlantBusinessPartner:                           whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ProductionPlantBusinessPartner`"},
	ProductionPlant:                                          whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ProductionPlant`"},
	ComponentProduct:                                         whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProduct`"},
	ComponentProductBuyer:                                    whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductBuyer`"},
	ComponentProductSeller:                                   whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductSeller`"},
	ComponentProductDeliverToParty:                           whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverToParty`"},
	ComponentProductDeliverToPlant:                           whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverToPlant`"},
	ComponentProductDeliverFromParty:                         whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverFromParty`"},
	ComponentProductDeliverFromPlant:                         whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverFromPlant`"},
	ComponentProductDeliverToPartyInOperation:                whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverToPartyInOperation`"},
	ComponentProductDeliverToPlantInOperation:                whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverToPlantInOperation`"},
	ComponentProductDeliverFromPartyInOperation:              whereHelperint{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverFromPartyInOperation`"},
	ComponentProductDeliverFromPlantInOperation:              whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliverFromPlantInOperation`"},
	ComponentProductRequirementDateInOperation:               whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductRequirementDateInOperation`"},
	ComponentProductRequirementTimeInOperation:               whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductRequirementTimeInOperation`"},
	ComponentProductPlannedQuantityInBaseUnitInOperation:     whereHelperfloat32{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductPlannedQuantityInBaseUnitInOperation`"},
	ComponentProductPlannedQuantityInDeliveryUnitInOperation: whereHelperfloat32{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductPlannedQuantityInDeliveryUnitInOperation`"},
	ComponentProductPlannedScrapInPercentInOperation:         whereHelpernull_Float32{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductPlannedScrapInPercentInOperation`"},
	ComponentProductBaseUnit:                                 whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductBaseUnit`"},
	ComponentProductDeliveryUnit:                             whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductDeliveryUnit`"},
	ComponentProductIsMarkedForBackflush:                     whereHelpernull_Bool{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductIsMarkedForBackflush`"},
	MRPArea:                                                  whereHelpernull_String{field: "`data_platform_planned_order_item_operation_component_data`.`MRPArea`"},
	MRPController:                                            whereHelpernull_String{field: "`data_platform_planned_order_item_operation_component_data`.`MRPController`"},
	ProductionVersion:                                        whereHelpernull_Int{field: "`data_platform_planned_order_item_operation_component_data`.`ProductionVersion`"},
	ProductionVersionItem:                                    whereHelpernull_Int{field: "`data_platform_planned_order_item_operation_component_data`.`ProductionVersionItem`"},
	ComponentProductReservation:                              whereHelpernull_Int{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductReservation`"},
	ComponentProductReservationItem:                          whereHelpernull_Int{field: "`data_platform_planned_order_item_operation_component_data`.`ComponentProductReservationItem`"},
	PlannedOrderIsReleased:                                   whereHelpernull_Bool{field: "`data_platform_planned_order_item_operation_component_data`.`PlannedOrderIsReleased`"},
	CreationDate:                                             whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`CreationDate`"},
	CreationTime:                                             whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`CreationTime`"},
	LastChangeDate:                                           whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`LastChangeDate`"},
	LastChangeTime:                                           whereHelperstring{field: "`data_platform_planned_order_item_operation_component_data`.`LastChangeTime`"},
	IsMarkedForDeletion:                                      whereHelpernull_Bool{field: "`data_platform_planned_order_item_operation_component_data`.`IsMarkedForDeletion`"},
}

// DataPlatformPlannedOrderItemOperationComponentDatumRels is where relationship names are stored.
var DataPlatformPlannedOrderItemOperationComponentDatumRels = struct {
	BillOfMaterialDataPlatformPlannedOrderItemComponentDatum  string
	ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum string
	ComponentProductBuyerDataPlatformSCRGeneralDatum          string
	OperationIDDataPlatformPlannedOrderItemOperationDatum     string
}{
	BillOfMaterialDataPlatformPlannedOrderItemComponentDatum:  "BillOfMaterialDataPlatformPlannedOrderItemComponentDatum",
	ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum: "ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum",
	ComponentProductBuyerDataPlatformSCRGeneralDatum:          "ComponentProductBuyerDataPlatformSCRGeneralDatum",
	OperationIDDataPlatformPlannedOrderItemOperationDatum:     "OperationIDDataPlatformPlannedOrderItemOperationDatum",
}

// dataPlatformPlannedOrderItemOperationComponentDatumR is where relationships are stored.
type dataPlatformPlannedOrderItemOperationComponentDatumR struct {
	BillOfMaterialDataPlatformPlannedOrderItemComponentDatum  *DataPlatformPlannedOrderItemComponentDatum `boil:"BillOfMaterialDataPlatformPlannedOrderItemComponentDatum" json:"BillOfMaterialDataPlatformPlannedOrderItemComponentDatum" toml:"BillOfMaterialDataPlatformPlannedOrderItemComponentDatum" yaml:"BillOfMaterialDataPlatformPlannedOrderItemComponentDatum"`
	ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum *DataPlatformSCRDeliveryRelationDatum       `boil:"ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum" json:"ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum" toml:"ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum" yaml:"ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum"`
	ComponentProductBuyerDataPlatformSCRGeneralDatum          *DataPlatformSCRGeneralDatum                `boil:"ComponentProductBuyerDataPlatformSCRGeneralDatum" json:"ComponentProductBuyerDataPlatformSCRGeneralDatum" toml:"ComponentProductBuyerDataPlatformSCRGeneralDatum" yaml:"ComponentProductBuyerDataPlatformSCRGeneralDatum"`
	OperationIDDataPlatformPlannedOrderItemOperationDatum     *DataPlatformPlannedOrderItemOperationDatum `boil:"OperationIDDataPlatformPlannedOrderItemOperationDatum" json:"OperationIDDataPlatformPlannedOrderItemOperationDatum" toml:"OperationIDDataPlatformPlannedOrderItemOperationDatum" yaml:"OperationIDDataPlatformPlannedOrderItemOperationDatum"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformPlannedOrderItemOperationComponentDatumR) NewStruct() *dataPlatformPlannedOrderItemOperationComponentDatumR {
	return &dataPlatformPlannedOrderItemOperationComponentDatumR{}
}

func (r *dataPlatformPlannedOrderItemOperationComponentDatumR) GetBillOfMaterialDataPlatformPlannedOrderItemComponentDatum() *DataPlatformPlannedOrderItemComponentDatum {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformPlannedOrderItemComponentDatum
}

func (r *dataPlatformPlannedOrderItemOperationComponentDatumR) GetComponentProductBuyerDataPlatformSCRDeliveryRelationDatum() *DataPlatformSCRDeliveryRelationDatum {
	if r == nil {
		return nil
	}
	return r.ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum
}

func (r *dataPlatformPlannedOrderItemOperationComponentDatumR) GetComponentProductBuyerDataPlatformSCRGeneralDatum() *DataPlatformSCRGeneralDatum {
	if r == nil {
		return nil
	}
	return r.ComponentProductBuyerDataPlatformSCRGeneralDatum
}

func (r *dataPlatformPlannedOrderItemOperationComponentDatumR) GetOperationIDDataPlatformPlannedOrderItemOperationDatum() *DataPlatformPlannedOrderItemOperationDatum {
	if r == nil {
		return nil
	}
	return r.OperationIDDataPlatformPlannedOrderItemOperationDatum
}

// dataPlatformPlannedOrderItemOperationComponentDatumL is where Load methods for each relationship are stored.
type dataPlatformPlannedOrderItemOperationComponentDatumL struct{}

var (
	dataPlatformPlannedOrderItemOperationComponentDatumAllColumns            = []string{"PlannedOrder", "PlannedOrderItem", "Operations", "OperationsItem", "OperationID", "BillOfMaterial", "BillOfMaterialItem", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "ProductionPlantBusinessPartner", "ProductionPlant", "ComponentProduct", "ComponentProductBuyer", "ComponentProductSeller", "ComponentProductDeliverToParty", "ComponentProductDeliverToPlant", "ComponentProductDeliverFromParty", "ComponentProductDeliverFromPlant", "ComponentProductDeliverToPartyInOperation", "ComponentProductDeliverToPlantInOperation", "ComponentProductDeliverFromPartyInOperation", "ComponentProductDeliverFromPlantInOperation", "ComponentProductRequirementDateInOperation", "ComponentProductRequirementTimeInOperation", "ComponentProductPlannedQuantityInBaseUnitInOperation", "ComponentProductPlannedQuantityInDeliveryUnitInOperation", "ComponentProductPlannedScrapInPercentInOperation", "ComponentProductBaseUnit", "ComponentProductDeliveryUnit", "ComponentProductIsMarkedForBackflush", "MRPArea", "MRPController", "ProductionVersion", "ProductionVersionItem", "ComponentProductReservation", "ComponentProductReservationItem", "PlannedOrderIsReleased", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsMarkedForDeletion"}
	dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithoutDefault = []string{"PlannedOrder", "PlannedOrderItem", "Operations", "OperationsItem", "OperationID", "BillOfMaterial", "BillOfMaterialItem", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "ProductionPlantBusinessPartner", "ProductionPlant", "ComponentProduct", "ComponentProductBuyer", "ComponentProductSeller", "ComponentProductDeliverToParty", "ComponentProductDeliverToPlant", "ComponentProductDeliverFromParty", "ComponentProductDeliverFromPlant", "ComponentProductDeliverToPartyInOperation", "ComponentProductDeliverToPlantInOperation", "ComponentProductDeliverFromPartyInOperation", "ComponentProductDeliverFromPlantInOperation", "ComponentProductRequirementDateInOperation", "ComponentProductRequirementTimeInOperation", "ComponentProductPlannedQuantityInBaseUnitInOperation", "ComponentProductPlannedQuantityInDeliveryUnitInOperation", "ComponentProductPlannedScrapInPercentInOperation", "ComponentProductBaseUnit", "ComponentProductDeliveryUnit", "ComponentProductIsMarkedForBackflush", "MRPArea", "MRPController", "ProductionVersion", "ProductionVersionItem", "ComponentProductReservation", "ComponentProductReservationItem", "PlannedOrderIsReleased", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsMarkedForDeletion"}
	dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithDefault    = []string{}
	dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns     = []string{"PlannedOrder", "PlannedOrderItem", "Operations", "OperationsItem", "OperationID", "BillOfMaterial", "BillOfMaterialItem"}
	dataPlatformPlannedOrderItemOperationComponentDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformPlannedOrderItemOperationComponentDatumSlice is an alias for a slice of pointers to DataPlatformPlannedOrderItemOperationComponentDatum.
	// This should almost always be used instead of []DataPlatformPlannedOrderItemOperationComponentDatum.
	DataPlatformPlannedOrderItemOperationComponentDatumSlice []*DataPlatformPlannedOrderItemOperationComponentDatum

	dataPlatformPlannedOrderItemOperationComponentDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformPlannedOrderItemOperationComponentDatumType                 = reflect.TypeOf(&DataPlatformPlannedOrderItemOperationComponentDatum{})
	dataPlatformPlannedOrderItemOperationComponentDatumMapping              = queries.MakeStructMapping(dataPlatformPlannedOrderItemOperationComponentDatumType)
	dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns)
	dataPlatformPlannedOrderItemOperationComponentDatumInsertCacheMut       sync.RWMutex
	dataPlatformPlannedOrderItemOperationComponentDatumInsertCache          = make(map[string]insertCache)
	dataPlatformPlannedOrderItemOperationComponentDatumUpdateCacheMut       sync.RWMutex
	dataPlatformPlannedOrderItemOperationComponentDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformPlannedOrderItemOperationComponentDatumUpsertCacheMut       sync.RWMutex
	dataPlatformPlannedOrderItemOperationComponentDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformPlannedOrderItemOperationComponentDatum record from the query.
func (q dataPlatformPlannedOrderItemOperationComponentDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformPlannedOrderItemOperationComponentDatum, error) {
	o := &DataPlatformPlannedOrderItemOperationComponentDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_planned_order_item_operation_component_data")
	}

	return o, nil
}

// All returns all DataPlatformPlannedOrderItemOperationComponentDatum records from the query.
func (q dataPlatformPlannedOrderItemOperationComponentDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformPlannedOrderItemOperationComponentDatumSlice, error) {
	var o []*DataPlatformPlannedOrderItemOperationComponentDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformPlannedOrderItemOperationComponentDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformPlannedOrderItemOperationComponentDatum records in the query.
func (q dataPlatformPlannedOrderItemOperationComponentDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_planned_order_item_operation_component_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformPlannedOrderItemOperationComponentDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_planned_order_item_operation_component_data exists")
	}

	return count > 0, nil
}

// BillOfMaterialDataPlatformPlannedOrderItemComponentDatum pointed to by the foreign key.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) BillOfMaterialDataPlatformPlannedOrderItemComponentDatum(mods ...qm.QueryMod) dataPlatformPlannedOrderItemComponentDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillOfMaterial` = ?", o.BillOfMaterial),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlannedOrderItemComponentData(queryMods...)
}

// ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum pointed to by the foreign key.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.ComponentProductBuyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryRelationData(queryMods...)
}

// ComponentProductBuyerDataPlatformSCRGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) ComponentProductBuyerDataPlatformSCRGeneralDatum(mods ...qm.QueryMod) dataPlatformSCRGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.ComponentProductBuyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRGeneralData(queryMods...)
}

// OperationIDDataPlatformPlannedOrderItemOperationDatum pointed to by the foreign key.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) OperationIDDataPlatformPlannedOrderItemOperationDatum(mods ...qm.QueryMod) dataPlatformPlannedOrderItemOperationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OperationID` = ?", o.OperationID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlannedOrderItemOperationData(queryMods...)
}

// LoadBillOfMaterialDataPlatformPlannedOrderItemComponentDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPlannedOrderItemOperationComponentDatumL) LoadBillOfMaterialDataPlatformPlannedOrderItemComponentDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPlannedOrderItemOperationComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPlannedOrderItemOperationComponentDatum
	var object *DataPlatformPlannedOrderItemOperationComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*DataPlatformPlannedOrderItemOperationComponentDatum)
		if !ok {
			object = new(DataPlatformPlannedOrderItemOperationComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*[]*DataPlatformPlannedOrderItemOperationComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
		}
		args = append(args, object.BillOfMaterial)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.BillOfMaterial {
					continue Outer
				}
			}

			args = append(args, obj.BillOfMaterial)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_planned_order_item_component_data`),
		qm.WhereIn(`data_platform_planned_order_item_component_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlannedOrderItemComponentDatum")
	}

	var resultSlice []*DataPlatformPlannedOrderItemComponentDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlannedOrderItemComponentDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_planned_order_item_component_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_planned_order_item_component_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillOfMaterialDataPlatformPlannedOrderItemComponentDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BillOfMaterial == foreign.BillOfMaterial {
				local.R.BillOfMaterialDataPlatformPlannedOrderItemComponentDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadComponentProductBuyerDataPlatformSCRDeliveryRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPlannedOrderItemOperationComponentDatumL) LoadComponentProductBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPlannedOrderItemOperationComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPlannedOrderItemOperationComponentDatum
	var object *DataPlatformPlannedOrderItemOperationComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*DataPlatformPlannedOrderItemOperationComponentDatum)
		if !ok {
			object = new(DataPlatformPlannedOrderItemOperationComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*[]*DataPlatformPlannedOrderItemOperationComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
		}
		args = append(args, object.ComponentProductBuyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ComponentProductBuyer {
					continue Outer
				}
			}

			args = append(args, obj.ComponentProductBuyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ComponentProductBuyer == foreign.Buyer {
				local.R.ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadComponentProductBuyerDataPlatformSCRGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPlannedOrderItemOperationComponentDatumL) LoadComponentProductBuyerDataPlatformSCRGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPlannedOrderItemOperationComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPlannedOrderItemOperationComponentDatum
	var object *DataPlatformPlannedOrderItemOperationComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*DataPlatformPlannedOrderItemOperationComponentDatum)
		if !ok {
			object = new(DataPlatformPlannedOrderItemOperationComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*[]*DataPlatformPlannedOrderItemOperationComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
		}
		args = append(args, object.ComponentProductBuyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.ComponentProductBuyer {
					continue Outer
				}
			}

			args = append(args, obj.ComponentProductBuyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_general_data`),
		qm.WhereIn(`data_platform_scr_general_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRGeneralDatum")
	}

	var resultSlice []*DataPlatformSCRGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ComponentProductBuyerDataPlatformSCRGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ComponentProductBuyer == foreign.Buyer {
				local.R.ComponentProductBuyerDataPlatformSCRGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadOperationIDDataPlatformPlannedOrderItemOperationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPlannedOrderItemOperationComponentDatumL) LoadOperationIDDataPlatformPlannedOrderItemOperationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPlannedOrderItemOperationComponentDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPlannedOrderItemOperationComponentDatum
	var object *DataPlatformPlannedOrderItemOperationComponentDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*DataPlatformPlannedOrderItemOperationComponentDatum)
		if !ok {
			object = new(DataPlatformPlannedOrderItemOperationComponentDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPlannedOrderItemOperationComponentDatum.(*[]*DataPlatformPlannedOrderItemOperationComponentDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPlannedOrderItemOperationComponentDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
		}
		args = append(args, object.OperationID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{}
			}

			for _, a := range args {
				if a == obj.OperationID {
					continue Outer
				}
			}

			args = append(args, obj.OperationID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_planned_order_item_operation_data`),
		qm.WhereIn(`data_platform_planned_order_item_operation_data.OperationID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlannedOrderItemOperationDatum")
	}

	var resultSlice []*DataPlatformPlannedOrderItemOperationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlannedOrderItemOperationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_planned_order_item_operation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_planned_order_item_operation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OperationIDDataPlatformPlannedOrderItemOperationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OperationID == foreign.OperationID {
				local.R.OperationIDDataPlatformPlannedOrderItemOperationDatum = foreign
				break
			}
		}
	}

	return nil
}

// SetBillOfMaterialDataPlatformPlannedOrderItemComponentDatum of the dataPlatformPlannedOrderItemOperationComponentDatum to the related item.
// Sets o.R.BillOfMaterialDataPlatformPlannedOrderItemComponentDatum to related.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) SetBillOfMaterialDataPlatformPlannedOrderItemComponentDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlannedOrderItemComponentDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_planned_order_item_operation_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillOfMaterial, o.PlannedOrder, o.PlannedOrderItem, o.Operations, o.OperationsItem, o.OperationID, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BillOfMaterial = related.BillOfMaterial
	if o.R == nil {
		o.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{
			BillOfMaterialDataPlatformPlannedOrderItemComponentDatum: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformPlannedOrderItemComponentDatum = related
	}

	return nil
}

// SetComponentProductBuyerDataPlatformSCRDeliveryRelationDatum of the dataPlatformPlannedOrderItemOperationComponentDatum to the related item.
// Sets o.R.ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum to related.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) SetComponentProductBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_planned_order_item_operation_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ComponentProductBuyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.PlannedOrder, o.PlannedOrderItem, o.Operations, o.OperationsItem, o.OperationID, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ComponentProductBuyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{
			ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum: related,
		}
	} else {
		o.R.ComponentProductBuyerDataPlatformSCRDeliveryRelationDatum = related
	}

	return nil
}

// SetComponentProductBuyerDataPlatformSCRGeneralDatum of the dataPlatformPlannedOrderItemOperationComponentDatum to the related item.
// Sets o.R.ComponentProductBuyerDataPlatformSCRGeneralDatum to related.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) SetComponentProductBuyerDataPlatformSCRGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_planned_order_item_operation_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ComponentProductBuyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.PlannedOrder, o.PlannedOrderItem, o.Operations, o.OperationsItem, o.OperationID, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ComponentProductBuyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{
			ComponentProductBuyerDataPlatformSCRGeneralDatum: related,
		}
	} else {
		o.R.ComponentProductBuyerDataPlatformSCRGeneralDatum = related
	}

	return nil
}

// SetOperationIDDataPlatformPlannedOrderItemOperationDatum of the dataPlatformPlannedOrderItemOperationComponentDatum to the related item.
// Sets o.R.OperationIDDataPlatformPlannedOrderItemOperationDatum to related.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) SetOperationIDDataPlatformPlannedOrderItemOperationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlannedOrderItemOperationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_planned_order_item_operation_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OperationID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OperationID, o.PlannedOrder, o.PlannedOrderItem, o.Operations, o.OperationsItem, o.OperationID, o.BillOfMaterial, o.BillOfMaterialItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OperationID = related.OperationID
	if o.R == nil {
		o.R = &dataPlatformPlannedOrderItemOperationComponentDatumR{
			OperationIDDataPlatformPlannedOrderItemOperationDatum: related,
		}
	} else {
		o.R.OperationIDDataPlatformPlannedOrderItemOperationDatum = related
	}

	return nil
}

// DataPlatformPlannedOrderItemOperationComponentData retrieves all the records using an executor.
func DataPlatformPlannedOrderItemOperationComponentData(mods ...qm.QueryMod) dataPlatformPlannedOrderItemOperationComponentDatumQuery {
	mods = append(mods, qm.From("`data_platform_planned_order_item_operation_component_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_planned_order_item_operation_component_data`.*"})
	}

	return dataPlatformPlannedOrderItemOperationComponentDatumQuery{q}
}

// FindDataPlatformPlannedOrderItemOperationComponentDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformPlannedOrderItemOperationComponentDatum(ctx context.Context, exec boil.ContextExecutor, plannedOrder int, plannedOrderItem int, operations int, operationsItem int, operationID int, billOfMaterial int, billOfMaterialItem int, selectCols ...string) (*DataPlatformPlannedOrderItemOperationComponentDatum, error) {
	dataPlatformPlannedOrderItemOperationComponentDatumObj := &DataPlatformPlannedOrderItemOperationComponentDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_planned_order_item_operation_component_data` where `PlannedOrder`=? AND `PlannedOrderItem`=? AND `Operations`=? AND `OperationsItem`=? AND `OperationID`=? AND `BillOfMaterial`=? AND `BillOfMaterialItem`=?", sel,
	)

	q := queries.Raw(query, plannedOrder, plannedOrderItem, operations, operationsItem, operationID, billOfMaterial, billOfMaterialItem)

	err := q.Bind(ctx, exec, dataPlatformPlannedOrderItemOperationComponentDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_planned_order_item_operation_component_data")
	}

	return dataPlatformPlannedOrderItemOperationComponentDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_planned_order_item_operation_component_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformPlannedOrderItemOperationComponentDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformPlannedOrderItemOperationComponentDatumInsertCache[key]
	dataPlatformPlannedOrderItemOperationComponentDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformPlannedOrderItemOperationComponentDatumAllColumns,
			dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithDefault,
			dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_planned_order_item_operation_component_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_planned_order_item_operation_component_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_planned_order_item_operation_component_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_planned_order_item_operation_component_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PlannedOrder,
		o.PlannedOrderItem,
		o.Operations,
		o.OperationsItem,
		o.OperationID,
		o.BillOfMaterial,
		o.BillOfMaterialItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_planned_order_item_operation_component_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformPlannedOrderItemOperationComponentDatumInsertCacheMut.Lock()
		dataPlatformPlannedOrderItemOperationComponentDatumInsertCache[key] = cache
		dataPlatformPlannedOrderItemOperationComponentDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformPlannedOrderItemOperationComponentDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformPlannedOrderItemOperationComponentDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformPlannedOrderItemOperationComponentDatumUpdateCache[key]
	dataPlatformPlannedOrderItemOperationComponentDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformPlannedOrderItemOperationComponentDatumAllColumns,
			dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_planned_order_item_operation_component_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_planned_order_item_operation_component_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, append(wl, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_planned_order_item_operation_component_data row")
	}

	if !cached {
		dataPlatformPlannedOrderItemOperationComponentDatumUpdateCacheMut.Lock()
		dataPlatformPlannedOrderItemOperationComponentDatumUpdateCache[key] = cache
		dataPlatformPlannedOrderItemOperationComponentDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformPlannedOrderItemOperationComponentDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_planned_order_item_operation_component_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformPlannedOrderItemOperationComponentDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_planned_order_item_operation_component_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformPlannedOrderItemOperationComponentDatum slice")
	}

	return nil
}

var mySQLDataPlatformPlannedOrderItemOperationComponentDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_planned_order_item_operation_component_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformPlannedOrderItemOperationComponentDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformPlannedOrderItemOperationComponentDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformPlannedOrderItemOperationComponentDatumUpsertCache[key]
	dataPlatformPlannedOrderItemOperationComponentDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformPlannedOrderItemOperationComponentDatumAllColumns,
			dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithDefault,
			dataPlatformPlannedOrderItemOperationComponentDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformPlannedOrderItemOperationComponentDatumAllColumns,
			dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_planned_order_item_operation_component_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_planned_order_item_operation_component_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_planned_order_item_operation_component_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_planned_order_item_operation_component_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformPlannedOrderItemOperationComponentDatumType, dataPlatformPlannedOrderItemOperationComponentDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_planned_order_item_operation_component_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_planned_order_item_operation_component_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformPlannedOrderItemOperationComponentDatumUpsertCacheMut.Lock()
		dataPlatformPlannedOrderItemOperationComponentDatumUpsertCache[key] = cache
		dataPlatformPlannedOrderItemOperationComponentDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformPlannedOrderItemOperationComponentDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformPlannedOrderItemOperationComponentDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_planned_order_item_operation_component_data` WHERE `PlannedOrder`=? AND `PlannedOrderItem`=? AND `Operations`=? AND `OperationsItem`=? AND `OperationID`=? AND `BillOfMaterial`=? AND `BillOfMaterialItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_planned_order_item_operation_component_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformPlannedOrderItemOperationComponentDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformPlannedOrderItemOperationComponentDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_planned_order_item_operation_component_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformPlannedOrderItemOperationComponentDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_planned_order_item_operation_component_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformPlannedOrderItemOperationComponentDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformPlannedOrderItemOperationComponentDatum(ctx, exec, o.PlannedOrder, o.PlannedOrderItem, o.Operations, o.OperationsItem, o.OperationID, o.BillOfMaterial, o.BillOfMaterialItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformPlannedOrderItemOperationComponentDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformPlannedOrderItemOperationComponentDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_planned_order_item_operation_component_data`.* FROM `data_platform_planned_order_item_operation_component_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPlannedOrderItemOperationComponentDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformPlannedOrderItemOperationComponentDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformPlannedOrderItemOperationComponentDatumExists checks if the DataPlatformPlannedOrderItemOperationComponentDatum row exists.
func DataPlatformPlannedOrderItemOperationComponentDatumExists(ctx context.Context, exec boil.ContextExecutor, plannedOrder int, plannedOrderItem int, operations int, operationsItem int, operationID int, billOfMaterial int, billOfMaterialItem int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_planned_order_item_operation_component_data` where `PlannedOrder`=? AND `PlannedOrderItem`=? AND `Operations`=? AND `OperationsItem`=? AND `OperationID`=? AND `BillOfMaterial`=? AND `BillOfMaterialItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, plannedOrder, plannedOrderItem, operations, operationsItem, operationID, billOfMaterial, billOfMaterialItem)
	}
	row := exec.QueryRowContext(ctx, sql, plannedOrder, plannedOrderItem, operations, operationsItem, operationID, billOfMaterial, billOfMaterialItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_planned_order_item_operation_component_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformPlannedOrderItemOperationComponentDatum row exists.
func (o *DataPlatformPlannedOrderItemOperationComponentDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformPlannedOrderItemOperationComponentDatumExists(ctx, exec, o.PlannedOrder, o.PlannedOrderItem, o.Operations, o.OperationsItem, o.OperationID, o.BillOfMaterial, o.BillOfMaterialItem)
}
