// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformDeliveryDocumentHeaderDatum is an object representing the database table.
type DataPlatformDeliveryDocumentHeaderDatum struct {
	DeliveryDocument                       int          `boil:"DeliveryDocument" json:"DeliveryDocument" toml:"DeliveryDocument" yaml:"DeliveryDocument"`
	DeliveryDocumentDate                   string       `boil:"DeliveryDocumentDate" json:"DeliveryDocumentDate" toml:"DeliveryDocumentDate" yaml:"DeliveryDocumentDate"`
	SupplyChainRelationshipID              int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipDeliveryID      int          `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID"`
	SupplyChainRelationshipDeliveryPlantID int          `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID"`
	SupplyChainRelationshipBillingID       null.Int     `boil:"SupplyChainRelationshipBillingID" json:"SupplyChainRelationshipBillingID,omitempty" toml:"SupplyChainRelationshipBillingID" yaml:"SupplyChainRelationshipBillingID,omitempty"`
	SupplyChainRelationshipPaymentID       null.Int     `boil:"SupplyChainRelationshipPaymentID" json:"SupplyChainRelationshipPaymentID,omitempty" toml:"SupplyChainRelationshipPaymentID" yaml:"SupplyChainRelationshipPaymentID,omitempty"`
	SupplyChainRelationshipFreightID       null.Int     `boil:"SupplyChainRelationshipFreightID" json:"SupplyChainRelationshipFreightID,omitempty" toml:"SupplyChainRelationshipFreightID" yaml:"SupplyChainRelationshipFreightID,omitempty"`
	Buyer                                  int          `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Seller                                 int          `boil:"Seller" json:"Seller" toml:"Seller" yaml:"Seller"`
	DeliverToParty                         int          `boil:"DeliverToParty" json:"DeliverToParty" toml:"DeliverToParty" yaml:"DeliverToParty"`
	DeliverFromParty                       int          `boil:"DeliverFromParty" json:"DeliverFromParty" toml:"DeliverFromParty" yaml:"DeliverFromParty"`
	DeliverToPlant                         string       `boil:"DeliverToPlant" json:"DeliverToPlant" toml:"DeliverToPlant" yaml:"DeliverToPlant"`
	DeliverFromPlant                       string       `boil:"DeliverFromPlant" json:"DeliverFromPlant" toml:"DeliverFromPlant" yaml:"DeliverFromPlant"`
	BillToParty                            null.Int     `boil:"BillToParty" json:"BillToParty,omitempty" toml:"BillToParty" yaml:"BillToParty,omitempty"`
	BillFromParty                          null.Int     `boil:"BillFromParty" json:"BillFromParty,omitempty" toml:"BillFromParty" yaml:"BillFromParty,omitempty"`
	BillToCountry                          null.String  `boil:"BillToCountry" json:"BillToCountry,omitempty" toml:"BillToCountry" yaml:"BillToCountry,omitempty"`
	BillFromCountry                        null.String  `boil:"BillFromCountry" json:"BillFromCountry,omitempty" toml:"BillFromCountry" yaml:"BillFromCountry,omitempty"`
	Payer                                  null.Int     `boil:"Payer" json:"Payer,omitempty" toml:"Payer" yaml:"Payer,omitempty"`
	Payee                                  null.Int     `boil:"Payee" json:"Payee,omitempty" toml:"Payee" yaml:"Payee,omitempty"`
	FreightPartner                         null.Int     `boil:"FreightPartner" json:"FreightPartner,omitempty" toml:"FreightPartner" yaml:"FreightPartner,omitempty"`
	IsExportImport                         null.Bool    `boil:"IsExportImport" json:"IsExportImport,omitempty" toml:"IsExportImport" yaml:"IsExportImport,omitempty"`
	DeliverToPlantTimeZone                 null.String  `boil:"DeliverToPlantTimeZone" json:"DeliverToPlantTimeZone,omitempty" toml:"DeliverToPlantTimeZone" yaml:"DeliverToPlantTimeZone,omitempty"`
	DeliverFromPlantTimeZone               null.String  `boil:"DeliverFromPlantTimeZone" json:"DeliverFromPlantTimeZone,omitempty" toml:"DeliverFromPlantTimeZone" yaml:"DeliverFromPlantTimeZone,omitempty"`
	ReferenceDocument                      null.Int     `boil:"ReferenceDocument" json:"ReferenceDocument,omitempty" toml:"ReferenceDocument" yaml:"ReferenceDocument,omitempty"`
	ReferenceDocumentItem                  null.Int     `boil:"ReferenceDocumentItem" json:"ReferenceDocumentItem,omitempty" toml:"ReferenceDocumentItem" yaml:"ReferenceDocumentItem,omitempty"`
	OrderID                                null.Int     `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	OrderItem                              null.Int     `boil:"OrderItem" json:"OrderItem,omitempty" toml:"OrderItem" yaml:"OrderItem,omitempty"`
	Contract                               null.Int     `boil:"Contract" json:"Contract,omitempty" toml:"Contract" yaml:"Contract,omitempty"`
	ContractItem                           null.Int     `boil:"ContractItem" json:"ContractItem,omitempty" toml:"ContractItem" yaml:"ContractItem,omitempty"`
	ProductionVersion                      null.Int     `boil:"ProductionVersion" json:"ProductionVersion,omitempty" toml:"ProductionVersion" yaml:"ProductionVersion,omitempty"`
	ProductionVersionItem                  null.Int     `boil:"ProductionVersionItem" json:"ProductionVersionItem,omitempty" toml:"ProductionVersionItem" yaml:"ProductionVersionItem,omitempty"`
	ProductionOrder                        null.Int     `boil:"ProductionOrder" json:"ProductionOrder,omitempty" toml:"ProductionOrder" yaml:"ProductionOrder,omitempty"`
	ProductionOrderItem                    null.Int     `boil:"ProductionOrderItem" json:"ProductionOrderItem,omitempty" toml:"ProductionOrderItem" yaml:"ProductionOrderItem,omitempty"`
	Operations                             null.Int     `boil:"Operations" json:"Operations,omitempty" toml:"Operations" yaml:"Operations,omitempty"`
	OperationsItem                         null.Int     `boil:"OperationsItem" json:"OperationsItem,omitempty" toml:"OperationsItem" yaml:"OperationsItem,omitempty"`
	OperationID                            null.Int     `boil:"OperationID" json:"OperationID,omitempty" toml:"OperationID" yaml:"OperationID,omitempty"`
	BillOfMaterial                         null.Int     `boil:"BillOfMaterial" json:"BillOfMaterial,omitempty" toml:"BillOfMaterial" yaml:"BillOfMaterial,omitempty"`
	BillOfMaterialItem                     null.Int     `boil:"BillOfMaterialItem" json:"BillOfMaterialItem,omitempty" toml:"BillOfMaterialItem" yaml:"BillOfMaterialItem,omitempty"`
	ContractType                           null.String  `boil:"ContractType" json:"ContractType,omitempty" toml:"ContractType" yaml:"ContractType,omitempty"`
	OrderValidityStartDate                 null.String  `boil:"OrderValidityStartDate" json:"OrderValidityStartDate,omitempty" toml:"OrderValidityStartDate" yaml:"OrderValidityStartDate,omitempty"`
	OrderValidityEndDate                   null.String  `boil:"OrderValidityEndDate" json:"OrderValidityEndDate,omitempty" toml:"OrderValidityEndDate" yaml:"OrderValidityEndDate,omitempty"`
	PlannedGoodsIssueDate                  string       `boil:"PlannedGoodsIssueDate" json:"PlannedGoodsIssueDate" toml:"PlannedGoodsIssueDate" yaml:"PlannedGoodsIssueDate"`
	PlannedGoodsIssueTime                  string       `boil:"PlannedGoodsIssueTime" json:"PlannedGoodsIssueTime" toml:"PlannedGoodsIssueTime" yaml:"PlannedGoodsIssueTime"`
	PlannedGoodsReceiptDate                string       `boil:"PlannedGoodsReceiptDate" json:"PlannedGoodsReceiptDate" toml:"PlannedGoodsReceiptDate" yaml:"PlannedGoodsReceiptDate"`
	PlannedGoodsReceiptTime                string       `boil:"PlannedGoodsReceiptTime" json:"PlannedGoodsReceiptTime" toml:"PlannedGoodsReceiptTime" yaml:"PlannedGoodsReceiptTime"`
	FreightOrder                           null.Int     `boil:"FreightOrder" json:"FreightOrder,omitempty" toml:"FreightOrder" yaml:"FreightOrder,omitempty"`
	InvoiceDocumentDate                    null.String  `boil:"InvoiceDocumentDate" json:"InvoiceDocumentDate,omitempty" toml:"InvoiceDocumentDate" yaml:"InvoiceDocumentDate,omitempty"`
	HeaderCompleteDeliveryIsDefined        null.Bool    `boil:"HeaderCompleteDeliveryIsDefined" json:"HeaderCompleteDeliveryIsDefined,omitempty" toml:"HeaderCompleteDeliveryIsDefined" yaml:"HeaderCompleteDeliveryIsDefined,omitempty"`
	HeaderDeliveryStatus                   null.String  `boil:"HeaderDeliveryStatus" json:"HeaderDeliveryStatus,omitempty" toml:"HeaderDeliveryStatus" yaml:"HeaderDeliveryStatus,omitempty"`
	GoodsIssueOrReceiptSlipNumber          null.String  `boil:"GoodsIssueOrReceiptSlipNumber" json:"GoodsIssueOrReceiptSlipNumber,omitempty" toml:"GoodsIssueOrReceiptSlipNumber" yaml:"GoodsIssueOrReceiptSlipNumber,omitempty"`
	HeaderBillingStatus                    null.String  `boil:"HeaderBillingStatus" json:"HeaderBillingStatus,omitempty" toml:"HeaderBillingStatus" yaml:"HeaderBillingStatus,omitempty"`
	HeaderBillingConfStatus                null.String  `boil:"HeaderBillingConfStatus" json:"HeaderBillingConfStatus,omitempty" toml:"HeaderBillingConfStatus" yaml:"HeaderBillingConfStatus,omitempty"`
	HeaderBillingBlockStatus               null.Bool    `boil:"HeaderBillingBlockStatus" json:"HeaderBillingBlockStatus,omitempty" toml:"HeaderBillingBlockStatus" yaml:"HeaderBillingBlockStatus,omitempty"`
	HeaderGrossWeight                      null.Float32 `boil:"HeaderGrossWeight" json:"HeaderGrossWeight,omitempty" toml:"HeaderGrossWeight" yaml:"HeaderGrossWeight,omitempty"`
	HeaderNetWeight                        null.Float32 `boil:"HeaderNetWeight" json:"HeaderNetWeight,omitempty" toml:"HeaderNetWeight" yaml:"HeaderNetWeight,omitempty"`
	HeaderWeightUnit                       null.String  `boil:"HeaderWeightUnit" json:"HeaderWeightUnit,omitempty" toml:"HeaderWeightUnit" yaml:"HeaderWeightUnit,omitempty"`
	Incoterms                              null.String  `boil:"Incoterms" json:"Incoterms,omitempty" toml:"Incoterms" yaml:"Incoterms,omitempty"`
	TransactionCurrency                    null.String  `boil:"TransactionCurrency" json:"TransactionCurrency,omitempty" toml:"TransactionCurrency" yaml:"TransactionCurrency,omitempty"`
	HeaderDeliveryBlockStatus              null.Bool    `boil:"HeaderDeliveryBlockStatus" json:"HeaderDeliveryBlockStatus,omitempty" toml:"HeaderDeliveryBlockStatus" yaml:"HeaderDeliveryBlockStatus,omitempty"`
	HeaderIssuingBlockStatus               null.Bool    `boil:"HeaderIssuingBlockStatus" json:"HeaderIssuingBlockStatus,omitempty" toml:"HeaderIssuingBlockStatus" yaml:"HeaderIssuingBlockStatus,omitempty"`
	HeaderReceivingBlockStatus             null.Bool    `boil:"HeaderReceivingBlockStatus" json:"HeaderReceivingBlockStatus,omitempty" toml:"HeaderReceivingBlockStatus" yaml:"HeaderReceivingBlockStatus,omitempty"`
	ExternalReferenceDocument              null.String  `boil:"ExternalReferenceDocument" json:"ExternalReferenceDocument,omitempty" toml:"ExternalReferenceDocument" yaml:"ExternalReferenceDocument,omitempty"`
	CertificateAuthorityChain              null.String  `boil:"CertificateAuthorityChain" json:"CertificateAuthorityChain,omitempty" toml:"CertificateAuthorityChain" yaml:"CertificateAuthorityChain,omitempty"`
	UsageControlChain                      null.String  `boil:"UsageControlChain" json:"UsageControlChain,omitempty" toml:"UsageControlChain" yaml:"UsageControlChain,omitempty"`
	CreationDate                           string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                           string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                         string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                         string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsCancelled                            null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                    null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformDeliveryDocumentHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformDeliveryDocumentHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformDeliveryDocumentHeaderDatumColumns = struct {
	DeliveryDocument                       string
	DeliveryDocumentDate                   string
	SupplyChainRelationshipID              string
	SupplyChainRelationshipDeliveryID      string
	SupplyChainRelationshipDeliveryPlantID string
	SupplyChainRelationshipBillingID       string
	SupplyChainRelationshipPaymentID       string
	SupplyChainRelationshipFreightID       string
	Buyer                                  string
	Seller                                 string
	DeliverToParty                         string
	DeliverFromParty                       string
	DeliverToPlant                         string
	DeliverFromPlant                       string
	BillToParty                            string
	BillFromParty                          string
	BillToCountry                          string
	BillFromCountry                        string
	Payer                                  string
	Payee                                  string
	FreightPartner                         string
	IsExportImport                         string
	DeliverToPlantTimeZone                 string
	DeliverFromPlantTimeZone               string
	ReferenceDocument                      string
	ReferenceDocumentItem                  string
	OrderID                                string
	OrderItem                              string
	Contract                               string
	ContractItem                           string
	ProductionVersion                      string
	ProductionVersionItem                  string
	ProductionOrder                        string
	ProductionOrderItem                    string
	Operations                             string
	OperationsItem                         string
	OperationID                            string
	BillOfMaterial                         string
	BillOfMaterialItem                     string
	ContractType                           string
	OrderValidityStartDate                 string
	OrderValidityEndDate                   string
	PlannedGoodsIssueDate                  string
	PlannedGoodsIssueTime                  string
	PlannedGoodsReceiptDate                string
	PlannedGoodsReceiptTime                string
	FreightOrder                           string
	InvoiceDocumentDate                    string
	HeaderCompleteDeliveryIsDefined        string
	HeaderDeliveryStatus                   string
	GoodsIssueOrReceiptSlipNumber          string
	HeaderBillingStatus                    string
	HeaderBillingConfStatus                string
	HeaderBillingBlockStatus               string
	HeaderGrossWeight                      string
	HeaderNetWeight                        string
	HeaderWeightUnit                       string
	Incoterms                              string
	TransactionCurrency                    string
	HeaderDeliveryBlockStatus              string
	HeaderIssuingBlockStatus               string
	HeaderReceivingBlockStatus             string
	ExternalReferenceDocument              string
	CertificateAuthorityChain              string
	UsageControlChain                      string
	CreationDate                           string
	CreationTime                           string
	LastChangeDate                         string
	LastChangeTime                         string
	IsCancelled                            string
	IsMarkedForDeletion                    string
}{
	DeliveryDocument:                       "DeliveryDocument",
	DeliveryDocumentDate:                   "DeliveryDocumentDate",
	SupplyChainRelationshipID:              "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:      "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID: "SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipBillingID:       "SupplyChainRelationshipBillingID",
	SupplyChainRelationshipPaymentID:       "SupplyChainRelationshipPaymentID",
	SupplyChainRelationshipFreightID:       "SupplyChainRelationshipFreightID",
	Buyer:                                  "Buyer",
	Seller:                                 "Seller",
	DeliverToParty:                         "DeliverToParty",
	DeliverFromParty:                       "DeliverFromParty",
	DeliverToPlant:                         "DeliverToPlant",
	DeliverFromPlant:                       "DeliverFromPlant",
	BillToParty:                            "BillToParty",
	BillFromParty:                          "BillFromParty",
	BillToCountry:                          "BillToCountry",
	BillFromCountry:                        "BillFromCountry",
	Payer:                                  "Payer",
	Payee:                                  "Payee",
	FreightPartner:                         "FreightPartner",
	IsExportImport:                         "IsExportImport",
	DeliverToPlantTimeZone:                 "DeliverToPlantTimeZone",
	DeliverFromPlantTimeZone:               "DeliverFromPlantTimeZone",
	ReferenceDocument:                      "ReferenceDocument",
	ReferenceDocumentItem:                  "ReferenceDocumentItem",
	OrderID:                                "OrderID",
	OrderItem:                              "OrderItem",
	Contract:                               "Contract",
	ContractItem:                           "ContractItem",
	ProductionVersion:                      "ProductionVersion",
	ProductionVersionItem:                  "ProductionVersionItem",
	ProductionOrder:                        "ProductionOrder",
	ProductionOrderItem:                    "ProductionOrderItem",
	Operations:                             "Operations",
	OperationsItem:                         "OperationsItem",
	OperationID:                            "OperationID",
	BillOfMaterial:                         "BillOfMaterial",
	BillOfMaterialItem:                     "BillOfMaterialItem",
	ContractType:                           "ContractType",
	OrderValidityStartDate:                 "OrderValidityStartDate",
	OrderValidityEndDate:                   "OrderValidityEndDate",
	PlannedGoodsIssueDate:                  "PlannedGoodsIssueDate",
	PlannedGoodsIssueTime:                  "PlannedGoodsIssueTime",
	PlannedGoodsReceiptDate:                "PlannedGoodsReceiptDate",
	PlannedGoodsReceiptTime:                "PlannedGoodsReceiptTime",
	FreightOrder:                           "FreightOrder",
	InvoiceDocumentDate:                    "InvoiceDocumentDate",
	HeaderCompleteDeliveryIsDefined:        "HeaderCompleteDeliveryIsDefined",
	HeaderDeliveryStatus:                   "HeaderDeliveryStatus",
	GoodsIssueOrReceiptSlipNumber:          "GoodsIssueOrReceiptSlipNumber",
	HeaderBillingStatus:                    "HeaderBillingStatus",
	HeaderBillingConfStatus:                "HeaderBillingConfStatus",
	HeaderBillingBlockStatus:               "HeaderBillingBlockStatus",
	HeaderGrossWeight:                      "HeaderGrossWeight",
	HeaderNetWeight:                        "HeaderNetWeight",
	HeaderWeightUnit:                       "HeaderWeightUnit",
	Incoterms:                              "Incoterms",
	TransactionCurrency:                    "TransactionCurrency",
	HeaderDeliveryBlockStatus:              "HeaderDeliveryBlockStatus",
	HeaderIssuingBlockStatus:               "HeaderIssuingBlockStatus",
	HeaderReceivingBlockStatus:             "HeaderReceivingBlockStatus",
	ExternalReferenceDocument:              "ExternalReferenceDocument",
	CertificateAuthorityChain:              "CertificateAuthorityChain",
	UsageControlChain:                      "UsageControlChain",
	CreationDate:                           "CreationDate",
	CreationTime:                           "CreationTime",
	LastChangeDate:                         "LastChangeDate",
	LastChangeTime:                         "LastChangeTime",
	IsCancelled:                            "IsCancelled",
	IsMarkedForDeletion:                    "IsMarkedForDeletion",
}

var DataPlatformDeliveryDocumentHeaderDatumTableColumns = struct {
	DeliveryDocument                       string
	DeliveryDocumentDate                   string
	SupplyChainRelationshipID              string
	SupplyChainRelationshipDeliveryID      string
	SupplyChainRelationshipDeliveryPlantID string
	SupplyChainRelationshipBillingID       string
	SupplyChainRelationshipPaymentID       string
	SupplyChainRelationshipFreightID       string
	Buyer                                  string
	Seller                                 string
	DeliverToParty                         string
	DeliverFromParty                       string
	DeliverToPlant                         string
	DeliverFromPlant                       string
	BillToParty                            string
	BillFromParty                          string
	BillToCountry                          string
	BillFromCountry                        string
	Payer                                  string
	Payee                                  string
	FreightPartner                         string
	IsExportImport                         string
	DeliverToPlantTimeZone                 string
	DeliverFromPlantTimeZone               string
	ReferenceDocument                      string
	ReferenceDocumentItem                  string
	OrderID                                string
	OrderItem                              string
	Contract                               string
	ContractItem                           string
	ProductionVersion                      string
	ProductionVersionItem                  string
	ProductionOrder                        string
	ProductionOrderItem                    string
	Operations                             string
	OperationsItem                         string
	OperationID                            string
	BillOfMaterial                         string
	BillOfMaterialItem                     string
	ContractType                           string
	OrderValidityStartDate                 string
	OrderValidityEndDate                   string
	PlannedGoodsIssueDate                  string
	PlannedGoodsIssueTime                  string
	PlannedGoodsReceiptDate                string
	PlannedGoodsReceiptTime                string
	FreightOrder                           string
	InvoiceDocumentDate                    string
	HeaderCompleteDeliveryIsDefined        string
	HeaderDeliveryStatus                   string
	GoodsIssueOrReceiptSlipNumber          string
	HeaderBillingStatus                    string
	HeaderBillingConfStatus                string
	HeaderBillingBlockStatus               string
	HeaderGrossWeight                      string
	HeaderNetWeight                        string
	HeaderWeightUnit                       string
	Incoterms                              string
	TransactionCurrency                    string
	HeaderDeliveryBlockStatus              string
	HeaderIssuingBlockStatus               string
	HeaderReceivingBlockStatus             string
	ExternalReferenceDocument              string
	CertificateAuthorityChain              string
	UsageControlChain                      string
	CreationDate                           string
	CreationTime                           string
	LastChangeDate                         string
	LastChangeTime                         string
	IsCancelled                            string
	IsMarkedForDeletion                    string
}{
	DeliveryDocument:                       "data_platform_delivery_document_header_data.DeliveryDocument",
	DeliveryDocumentDate:                   "data_platform_delivery_document_header_data.DeliveryDocumentDate",
	SupplyChainRelationshipID:              "data_platform_delivery_document_header_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:      "data_platform_delivery_document_header_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID: "data_platform_delivery_document_header_data.SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipBillingID:       "data_platform_delivery_document_header_data.SupplyChainRelationshipBillingID",
	SupplyChainRelationshipPaymentID:       "data_platform_delivery_document_header_data.SupplyChainRelationshipPaymentID",
	SupplyChainRelationshipFreightID:       "data_platform_delivery_document_header_data.SupplyChainRelationshipFreightID",
	Buyer:                                  "data_platform_delivery_document_header_data.Buyer",
	Seller:                                 "data_platform_delivery_document_header_data.Seller",
	DeliverToParty:                         "data_platform_delivery_document_header_data.DeliverToParty",
	DeliverFromParty:                       "data_platform_delivery_document_header_data.DeliverFromParty",
	DeliverToPlant:                         "data_platform_delivery_document_header_data.DeliverToPlant",
	DeliverFromPlant:                       "data_platform_delivery_document_header_data.DeliverFromPlant",
	BillToParty:                            "data_platform_delivery_document_header_data.BillToParty",
	BillFromParty:                          "data_platform_delivery_document_header_data.BillFromParty",
	BillToCountry:                          "data_platform_delivery_document_header_data.BillToCountry",
	BillFromCountry:                        "data_platform_delivery_document_header_data.BillFromCountry",
	Payer:                                  "data_platform_delivery_document_header_data.Payer",
	Payee:                                  "data_platform_delivery_document_header_data.Payee",
	FreightPartner:                         "data_platform_delivery_document_header_data.FreightPartner",
	IsExportImport:                         "data_platform_delivery_document_header_data.IsExportImport",
	DeliverToPlantTimeZone:                 "data_platform_delivery_document_header_data.DeliverToPlantTimeZone",
	DeliverFromPlantTimeZone:               "data_platform_delivery_document_header_data.DeliverFromPlantTimeZone",
	ReferenceDocument:                      "data_platform_delivery_document_header_data.ReferenceDocument",
	ReferenceDocumentItem:                  "data_platform_delivery_document_header_data.ReferenceDocumentItem",
	OrderID:                                "data_platform_delivery_document_header_data.OrderID",
	OrderItem:                              "data_platform_delivery_document_header_data.OrderItem",
	Contract:                               "data_platform_delivery_document_header_data.Contract",
	ContractItem:                           "data_platform_delivery_document_header_data.ContractItem",
	ProductionVersion:                      "data_platform_delivery_document_header_data.ProductionVersion",
	ProductionVersionItem:                  "data_platform_delivery_document_header_data.ProductionVersionItem",
	ProductionOrder:                        "data_platform_delivery_document_header_data.ProductionOrder",
	ProductionOrderItem:                    "data_platform_delivery_document_header_data.ProductionOrderItem",
	Operations:                             "data_platform_delivery_document_header_data.Operations",
	OperationsItem:                         "data_platform_delivery_document_header_data.OperationsItem",
	OperationID:                            "data_platform_delivery_document_header_data.OperationID",
	BillOfMaterial:                         "data_platform_delivery_document_header_data.BillOfMaterial",
	BillOfMaterialItem:                     "data_platform_delivery_document_header_data.BillOfMaterialItem",
	ContractType:                           "data_platform_delivery_document_header_data.ContractType",
	OrderValidityStartDate:                 "data_platform_delivery_document_header_data.OrderValidityStartDate",
	OrderValidityEndDate:                   "data_platform_delivery_document_header_data.OrderValidityEndDate",
	PlannedGoodsIssueDate:                  "data_platform_delivery_document_header_data.PlannedGoodsIssueDate",
	PlannedGoodsIssueTime:                  "data_platform_delivery_document_header_data.PlannedGoodsIssueTime",
	PlannedGoodsReceiptDate:                "data_platform_delivery_document_header_data.PlannedGoodsReceiptDate",
	PlannedGoodsReceiptTime:                "data_platform_delivery_document_header_data.PlannedGoodsReceiptTime",
	FreightOrder:                           "data_platform_delivery_document_header_data.FreightOrder",
	InvoiceDocumentDate:                    "data_platform_delivery_document_header_data.InvoiceDocumentDate",
	HeaderCompleteDeliveryIsDefined:        "data_platform_delivery_document_header_data.HeaderCompleteDeliveryIsDefined",
	HeaderDeliveryStatus:                   "data_platform_delivery_document_header_data.HeaderDeliveryStatus",
	GoodsIssueOrReceiptSlipNumber:          "data_platform_delivery_document_header_data.GoodsIssueOrReceiptSlipNumber",
	HeaderBillingStatus:                    "data_platform_delivery_document_header_data.HeaderBillingStatus",
	HeaderBillingConfStatus:                "data_platform_delivery_document_header_data.HeaderBillingConfStatus",
	HeaderBillingBlockStatus:               "data_platform_delivery_document_header_data.HeaderBillingBlockStatus",
	HeaderGrossWeight:                      "data_platform_delivery_document_header_data.HeaderGrossWeight",
	HeaderNetWeight:                        "data_platform_delivery_document_header_data.HeaderNetWeight",
	HeaderWeightUnit:                       "data_platform_delivery_document_header_data.HeaderWeightUnit",
	Incoterms:                              "data_platform_delivery_document_header_data.Incoterms",
	TransactionCurrency:                    "data_platform_delivery_document_header_data.TransactionCurrency",
	HeaderDeliveryBlockStatus:              "data_platform_delivery_document_header_data.HeaderDeliveryBlockStatus",
	HeaderIssuingBlockStatus:               "data_platform_delivery_document_header_data.HeaderIssuingBlockStatus",
	HeaderReceivingBlockStatus:             "data_platform_delivery_document_header_data.HeaderReceivingBlockStatus",
	ExternalReferenceDocument:              "data_platform_delivery_document_header_data.ExternalReferenceDocument",
	CertificateAuthorityChain:              "data_platform_delivery_document_header_data.CertificateAuthorityChain",
	UsageControlChain:                      "data_platform_delivery_document_header_data.UsageControlChain",
	CreationDate:                           "data_platform_delivery_document_header_data.CreationDate",
	CreationTime:                           "data_platform_delivery_document_header_data.CreationTime",
	LastChangeDate:                         "data_platform_delivery_document_header_data.LastChangeDate",
	LastChangeTime:                         "data_platform_delivery_document_header_data.LastChangeTime",
	IsCancelled:                            "data_platform_delivery_document_header_data.IsCancelled",
	IsMarkedForDeletion:                    "data_platform_delivery_document_header_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformDeliveryDocumentHeaderDatumWhere = struct {
	DeliveryDocument                       whereHelperint
	DeliveryDocumentDate                   whereHelperstring
	SupplyChainRelationshipID              whereHelperint
	SupplyChainRelationshipDeliveryID      whereHelperint
	SupplyChainRelationshipDeliveryPlantID whereHelperint
	SupplyChainRelationshipBillingID       whereHelpernull_Int
	SupplyChainRelationshipPaymentID       whereHelpernull_Int
	SupplyChainRelationshipFreightID       whereHelpernull_Int
	Buyer                                  whereHelperint
	Seller                                 whereHelperint
	DeliverToParty                         whereHelperint
	DeliverFromParty                       whereHelperint
	DeliverToPlant                         whereHelperstring
	DeliverFromPlant                       whereHelperstring
	BillToParty                            whereHelpernull_Int
	BillFromParty                          whereHelpernull_Int
	BillToCountry                          whereHelpernull_String
	BillFromCountry                        whereHelpernull_String
	Payer                                  whereHelpernull_Int
	Payee                                  whereHelpernull_Int
	FreightPartner                         whereHelpernull_Int
	IsExportImport                         whereHelpernull_Bool
	DeliverToPlantTimeZone                 whereHelpernull_String
	DeliverFromPlantTimeZone               whereHelpernull_String
	ReferenceDocument                      whereHelpernull_Int
	ReferenceDocumentItem                  whereHelpernull_Int
	OrderID                                whereHelpernull_Int
	OrderItem                              whereHelpernull_Int
	Contract                               whereHelpernull_Int
	ContractItem                           whereHelpernull_Int
	ProductionVersion                      whereHelpernull_Int
	ProductionVersionItem                  whereHelpernull_Int
	ProductionOrder                        whereHelpernull_Int
	ProductionOrderItem                    whereHelpernull_Int
	Operations                             whereHelpernull_Int
	OperationsItem                         whereHelpernull_Int
	OperationID                            whereHelpernull_Int
	BillOfMaterial                         whereHelpernull_Int
	BillOfMaterialItem                     whereHelpernull_Int
	ContractType                           whereHelpernull_String
	OrderValidityStartDate                 whereHelpernull_String
	OrderValidityEndDate                   whereHelpernull_String
	PlannedGoodsIssueDate                  whereHelperstring
	PlannedGoodsIssueTime                  whereHelperstring
	PlannedGoodsReceiptDate                whereHelperstring
	PlannedGoodsReceiptTime                whereHelperstring
	FreightOrder                           whereHelpernull_Int
	InvoiceDocumentDate                    whereHelpernull_String
	HeaderCompleteDeliveryIsDefined        whereHelpernull_Bool
	HeaderDeliveryStatus                   whereHelpernull_String
	GoodsIssueOrReceiptSlipNumber          whereHelpernull_String
	HeaderBillingStatus                    whereHelpernull_String
	HeaderBillingConfStatus                whereHelpernull_String
	HeaderBillingBlockStatus               whereHelpernull_Bool
	HeaderGrossWeight                      whereHelpernull_Float32
	HeaderNetWeight                        whereHelpernull_Float32
	HeaderWeightUnit                       whereHelpernull_String
	Incoterms                              whereHelpernull_String
	TransactionCurrency                    whereHelpernull_String
	HeaderDeliveryBlockStatus              whereHelpernull_Bool
	HeaderIssuingBlockStatus               whereHelpernull_Bool
	HeaderReceivingBlockStatus             whereHelpernull_Bool
	ExternalReferenceDocument              whereHelpernull_String
	CertificateAuthorityChain              whereHelpernull_String
	UsageControlChain                      whereHelpernull_String
	CreationDate                           whereHelperstring
	CreationTime                           whereHelperstring
	LastChangeDate                         whereHelperstring
	LastChangeTime                         whereHelperstring
	IsCancelled                            whereHelpernull_Bool
	IsMarkedForDeletion                    whereHelpernull_Bool
}{
	DeliveryDocument:                       whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliveryDocument`"},
	DeliveryDocumentDate:                   whereHelperstring{field: "`data_platform_delivery_document_header_data`.`DeliveryDocumentDate`"},
	SupplyChainRelationshipID:              whereHelperint{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:      whereHelperint{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID: whereHelperint{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	SupplyChainRelationshipBillingID:       whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipBillingID`"},
	SupplyChainRelationshipPaymentID:       whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipPaymentID`"},
	SupplyChainRelationshipFreightID:       whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipFreightID`"},
	Buyer:                                  whereHelperint{field: "`data_platform_delivery_document_header_data`.`Buyer`"},
	Seller:                                 whereHelperint{field: "`data_platform_delivery_document_header_data`.`Seller`"},
	DeliverToParty:                         whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliverToParty`"},
	DeliverFromParty:                       whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliverFromParty`"},
	DeliverToPlant:                         whereHelperstring{field: "`data_platform_delivery_document_header_data`.`DeliverToPlant`"},
	DeliverFromPlant:                       whereHelperstring{field: "`data_platform_delivery_document_header_data`.`DeliverFromPlant`"},
	BillToParty:                            whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillToParty`"},
	BillFromParty:                          whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillFromParty`"},
	BillToCountry:                          whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`BillToCountry`"},
	BillFromCountry:                        whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`BillFromCountry`"},
	Payer:                                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Payer`"},
	Payee:                                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Payee`"},
	FreightPartner:                         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`FreightPartner`"},
	IsExportImport:                         whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsExportImport`"},
	DeliverToPlantTimeZone:                 whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`DeliverToPlantTimeZone`"},
	DeliverFromPlantTimeZone:               whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`DeliverFromPlantTimeZone`"},
	ReferenceDocument:                      whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReferenceDocument`"},
	ReferenceDocumentItem:                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReferenceDocumentItem`"},
	OrderID:                                whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OrderID`"},
	OrderItem:                              whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OrderItem`"},
	Contract:                               whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Contract`"},
	ContractItem:                           whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ContractItem`"},
	ProductionVersion:                      whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ProductionVersion`"},
	ProductionVersionItem:                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ProductionVersionItem`"},
	ProductionOrder:                        whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ProductionOrder`"},
	ProductionOrderItem:                    whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ProductionOrderItem`"},
	Operations:                             whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Operations`"},
	OperationsItem:                         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OperationsItem`"},
	OperationID:                            whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OperationID`"},
	BillOfMaterial:                         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillOfMaterial`"},
	BillOfMaterialItem:                     whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillOfMaterialItem`"},
	ContractType:                           whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`ContractType`"},
	OrderValidityStartDate:                 whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`OrderValidityStartDate`"},
	OrderValidityEndDate:                   whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`OrderValidityEndDate`"},
	PlannedGoodsIssueDate:                  whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsIssueDate`"},
	PlannedGoodsIssueTime:                  whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsIssueTime`"},
	PlannedGoodsReceiptDate:                whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsReceiptDate`"},
	PlannedGoodsReceiptTime:                whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsReceiptTime`"},
	FreightOrder:                           whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`FreightOrder`"},
	InvoiceDocumentDate:                    whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`InvoiceDocumentDate`"},
	HeaderCompleteDeliveryIsDefined:        whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderCompleteDeliveryIsDefined`"},
	HeaderDeliveryStatus:                   whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderDeliveryStatus`"},
	GoodsIssueOrReceiptSlipNumber:          whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`GoodsIssueOrReceiptSlipNumber`"},
	HeaderBillingStatus:                    whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderBillingStatus`"},
	HeaderBillingConfStatus:                whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderBillingConfStatus`"},
	HeaderBillingBlockStatus:               whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderBillingBlockStatus`"},
	HeaderGrossWeight:                      whereHelpernull_Float32{field: "`data_platform_delivery_document_header_data`.`HeaderGrossWeight`"},
	HeaderNetWeight:                        whereHelpernull_Float32{field: "`data_platform_delivery_document_header_data`.`HeaderNetWeight`"},
	HeaderWeightUnit:                       whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderWeightUnit`"},
	Incoterms:                              whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`Incoterms`"},
	TransactionCurrency:                    whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`TransactionCurrency`"},
	HeaderDeliveryBlockStatus:              whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderDeliveryBlockStatus`"},
	HeaderIssuingBlockStatus:               whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderIssuingBlockStatus`"},
	HeaderReceivingBlockStatus:             whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderReceivingBlockStatus`"},
	ExternalReferenceDocument:              whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`ExternalReferenceDocument`"},
	CertificateAuthorityChain:              whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`CertificateAuthorityChain`"},
	UsageControlChain:                      whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`UsageControlChain`"},
	CreationDate:                           whereHelperstring{field: "`data_platform_delivery_document_header_data`.`CreationDate`"},
	CreationTime:                           whereHelperstring{field: "`data_platform_delivery_document_header_data`.`CreationTime`"},
	LastChangeDate:                         whereHelperstring{field: "`data_platform_delivery_document_header_data`.`LastChangeDate`"},
	LastChangeTime:                         whereHelperstring{field: "`data_platform_delivery_document_header_data`.`LastChangeTime`"},
	IsCancelled:                            whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsCancelled`"},
	IsMarkedForDeletion:                    whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsMarkedForDeletion`"},
}

// DataPlatformDeliveryDocumentHeaderDatumRels is where relationship names are stored.
var DataPlatformDeliveryDocumentHeaderDatumRels = struct {
	BillFromCountryDataPlatformCountryCountryDatum            string
	BillOfMaterialDataPlatformBillOfMaterialItemDatum         string
	BillToCountryDataPlatformCountryCountryDatum              string
	ContractDataPlatformContractItemDatum                     string
	ContractDataPlatformContractHeaderDatum                   string
	DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum string
	DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum   string
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum string
	Incoterm                                                  string
	OrderIDDataPlatformOrdersItemDatum                        string
	OperationIDDataPlatformProductionOrderItemOperationDatum  string
	ProductionOrderDataPlatformProductionOrderItemDatum       string
	BillFromPartyDataPlatformSCRBillingRelationDatum          string
	BuyerDataPlatformSCRDeliveryRelationDatum                 string
	BuyerDataPlatformSCRDeliveryPlantRelationDatum            string
	BillFromPartyDataPlatformSCRPaymentRelationDatum          string
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum      string
	DeliveryDocumentDataPlatformDeliveryDocumentAddressData   string
	DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData string
	DeliveryDocumentDataPlatformDeliveryDocumentItemData      string
	DeliveryDocumentDataPlatformDeliveryDocumentPartnerData   string
}{
	BillFromCountryDataPlatformCountryCountryDatum:            "BillFromCountryDataPlatformCountryCountryDatum",
	BillOfMaterialDataPlatformBillOfMaterialItemDatum:         "BillOfMaterialDataPlatformBillOfMaterialItemDatum",
	BillToCountryDataPlatformCountryCountryDatum:              "BillToCountryDataPlatformCountryCountryDatum",
	ContractDataPlatformContractItemDatum:                     "ContractDataPlatformContractItemDatum",
	ContractDataPlatformContractHeaderDatum:                   "ContractDataPlatformContractHeaderDatum",
	DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: "DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum",
	DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum:   "DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum",
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: "HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum",
	Incoterm:                           "Incoterm",
	OrderIDDataPlatformOrdersItemDatum: "OrderIDDataPlatformOrdersItemDatum",
	OperationIDDataPlatformProductionOrderItemOperationDatum:  "OperationIDDataPlatformProductionOrderItemOperationDatum",
	ProductionOrderDataPlatformProductionOrderItemDatum:       "ProductionOrderDataPlatformProductionOrderItemDatum",
	BillFromPartyDataPlatformSCRBillingRelationDatum:          "BillFromPartyDataPlatformSCRBillingRelationDatum",
	BuyerDataPlatformSCRDeliveryRelationDatum:                 "BuyerDataPlatformSCRDeliveryRelationDatum",
	BuyerDataPlatformSCRDeliveryPlantRelationDatum:            "BuyerDataPlatformSCRDeliveryPlantRelationDatum",
	BillFromPartyDataPlatformSCRPaymentRelationDatum:          "BillFromPartyDataPlatformSCRPaymentRelationDatum",
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum:      "TransactionCurrencyDataPlatformCurrencyCurrencyDatum",
	DeliveryDocumentDataPlatformDeliveryDocumentAddressData:   "DeliveryDocumentDataPlatformDeliveryDocumentAddressData",
	DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData: "DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData",
	DeliveryDocumentDataPlatformDeliveryDocumentItemData:      "DeliveryDocumentDataPlatformDeliveryDocumentItemData",
	DeliveryDocumentDataPlatformDeliveryDocumentPartnerData:   "DeliveryDocumentDataPlatformDeliveryDocumentPartnerData",
}

// dataPlatformDeliveryDocumentHeaderDatumR is where relationships are stored.
type dataPlatformDeliveryDocumentHeaderDatumR struct {
	BillFromCountryDataPlatformCountryCountryDatum            *DataPlatformCountryCountryDatum                `boil:"BillFromCountryDataPlatformCountryCountryDatum" json:"BillFromCountryDataPlatformCountryCountryDatum" toml:"BillFromCountryDataPlatformCountryCountryDatum" yaml:"BillFromCountryDataPlatformCountryCountryDatum"`
	BillOfMaterialDataPlatformBillOfMaterialItemDatum         *DataPlatformBillOfMaterialItemDatum            `boil:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" json:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" toml:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" yaml:"BillOfMaterialDataPlatformBillOfMaterialItemDatum"`
	BillToCountryDataPlatformCountryCountryDatum              *DataPlatformCountryCountryDatum                `boil:"BillToCountryDataPlatformCountryCountryDatum" json:"BillToCountryDataPlatformCountryCountryDatum" toml:"BillToCountryDataPlatformCountryCountryDatum" yaml:"BillToCountryDataPlatformCountryCountryDatum"`
	ContractDataPlatformContractItemDatum                     *DataPlatformContractItemDatum                  `boil:"ContractDataPlatformContractItemDatum" json:"ContractDataPlatformContractItemDatum" toml:"ContractDataPlatformContractItemDatum" yaml:"ContractDataPlatformContractItemDatum"`
	ContractDataPlatformContractHeaderDatum                   *DataPlatformContractHeaderDatum                `boil:"ContractDataPlatformContractHeaderDatum" json:"ContractDataPlatformContractHeaderDatum" toml:"ContractDataPlatformContractHeaderDatum" yaml:"ContractDataPlatformContractHeaderDatum"`
	DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum *DataPlatformTimeZoneTimeZoneDatum              `boil:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" json:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" toml:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" yaml:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum"`
	DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum   *DataPlatformTimeZoneTimeZoneDatum              `boil:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" json:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" toml:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" yaml:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum"`
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum      `boil:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	Incoterm                                                  *DataPlatformIncotermsIncotermsDatum            `boil:"Incoterm" json:"Incoterm" toml:"Incoterm" yaml:"Incoterm"`
	OrderIDDataPlatformOrdersItemDatum                        *DataPlatformOrdersItemDatum                    `boil:"OrderIDDataPlatformOrdersItemDatum" json:"OrderIDDataPlatformOrdersItemDatum" toml:"OrderIDDataPlatformOrdersItemDatum" yaml:"OrderIDDataPlatformOrdersItemDatum"`
	OperationIDDataPlatformProductionOrderItemOperationDatum  *DataPlatformProductionOrderItemOperationDatum  `boil:"OperationIDDataPlatformProductionOrderItemOperationDatum" json:"OperationIDDataPlatformProductionOrderItemOperationDatum" toml:"OperationIDDataPlatformProductionOrderItemOperationDatum" yaml:"OperationIDDataPlatformProductionOrderItemOperationDatum"`
	ProductionOrderDataPlatformProductionOrderItemDatum       *DataPlatformProductionOrderItemDatum           `boil:"ProductionOrderDataPlatformProductionOrderItemDatum" json:"ProductionOrderDataPlatformProductionOrderItemDatum" toml:"ProductionOrderDataPlatformProductionOrderItemDatum" yaml:"ProductionOrderDataPlatformProductionOrderItemDatum"`
	BillFromPartyDataPlatformSCRBillingRelationDatum          *DataPlatformSCRBillingRelationDatum            `boil:"BillFromPartyDataPlatformSCRBillingRelationDatum" json:"BillFromPartyDataPlatformSCRBillingRelationDatum" toml:"BillFromPartyDataPlatformSCRBillingRelationDatum" yaml:"BillFromPartyDataPlatformSCRBillingRelationDatum"`
	BuyerDataPlatformSCRDeliveryRelationDatum                 *DataPlatformSCRDeliveryRelationDatum           `boil:"BuyerDataPlatformSCRDeliveryRelationDatum" json:"BuyerDataPlatformSCRDeliveryRelationDatum" toml:"BuyerDataPlatformSCRDeliveryRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryRelationDatum"`
	BuyerDataPlatformSCRDeliveryPlantRelationDatum            *DataPlatformSCRDeliveryPlantRelationDatum      `boil:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" json:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" toml:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryPlantRelationDatum"`
	BillFromPartyDataPlatformSCRPaymentRelationDatum          *DataPlatformSCRPaymentRelationDatum            `boil:"BillFromPartyDataPlatformSCRPaymentRelationDatum" json:"BillFromPartyDataPlatformSCRPaymentRelationDatum" toml:"BillFromPartyDataPlatformSCRPaymentRelationDatum" yaml:"BillFromPartyDataPlatformSCRPaymentRelationDatum"`
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum      *DataPlatformCurrencyCurrencyDatum              `boil:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" json:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" toml:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" yaml:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum"`
	DeliveryDocumentDataPlatformDeliveryDocumentAddressData   DataPlatformDeliveryDocumentAddressDatumSlice   `boil:"DeliveryDocumentDataPlatformDeliveryDocumentAddressData" json:"DeliveryDocumentDataPlatformDeliveryDocumentAddressData" toml:"DeliveryDocumentDataPlatformDeliveryDocumentAddressData" yaml:"DeliveryDocumentDataPlatformDeliveryDocumentAddressData"`
	DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData DataPlatformDeliveryDocumentHeaderDocDatumSlice `boil:"DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData" json:"DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData" toml:"DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData" yaml:"DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData"`
	DeliveryDocumentDataPlatformDeliveryDocumentItemData      DataPlatformDeliveryDocumentItemDatumSlice      `boil:"DeliveryDocumentDataPlatformDeliveryDocumentItemData" json:"DeliveryDocumentDataPlatformDeliveryDocumentItemData" toml:"DeliveryDocumentDataPlatformDeliveryDocumentItemData" yaml:"DeliveryDocumentDataPlatformDeliveryDocumentItemData"`
	DeliveryDocumentDataPlatformDeliveryDocumentPartnerData   DataPlatformDeliveryDocumentPartnerDatumSlice   `boil:"DeliveryDocumentDataPlatformDeliveryDocumentPartnerData" json:"DeliveryDocumentDataPlatformDeliveryDocumentPartnerData" toml:"DeliveryDocumentDataPlatformDeliveryDocumentPartnerData" yaml:"DeliveryDocumentDataPlatformDeliveryDocumentPartnerData"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformDeliveryDocumentHeaderDatumR) NewStruct() *dataPlatformDeliveryDocumentHeaderDatumR {
	return &dataPlatformDeliveryDocumentHeaderDatumR{}
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillFromCountryDataPlatformCountryCountryDatum() *DataPlatformCountryCountryDatum {
	if r == nil {
		return nil
	}
	return r.BillFromCountryDataPlatformCountryCountryDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillOfMaterialDataPlatformBillOfMaterialItemDatum() *DataPlatformBillOfMaterialItemDatum {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformBillOfMaterialItemDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillToCountryDataPlatformCountryCountryDatum() *DataPlatformCountryCountryDatum {
	if r == nil {
		return nil
	}
	return r.BillToCountryDataPlatformCountryCountryDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetContractDataPlatformContractItemDatum() *DataPlatformContractItemDatum {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformContractItemDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetContractDataPlatformContractHeaderDatum() *DataPlatformContractHeaderDatum {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformContractHeaderDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetIncoterm() *DataPlatformIncotermsIncotermsDatum {
	if r == nil {
		return nil
	}
	return r.Incoterm
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetOrderIDDataPlatformOrdersItemDatum() *DataPlatformOrdersItemDatum {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetOperationIDDataPlatformProductionOrderItemOperationDatum() *DataPlatformProductionOrderItemOperationDatum {
	if r == nil {
		return nil
	}
	return r.OperationIDDataPlatformProductionOrderItemOperationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetProductionOrderDataPlatformProductionOrderItemDatum() *DataPlatformProductionOrderItemDatum {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillFromPartyDataPlatformSCRBillingRelationDatum() *DataPlatformSCRBillingRelationDatum {
	if r == nil {
		return nil
	}
	return r.BillFromPartyDataPlatformSCRBillingRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBuyerDataPlatformSCRDeliveryRelationDatum() *DataPlatformSCRDeliveryRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBuyerDataPlatformSCRDeliveryPlantRelationDatum() *DataPlatformSCRDeliveryPlantRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryPlantRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillFromPartyDataPlatformSCRPaymentRelationDatum() *DataPlatformSCRPaymentRelationDatum {
	if r == nil {
		return nil
	}
	return r.BillFromPartyDataPlatformSCRPaymentRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetTransactionCurrencyDataPlatformCurrencyCurrencyDatum() *DataPlatformCurrencyCurrencyDatum {
	if r == nil {
		return nil
	}
	return r.TransactionCurrencyDataPlatformCurrencyCurrencyDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliveryDocumentDataPlatformDeliveryDocumentAddressData() DataPlatformDeliveryDocumentAddressDatumSlice {
	if r == nil {
		return nil
	}
	return r.DeliveryDocumentDataPlatformDeliveryDocumentAddressData
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData() DataPlatformDeliveryDocumentHeaderDocDatumSlice {
	if r == nil {
		return nil
	}
	return r.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliveryDocumentDataPlatformDeliveryDocumentItemData() DataPlatformDeliveryDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.DeliveryDocumentDataPlatformDeliveryDocumentItemData
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliveryDocumentDataPlatformDeliveryDocumentPartnerData() DataPlatformDeliveryDocumentPartnerDatumSlice {
	if r == nil {
		return nil
	}
	return r.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData
}

// dataPlatformDeliveryDocumentHeaderDatumL is where Load methods for each relationship are stored.
type dataPlatformDeliveryDocumentHeaderDatumL struct{}

var (
	dataPlatformDeliveryDocumentHeaderDatumAllColumns            = []string{"DeliveryDocument", "DeliveryDocumentDate", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipBillingID", "SupplyChainRelationshipPaymentID", "SupplyChainRelationshipFreightID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "BillToParty", "BillFromParty", "BillToCountry", "BillFromCountry", "Payer", "Payee", "FreightPartner", "IsExportImport", "DeliverToPlantTimeZone", "DeliverFromPlantTimeZone", "ReferenceDocument", "ReferenceDocumentItem", "OrderID", "OrderItem", "Contract", "ContractItem", "ProductionVersion", "ProductionVersionItem", "ProductionOrder", "ProductionOrderItem", "Operations", "OperationsItem", "OperationID", "BillOfMaterial", "BillOfMaterialItem", "ContractType", "OrderValidityStartDate", "OrderValidityEndDate", "PlannedGoodsIssueDate", "PlannedGoodsIssueTime", "PlannedGoodsReceiptDate", "PlannedGoodsReceiptTime", "FreightOrder", "InvoiceDocumentDate", "HeaderCompleteDeliveryIsDefined", "HeaderDeliveryStatus", "GoodsIssueOrReceiptSlipNumber", "HeaderBillingStatus", "HeaderBillingConfStatus", "HeaderBillingBlockStatus", "HeaderGrossWeight", "HeaderNetWeight", "HeaderWeightUnit", "Incoterms", "TransactionCurrency", "HeaderDeliveryBlockStatus", "HeaderIssuingBlockStatus", "HeaderReceivingBlockStatus", "ExternalReferenceDocument", "CertificateAuthorityChain", "UsageControlChain", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault = []string{"DeliveryDocument", "DeliveryDocumentDate", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipBillingID", "SupplyChainRelationshipPaymentID", "SupplyChainRelationshipFreightID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "BillToParty", "BillFromParty", "BillToCountry", "BillFromCountry", "Payer", "Payee", "FreightPartner", "IsExportImport", "DeliverToPlantTimeZone", "DeliverFromPlantTimeZone", "ReferenceDocument", "ReferenceDocumentItem", "OrderID", "OrderItem", "Contract", "ContractItem", "ProductionVersion", "ProductionVersionItem", "ProductionOrder", "ProductionOrderItem", "Operations", "OperationsItem", "OperationID", "BillOfMaterial", "BillOfMaterialItem", "ContractType", "OrderValidityStartDate", "OrderValidityEndDate", "PlannedGoodsIssueDate", "PlannedGoodsIssueTime", "PlannedGoodsReceiptDate", "PlannedGoodsReceiptTime", "FreightOrder", "InvoiceDocumentDate", "HeaderCompleteDeliveryIsDefined", "HeaderDeliveryStatus", "GoodsIssueOrReceiptSlipNumber", "HeaderBillingStatus", "HeaderBillingConfStatus", "HeaderBillingBlockStatus", "HeaderGrossWeight", "HeaderNetWeight", "HeaderWeightUnit", "Incoterms", "TransactionCurrency", "HeaderDeliveryBlockStatus", "HeaderIssuingBlockStatus", "HeaderReceivingBlockStatus", "ExternalReferenceDocument", "CertificateAuthorityChain", "UsageControlChain", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault    = []string{}
	dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns     = []string{"DeliveryDocument"}
	dataPlatformDeliveryDocumentHeaderDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformDeliveryDocumentHeaderDatumSlice is an alias for a slice of pointers to DataPlatformDeliveryDocumentHeaderDatum.
	// This should almost always be used instead of []DataPlatformDeliveryDocumentHeaderDatum.
	DataPlatformDeliveryDocumentHeaderDatumSlice []*DataPlatformDeliveryDocumentHeaderDatum

	dataPlatformDeliveryDocumentHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformDeliveryDocumentHeaderDatumType                 = reflect.TypeOf(&DataPlatformDeliveryDocumentHeaderDatum{})
	dataPlatformDeliveryDocumentHeaderDatumMapping              = queries.MakeStructMapping(dataPlatformDeliveryDocumentHeaderDatumType)
	dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns)
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumInsertCache          = make(map[string]insertCache)
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformDeliveryDocumentHeaderDatum record from the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformDeliveryDocumentHeaderDatum, error) {
	o := &DataPlatformDeliveryDocumentHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_delivery_document_header_data")
	}

	return o, nil
}

// All returns all DataPlatformDeliveryDocumentHeaderDatum records from the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformDeliveryDocumentHeaderDatumSlice, error) {
	var o []*DataPlatformDeliveryDocumentHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformDeliveryDocumentHeaderDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformDeliveryDocumentHeaderDatum records in the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_delivery_document_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_delivery_document_header_data exists")
	}

	return count > 0, nil
}

// BillFromCountryDataPlatformCountryCountryDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillFromCountryDataPlatformCountryCountryDatum(mods ...qm.QueryMod) dataPlatformCountryCountryDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Country` = ?", o.BillFromCountry),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCountryCountryData(queryMods...)
}

// BillOfMaterialDataPlatformBillOfMaterialItemDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillOfMaterialDataPlatformBillOfMaterialItemDatum(mods ...qm.QueryMod) dataPlatformBillOfMaterialItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillOfMaterial` = ?", o.BillOfMaterial),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBillOfMaterialItemData(queryMods...)
}

// BillToCountryDataPlatformCountryCountryDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillToCountryDataPlatformCountryCountryDatum(mods ...qm.QueryMod) dataPlatformCountryCountryDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Country` = ?", o.BillToCountry),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCountryCountryData(queryMods...)
}

// ContractDataPlatformContractItemDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) ContractDataPlatformContractItemDatum(mods ...qm.QueryMod) dataPlatformContractItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Contract` = ?", o.Contract),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformContractItemData(queryMods...)
}

// ContractDataPlatformContractHeaderDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) ContractDataPlatformContractHeaderDatum(mods ...qm.QueryMod) dataPlatformContractHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Contract` = ?", o.Contract),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformContractHeaderData(queryMods...)
}

// DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.DeliverFromPlantTimeZone),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.DeliverToPlantTimeZone),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.HeaderWeightUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// Incoterm pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Incoterm(mods ...qm.QueryMod) dataPlatformIncotermsIncotermsDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Incoterms` = ?", o.Incoterms),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformIncotermsIncotermsData(queryMods...)
}

// OrderIDDataPlatformOrdersItemDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) OrderIDDataPlatformOrdersItemDatum(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OrderID` = ?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOrdersItemData(queryMods...)
}

// OperationIDDataPlatformProductionOrderItemOperationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) OperationIDDataPlatformProductionOrderItemOperationDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemOperationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OperationID` = ?", o.OperationID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemOperationData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) ProductionOrderDataPlatformProductionOrderItemDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionOrder` = ?", o.ProductionOrder),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemData(queryMods...)
}

// BillFromPartyDataPlatformSCRBillingRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillFromPartyDataPlatformSCRBillingRelationDatum(mods ...qm.QueryMod) dataPlatformSCRBillingRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillFromParty` = ?", o.BillFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRBillingRelationData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BuyerDataPlatformSCRDeliveryRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryRelationData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryPlantRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BuyerDataPlatformSCRDeliveryPlantRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryPlantRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryPlantRelationData(queryMods...)
}

// BillFromPartyDataPlatformSCRPaymentRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillFromPartyDataPlatformSCRPaymentRelationDatum(mods ...qm.QueryMod) dataPlatformSCRPaymentRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillFromParty` = ?", o.BillFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRPaymentRelationData(queryMods...)
}

// TransactionCurrencyDataPlatformCurrencyCurrencyDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) TransactionCurrencyDataPlatformCurrencyCurrencyDatum(mods ...qm.QueryMod) dataPlatformCurrencyCurrencyDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Currency` = ?", o.TransactionCurrency),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCurrencyCurrencyData(queryMods...)
}

// DeliveryDocumentDataPlatformDeliveryDocumentAddressData retrieves all the data_platform_delivery_document_address_datum's DataPlatformDeliveryDocumentAddressData with an executor via DeliveryDocument column.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliveryDocumentDataPlatformDeliveryDocumentAddressData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentAddressDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_address_data`.`DeliveryDocument`=?", o.DeliveryDocument),
	)

	return DataPlatformDeliveryDocumentAddressData(queryMods...)
}

// DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData retrieves all the data_platform_delivery_document_header_doc_datum's DataPlatformDeliveryDocumentHeaderDocData with an executor via DeliveryDocument column.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDocDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_header_doc_data`.`DeliveryDocument`=?", o.DeliveryDocument),
	)

	return DataPlatformDeliveryDocumentHeaderDocData(queryMods...)
}

// DeliveryDocumentDataPlatformDeliveryDocumentItemData retrieves all the data_platform_delivery_document_item_datum's DataPlatformDeliveryDocumentItemData with an executor via DeliveryDocument column.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliveryDocumentDataPlatformDeliveryDocumentItemData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_item_data`.`DeliveryDocument`=?", o.DeliveryDocument),
	)

	return DataPlatformDeliveryDocumentItemData(queryMods...)
}

// DeliveryDocumentDataPlatformDeliveryDocumentPartnerData retrieves all the data_platform_delivery_document_partner_datum's DataPlatformDeliveryDocumentPartnerData with an executor via DeliveryDocument column.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliveryDocumentDataPlatformDeliveryDocumentPartnerData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentPartnerDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_partner_data`.`DeliveryDocument`=?", o.DeliveryDocument),
	)

	return DataPlatformDeliveryDocumentPartnerData(queryMods...)
}

// LoadBillFromCountryDataPlatformCountryCountryDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillFromCountryDataPlatformCountryCountryDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillFromCountry) {
			args = append(args, object.BillFromCountry)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillFromCountry) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillFromCountry) {
				args = append(args, obj.BillFromCountry)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_country_country_data`),
		qm.WhereIn(`data_platform_country_country_data.Country in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCountryCountryDatum")
	}

	var resultSlice []*DataPlatformCountryCountryDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCountryCountryDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_country_country_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_country_country_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillFromCountryDataPlatformCountryCountryDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillFromCountry, foreign.Country) {
				local.R.BillFromCountryDataPlatformCountryCountryDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillOfMaterialDataPlatformBillOfMaterialItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillOfMaterial) {
			args = append(args, object.BillOfMaterial)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillOfMaterial) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillOfMaterial) {
				args = append(args, obj.BillOfMaterial)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_bill_of_material_item_data`),
		qm.WhereIn(`data_platform_bill_of_material_item_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBillOfMaterialItemDatum")
	}

	var resultSlice []*DataPlatformBillOfMaterialItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBillOfMaterialItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_bill_of_material_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_bill_of_material_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillOfMaterial, foreign.BillOfMaterial) {
				local.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillToCountryDataPlatformCountryCountryDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillToCountryDataPlatformCountryCountryDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillToCountry) {
			args = append(args, object.BillToCountry)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillToCountry) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillToCountry) {
				args = append(args, obj.BillToCountry)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_country_country_data`),
		qm.WhereIn(`data_platform_country_country_data.Country in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCountryCountryDatum")
	}

	var resultSlice []*DataPlatformCountryCountryDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCountryCountryDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_country_country_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_country_country_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillToCountryDataPlatformCountryCountryDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillToCountry, foreign.Country) {
				local.R.BillToCountryDataPlatformCountryCountryDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformContractItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadContractDataPlatformContractItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Contract) {
			args = append(args, object.Contract)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Contract) {
				args = append(args, obj.Contract)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_contract_item_data`),
		qm.WhereIn(`data_platform_contract_item_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformContractItemDatum")
	}

	var resultSlice []*DataPlatformContractItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformContractItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_contract_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_contract_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ContractDataPlatformContractItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformContractItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformContractHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadContractDataPlatformContractHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Contract) {
			args = append(args, object.Contract)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Contract) {
				args = append(args, obj.Contract)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_contract_header_data`),
		qm.WhereIn(`data_platform_contract_header_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformContractHeaderDatum")
	}

	var resultSlice []*DataPlatformContractHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformContractHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_contract_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_contract_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ContractDataPlatformContractHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformContractHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.DeliverFromPlantTimeZone) {
			args = append(args, object.DeliverFromPlantTimeZone)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromPlantTimeZone) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromPlantTimeZone) {
				args = append(args, obj.DeliverFromPlantTimeZone)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromPlantTimeZone, foreign.TimeZone) {
				local.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.DeliverToPlantTimeZone) {
			args = append(args, object.DeliverToPlantTimeZone)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverToPlantTimeZone) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverToPlantTimeZone) {
				args = append(args, obj.DeliverToPlantTimeZone)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverToPlantTimeZone, foreign.TimeZone) {
				local.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.HeaderWeightUnit) {
			args = append(args, object.HeaderWeightUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.HeaderWeightUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.HeaderWeightUnit) {
				args = append(args, obj.HeaderWeightUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.HeaderWeightUnit, foreign.QuantityUnit) {
				local.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadIncoterm allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadIncoterm(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Incoterms) {
			args = append(args, object.Incoterms)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Incoterms) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Incoterms) {
				args = append(args, obj.Incoterms)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_incoterms_incoterms_data`),
		qm.WhereIn(`data_platform_incoterms_incoterms_data.Incoterms in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformIncotermsIncotermsDatum")
	}

	var resultSlice []*DataPlatformIncotermsIncotermsDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformIncotermsIncotermsDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_incoterms_incoterms_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_incoterms_incoterms_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Incoterm = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Incoterms, foreign.Incoterms) {
				local.R.Incoterm = foreign
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadOrderIDDataPlatformOrdersItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.OrderID) {
			args = append(args, object.OrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrderID) {
				args = append(args, obj.OrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOrdersItemDatum")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOrdersItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrderIDDataPlatformOrdersItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformOrdersItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadOperationIDDataPlatformProductionOrderItemOperationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadOperationIDDataPlatformProductionOrderItemOperationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.OperationID) {
			args = append(args, object.OperationID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OperationID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OperationID) {
				args = append(args, obj.OperationID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_operation_data`),
		qm.WhereIn(`data_platform_production_order_item_operation_data.OperationID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemOperationDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemOperationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemOperationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_operation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_operation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OperationIDDataPlatformProductionOrderItemOperationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OperationID, foreign.OperationID) {
				local.R.OperationIDDataPlatformProductionOrderItemOperationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.ProductionOrder) {
			args = append(args, object.ProductionOrder)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductionOrder) {
				args = append(args, obj.ProductionOrder)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_data`),
		qm.WhereIn(`data_platform_production_order_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillFromPartyDataPlatformSCRBillingRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillFromPartyDataPlatformSCRBillingRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillFromParty) {
			args = append(args, object.BillFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillFromParty) {
				args = append(args, obj.BillFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_billing_relation_data`),
		qm.WhereIn(`data_platform_scr_billing_relation_data.BillFromParty in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRBillingRelationDatum")
	}

	var resultSlice []*DataPlatformSCRBillingRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRBillingRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_billing_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_billing_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillFromPartyDataPlatformSCRBillingRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillFromParty, foreign.BillFromParty) {
				local.R.BillFromPartyDataPlatformSCRBillingRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryPlantRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBuyerDataPlatformSCRDeliveryPlantRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_plant_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_plant_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryPlantRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryPlantRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryPlantRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_plant_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_plant_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillFromPartyDataPlatformSCRPaymentRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillFromPartyDataPlatformSCRPaymentRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillFromParty) {
			args = append(args, object.BillFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillFromParty) {
				args = append(args, obj.BillFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_payment_relation_data`),
		qm.WhereIn(`data_platform_scr_payment_relation_data.BillFromParty in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRPaymentRelationDatum")
	}

	var resultSlice []*DataPlatformSCRPaymentRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRPaymentRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_payment_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_payment_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillFromParty, foreign.BillFromParty) {
				local.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadTransactionCurrencyDataPlatformCurrencyCurrencyDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.TransactionCurrency) {
			args = append(args, object.TransactionCurrency)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.TransactionCurrency) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.TransactionCurrency) {
				args = append(args, obj.TransactionCurrency)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_currency_currency_data`),
		qm.WhereIn(`data_platform_currency_currency_data.Currency in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCurrencyCurrencyDatum")
	}

	var resultSlice []*DataPlatformCurrencyCurrencyDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCurrencyCurrencyDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_currency_currency_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_currency_currency_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TransactionCurrency, foreign.Currency) {
				local.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliveryDocumentDataPlatformDeliveryDocumentAddressData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliveryDocumentDataPlatformDeliveryDocumentAddressData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_address_data`),
		qm.WhereIn(`data_platform_delivery_document_address_data.DeliveryDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_address_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentAddressDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_address_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_address_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_address_data")
	}

	if singular {
		object.R.DeliveryDocumentDataPlatformDeliveryDocumentAddressData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.DeliveryDocument {
				local.R.DeliveryDocumentDataPlatformDeliveryDocumentAddressData = append(local.R.DeliveryDocumentDataPlatformDeliveryDocumentAddressData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadDeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_header_doc_data`),
		qm.WhereIn(`data_platform_delivery_document_header_doc_data.DeliveryDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_header_doc_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentHeaderDocDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_header_doc_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_header_doc_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_header_doc_data")
	}

	if singular {
		object.R.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.DeliveryDocument {
				local.R.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData = append(local.R.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadDeliveryDocumentDataPlatformDeliveryDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliveryDocumentDataPlatformDeliveryDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_item_data`),
		qm.WhereIn(`data_platform_delivery_document_item_data.DeliveryDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_item_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_item_data")
	}

	if singular {
		object.R.DeliveryDocumentDataPlatformDeliveryDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.DeliveryDocument {
				local.R.DeliveryDocumentDataPlatformDeliveryDocumentItemData = append(local.R.DeliveryDocumentDataPlatformDeliveryDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadDeliveryDocumentDataPlatformDeliveryDocumentPartnerData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliveryDocumentDataPlatformDeliveryDocumentPartnerData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.DeliveryDocument)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryDocument {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryDocument)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_partner_data`),
		qm.WhereIn(`data_platform_delivery_document_partner_data.DeliveryDocument in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_partner_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentPartnerDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_partner_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_partner_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_partner_data")
	}

	if singular {
		object.R.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.DeliveryDocument == foreign.DeliveryDocument {
				local.R.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData = append(local.R.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData, foreign)
				break
			}
		}
	}

	return nil
}

// SetBillFromCountryDataPlatformCountryCountryDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillFromCountryDataPlatformCountryCountryDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillFromCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCountryCountryDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillFromCountry"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Country, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillFromCountry, related.Country)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillFromCountryDataPlatformCountryCountryDatum: related,
		}
	} else {
		o.R.BillFromCountryDataPlatformCountryCountryDatum = related
	}

	return nil
}

// RemoveBillFromCountryDataPlatformCountryCountryDatum relationship.
// Sets o.R.BillFromCountryDataPlatformCountryCountryDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillFromCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCountryCountryDatum) error {
	var err error

	queries.SetScanner(&o.BillFromCountry, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillFromCountry")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillFromCountryDataPlatformCountryCountryDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBillOfMaterialDataPlatformBillOfMaterialItemDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBillOfMaterialItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillOfMaterial, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillOfMaterial, related.BillOfMaterial)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillOfMaterialDataPlatformBillOfMaterialItemDatum: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = related
	}

	return nil
}

// RemoveBillOfMaterialDataPlatformBillOfMaterialItemDatum relationship.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBillOfMaterialItemDatum) error {
	var err error

	queries.SetScanner(&o.BillOfMaterial, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillOfMaterial")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBillToCountryDataPlatformCountryCountryDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillToCountryDataPlatformCountryCountryDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillToCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCountryCountryDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillToCountry"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Country, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillToCountry, related.Country)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillToCountryDataPlatformCountryCountryDatum: related,
		}
	} else {
		o.R.BillToCountryDataPlatformCountryCountryDatum = related
	}

	return nil
}

// RemoveBillToCountryDataPlatformCountryCountryDatum relationship.
// Sets o.R.BillToCountryDataPlatformCountryCountryDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillToCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCountryCountryDatum) error {
	var err error

	queries.SetScanner(&o.BillToCountry, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillToCountry")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillToCountryDataPlatformCountryCountryDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetContractDataPlatformContractItemDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.ContractDataPlatformContractItemDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetContractDataPlatformContractItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformContractItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Contract, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Contract, related.Contract)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			ContractDataPlatformContractItemDatum: related,
		}
	} else {
		o.R.ContractDataPlatformContractItemDatum = related
	}

	return nil
}

// RemoveContractDataPlatformContractItemDatum relationship.
// Sets o.R.ContractDataPlatformContractItemDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveContractDataPlatformContractItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformContractItemDatum) error {
	var err error

	queries.SetScanner(&o.Contract, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ContractDataPlatformContractItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetContractDataPlatformContractHeaderDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.ContractDataPlatformContractHeaderDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetContractDataPlatformContractHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformContractHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Contract, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Contract, related.Contract)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			ContractDataPlatformContractHeaderDatum: related,
		}
	} else {
		o.R.ContractDataPlatformContractHeaderDatum = related
	}

	return nil
}

// RemoveContractDataPlatformContractHeaderDatum relationship.
// Sets o.R.ContractDataPlatformContractHeaderDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveContractDataPlatformContractHeaderDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformContractHeaderDatum) error {
	var err error

	queries.SetScanner(&o.Contract, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ContractDataPlatformContractHeaderDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromPlantTimeZone"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromPlantTimeZone, related.TimeZone)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// RemoveDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum relationship.
// Sets o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromPlantTimeZone, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromPlantTimeZone")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToPlantTimeZone"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverToPlantTimeZone, related.TimeZone)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// RemoveDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum relationship.
// Sets o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error

	queries.SetScanner(&o.DeliverToPlantTimeZone, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverToPlantTimeZone")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"HeaderWeightUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.HeaderWeightUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// RemoveHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.HeaderWeightUnit, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("HeaderWeightUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetIncoterm of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.Incoterm to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetIncoterm(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Incoterms"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Incoterms, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Incoterms, related.Incoterms)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			Incoterm: related,
		}
	} else {
		o.R.Incoterm = related
	}

	return nil
}

// RemoveIncoterm relationship.
// Sets o.R.Incoterm to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveIncoterm(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error

	queries.SetScanner(&o.Incoterms, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Incoterms")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Incoterm = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetOrderIDDataPlatformOrdersItemDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOrdersItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OrderID, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrderID, related.OrderID)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			OrderIDDataPlatformOrdersItemDatum: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemDatum = related
	}

	return nil
}

// RemoveOrderIDDataPlatformOrdersItemDatum relationship.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformOrdersItemDatum) error {
	var err error

	queries.SetScanner(&o.OrderID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformOrdersItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetOperationIDDataPlatformProductionOrderItemOperationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.OperationIDDataPlatformProductionOrderItemOperationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetOperationIDDataPlatformProductionOrderItemOperationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemOperationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OperationID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OperationID, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OperationID, related.OperationID)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			OperationIDDataPlatformProductionOrderItemOperationDatum: related,
		}
	} else {
		o.R.OperationIDDataPlatformProductionOrderItemOperationDatum = related
	}

	return nil
}

// RemoveOperationIDDataPlatformProductionOrderItemOperationDatum relationship.
// Sets o.R.OperationIDDataPlatformProductionOrderItemOperationDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveOperationIDDataPlatformProductionOrderItemOperationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionOrderItemOperationDatum) error {
	var err error

	queries.SetScanner(&o.OperationID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("OperationID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OperationIDDataPlatformProductionOrderItemOperationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductionOrderDataPlatformProductionOrderItemDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionOrder, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductionOrder, related.ProductionOrder)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			ProductionOrderDataPlatformProductionOrderItemDatum: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = related
	}

	return nil
}

// RemoveProductionOrderDataPlatformProductionOrderItemDatum relationship.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionOrderItemDatum) error {
	var err error

	queries.SetScanner(&o.ProductionOrder, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBillFromPartyDataPlatformSCRBillingRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillFromPartyDataPlatformSCRBillingRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillFromPartyDataPlatformSCRBillingRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRBillingRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillFromParty, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillFromParty, related.BillFromParty)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillFromPartyDataPlatformSCRBillingRelationDatum: related,
		}
	} else {
		o.R.BillFromPartyDataPlatformSCRBillingRelationDatum = related
	}

	return nil
}

// RemoveBillFromPartyDataPlatformSCRBillingRelationDatum relationship.
// Sets o.R.BillFromPartyDataPlatformSCRBillingRelationDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillFromPartyDataPlatformSCRBillingRelationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformSCRBillingRelationDatum) error {
	var err error

	queries.SetScanner(&o.BillFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillFromPartyDataPlatformSCRBillingRelationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BuyerDataPlatformSCRDeliveryRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryRelationDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryPlantRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBuyerDataPlatformSCRDeliveryPlantRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryPlantRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BuyerDataPlatformSCRDeliveryPlantRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = related
	}

	return nil
}

// SetBillFromPartyDataPlatformSCRPaymentRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillFromPartyDataPlatformSCRPaymentRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRPaymentRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillFromParty, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillFromParty, related.BillFromParty)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillFromPartyDataPlatformSCRPaymentRelationDatum: related,
		}
	} else {
		o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = related
	}

	return nil
}

// RemoveBillFromPartyDataPlatformSCRPaymentRelationDatum relationship.
// Sets o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillFromPartyDataPlatformSCRPaymentRelationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformSCRPaymentRelationDatum) error {
	var err error

	queries.SetScanner(&o.BillFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetTransactionCurrencyDataPlatformCurrencyCurrencyDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCurrencyCurrencyDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"TransactionCurrency"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Currency, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TransactionCurrency, related.Currency)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			TransactionCurrencyDataPlatformCurrencyCurrencyDatum: related,
		}
	} else {
		o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = related
	}

	return nil
}

// RemoveTransactionCurrencyDataPlatformCurrencyCurrencyDatum relationship.
// Sets o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCurrencyCurrencyDatum) error {
	var err error

	queries.SetScanner(&o.TransactionCurrency, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("TransactionCurrency")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// AddDeliveryDocumentDataPlatformDeliveryDocumentAddressData adds the given related objects to the existing relationships
// of the data_platform_delivery_document_header_datum, optionally inserting them as new records.
// Appends related to o.R.DeliveryDocumentDataPlatformDeliveryDocumentAddressData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) AddDeliveryDocumentDataPlatformDeliveryDocumentAddressData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentAddressDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeliveryDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_address_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"DeliveryDocument"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentAddressDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.DeliveryDocument, rel.AddressID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeliveryDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliveryDocumentDataPlatformDeliveryDocumentAddressData: related,
		}
	} else {
		o.R.DeliveryDocumentDataPlatformDeliveryDocumentAddressData = append(o.R.DeliveryDocumentDataPlatformDeliveryDocumentAddressData, related...)
	}

	return nil
}

// AddDeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData adds the given related objects to the existing relationships
// of the data_platform_delivery_document_header_datum, optionally inserting them as new records.
// Appends related to o.R.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) AddDeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDocDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeliveryDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_header_doc_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"DeliveryDocument"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDocDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.DeliveryDocument, rel.DocType, rel.DocVersionID, rel.DocID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeliveryDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData: related,
		}
	} else {
		o.R.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData = append(o.R.DeliveryDocumentDataPlatformDeliveryDocumentHeaderDocData, related...)
	}

	return nil
}

// AddDeliveryDocumentDataPlatformDeliveryDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_delivery_document_header_datum, optionally inserting them as new records.
// Appends related to o.R.DeliveryDocumentDataPlatformDeliveryDocumentItemData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) AddDeliveryDocumentDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeliveryDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"DeliveryDocument"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeliveryDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliveryDocumentDataPlatformDeliveryDocumentItemData: related,
		}
	} else {
		o.R.DeliveryDocumentDataPlatformDeliveryDocumentItemData = append(o.R.DeliveryDocumentDataPlatformDeliveryDocumentItemData, related...)
	}

	return nil
}

// AddDeliveryDocumentDataPlatformDeliveryDocumentPartnerData adds the given related objects to the existing relationships
// of the data_platform_delivery_document_header_datum, optionally inserting them as new records.
// Appends related to o.R.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) AddDeliveryDocumentDataPlatformDeliveryDocumentPartnerData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentPartnerDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.DeliveryDocument = o.DeliveryDocument
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_partner_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"DeliveryDocument"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentPartnerDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.DeliveryDocument, rel.DeliveryDocument, rel.PartnerFunction, rel.BusinessPartner}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.DeliveryDocument = o.DeliveryDocument
		}
	}

	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliveryDocumentDataPlatformDeliveryDocumentPartnerData: related,
		}
	} else {
		o.R.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData = append(o.R.DeliveryDocumentDataPlatformDeliveryDocumentPartnerData, related...)
	}

	return nil
}

// DataPlatformDeliveryDocumentHeaderData retrieves all the records using an executor.
func DataPlatformDeliveryDocumentHeaderData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDatumQuery {
	mods = append(mods, qm.From("`data_platform_delivery_document_header_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_delivery_document_header_data`.*"})
	}

	return dataPlatformDeliveryDocumentHeaderDatumQuery{q}
}

// FindDataPlatformDeliveryDocumentHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformDeliveryDocumentHeaderDatum(ctx context.Context, exec boil.ContextExecutor, deliveryDocument int, selectCols ...string) (*DataPlatformDeliveryDocumentHeaderDatum, error) {
	dataPlatformDeliveryDocumentHeaderDatumObj := &DataPlatformDeliveryDocumentHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_delivery_document_header_data` where `DeliveryDocument`=?", sel,
	)

	q := queries.Raw(query, deliveryDocument)

	err := q.Bind(ctx, exec, dataPlatformDeliveryDocumentHeaderDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_delivery_document_header_data")
	}

	return dataPlatformDeliveryDocumentHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_delivery_document_header_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumInsertCache[key]
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_delivery_document_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_delivery_document_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_delivery_document_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_delivery_document_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.DeliveryDocument,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_delivery_document_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumInsertCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformDeliveryDocumentHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumUpdateCache[key]
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_delivery_document_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, append(wl, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_delivery_document_header_data row")
	}

	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumUpdateCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_delivery_document_header_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformDeliveryDocumentHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformDeliveryDocumentHeaderDatum slice")
	}

	return nil
}

var mySQLDataPlatformDeliveryDocumentHeaderDatumUniqueColumns = []string{
	"DeliveryDocument",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_delivery_document_header_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformDeliveryDocumentHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumUpsertCache[key]
	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_delivery_document_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_delivery_document_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_delivery_document_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_delivery_document_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_delivery_document_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_delivery_document_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumUpsertCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformDeliveryDocumentHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformDeliveryDocumentHeaderDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_delivery_document_header_data` WHERE `DeliveryDocument`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_delivery_document_header_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformDeliveryDocumentHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_delivery_document_header_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformDeliveryDocumentHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_delivery_document_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformDeliveryDocumentHeaderDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformDeliveryDocumentHeaderDatum(ctx, exec, o.DeliveryDocument)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformDeliveryDocumentHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformDeliveryDocumentHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_delivery_document_header_data`.* FROM `data_platform_delivery_document_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformDeliveryDocumentHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformDeliveryDocumentHeaderDatumExists checks if the DataPlatformDeliveryDocumentHeaderDatum row exists.
func DataPlatformDeliveryDocumentHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, deliveryDocument int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_delivery_document_header_data` where `DeliveryDocument`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, deliveryDocument)
	}
	row := exec.QueryRowContext(ctx, sql, deliveryDocument)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_delivery_document_header_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformDeliveryDocumentHeaderDatum row exists.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformDeliveryDocumentHeaderDatumExists(ctx, exec, o.DeliveryDocument)
}
