// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformDeliveryDocumentHeaderDatum is an object representing the database table.
type DataPlatformDeliveryDocumentHeaderDatum struct {
	DeliveryDocument                       int          `boil:"DeliveryDocument" json:"DeliveryDocument" toml:"DeliveryDocument" yaml:"DeliveryDocument"`
	SupplyChainRelationshipID              int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipDeliveryID      int          `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID"`
	SupplyChainRelationshipDeliveryPlantID int          `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID"`
	SupplyChainRelationshipBillingID       null.Int     `boil:"SupplyChainRelationshipBillingID" json:"SupplyChainRelationshipBillingID,omitempty" toml:"SupplyChainRelationshipBillingID" yaml:"SupplyChainRelationshipBillingID,omitempty"`
	SupplyChainRelationshipPaymentID       null.Int     `boil:"SupplyChainRelationshipPaymentID" json:"SupplyChainRelationshipPaymentID,omitempty" toml:"SupplyChainRelationshipPaymentID" yaml:"SupplyChainRelationshipPaymentID,omitempty"`
	Buyer                                  int          `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Seller                                 int          `boil:"Seller" json:"Seller" toml:"Seller" yaml:"Seller"`
	DeliverToParty                         int          `boil:"DeliverToParty" json:"DeliverToParty" toml:"DeliverToParty" yaml:"DeliverToParty"`
	DeliverFromParty                       int          `boil:"DeliverFromParty" json:"DeliverFromParty" toml:"DeliverFromParty" yaml:"DeliverFromParty"`
	DeliverToPlant                         string       `boil:"DeliverToPlant" json:"DeliverToPlant" toml:"DeliverToPlant" yaml:"DeliverToPlant"`
	DeliverFromPlant                       string       `boil:"DeliverFromPlant" json:"DeliverFromPlant" toml:"DeliverFromPlant" yaml:"DeliverFromPlant"`
	BillToParty                            null.Int     `boil:"BillToParty" json:"BillToParty,omitempty" toml:"BillToParty" yaml:"BillToParty,omitempty"`
	BillFromParty                          null.Int     `boil:"BillFromParty" json:"BillFromParty,omitempty" toml:"BillFromParty" yaml:"BillFromParty,omitempty"`
	BillToCountry                          null.String  `boil:"BillToCountry" json:"BillToCountry,omitempty" toml:"BillToCountry" yaml:"BillToCountry,omitempty"`
	BillFromCountry                        null.String  `boil:"BillFromCountry" json:"BillFromCountry,omitempty" toml:"BillFromCountry" yaml:"BillFromCountry,omitempty"`
	Payer                                  null.Int     `boil:"Payer" json:"Payer,omitempty" toml:"Payer" yaml:"Payer,omitempty"`
	Payee                                  null.Int     `boil:"Payee" json:"Payee,omitempty" toml:"Payee" yaml:"Payee,omitempty"`
	IsExportImport                         null.Bool    `boil:"IsExportImport" json:"IsExportImport,omitempty" toml:"IsExportImport" yaml:"IsExportImport,omitempty"`
	DeliverToPlantTimeZone                 null.String  `boil:"DeliverToPlantTimeZone" json:"DeliverToPlantTimeZone,omitempty" toml:"DeliverToPlantTimeZone" yaml:"DeliverToPlantTimeZone,omitempty"`
	DeliverFromPlantTimeZone               null.String  `boil:"DeliverFromPlantTimeZone" json:"DeliverFromPlantTimeZone,omitempty" toml:"DeliverFromPlantTimeZone" yaml:"DeliverFromPlantTimeZone,omitempty"`
	ReferenceDocument                      null.Int     `boil:"ReferenceDocument" json:"ReferenceDocument,omitempty" toml:"ReferenceDocument" yaml:"ReferenceDocument,omitempty"`
	ReferenceDocumentItem                  null.Int     `boil:"ReferenceDocumentItem" json:"ReferenceDocumentItem,omitempty" toml:"ReferenceDocumentItem" yaml:"ReferenceDocumentItem,omitempty"`
	OrderID                                null.Int     `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	OrderItem                              null.Int     `boil:"OrderItem" json:"OrderItem,omitempty" toml:"OrderItem" yaml:"OrderItem,omitempty"`
	ProductionOrder                        null.Int     `boil:"ProductionOrder" json:"ProductionOrder,omitempty" toml:"ProductionOrder" yaml:"ProductionOrder,omitempty"`
	ProductionOrderItem                    null.Int     `boil:"ProductionOrderItem" json:"ProductionOrderItem,omitempty" toml:"ProductionOrderItem" yaml:"ProductionOrderItem,omitempty"`
	Operations                             null.Int     `boil:"Operations" json:"Operations,omitempty" toml:"Operations" yaml:"Operations,omitempty"`
	OperationsItem                         null.Int     `boil:"OperationsItem" json:"OperationsItem,omitempty" toml:"OperationsItem" yaml:"OperationsItem,omitempty"`
	BillOfMaterial                         null.Int     `boil:"BillOfMaterial" json:"BillOfMaterial,omitempty" toml:"BillOfMaterial" yaml:"BillOfMaterial,omitempty"`
	BillOfMaterialItem                     null.Int     `boil:"BillOfMaterialItem" json:"BillOfMaterialItem,omitempty" toml:"BillOfMaterialItem" yaml:"BillOfMaterialItem,omitempty"`
	ContractType                           null.String  `boil:"ContractType" json:"ContractType,omitempty" toml:"ContractType" yaml:"ContractType,omitempty"`
	OrderValidityStartDate                 null.String  `boil:"OrderValidityStartDate" json:"OrderValidityStartDate,omitempty" toml:"OrderValidityStartDate" yaml:"OrderValidityStartDate,omitempty"`
	OrderValidityEndDate                   null.String  `boil:"OrderValidityEndDate" json:"OrderValidityEndDate,omitempty" toml:"OrderValidityEndDate" yaml:"OrderValidityEndDate,omitempty"`
	DeliveryDocumentDate                   string       `boil:"DeliveryDocumentDate" json:"DeliveryDocumentDate" toml:"DeliveryDocumentDate" yaml:"DeliveryDocumentDate"`
	PlannedGoodsIssueDate                  string       `boil:"PlannedGoodsIssueDate" json:"PlannedGoodsIssueDate" toml:"PlannedGoodsIssueDate" yaml:"PlannedGoodsIssueDate"`
	PlannedGoodsIssueTime                  string       `boil:"PlannedGoodsIssueTime" json:"PlannedGoodsIssueTime" toml:"PlannedGoodsIssueTime" yaml:"PlannedGoodsIssueTime"`
	PlannedGoodsReceiptDate                string       `boil:"PlannedGoodsReceiptDate" json:"PlannedGoodsReceiptDate" toml:"PlannedGoodsReceiptDate" yaml:"PlannedGoodsReceiptDate"`
	PlannedGoodsReceiptTime                string       `boil:"PlannedGoodsReceiptTime" json:"PlannedGoodsReceiptTime" toml:"PlannedGoodsReceiptTime" yaml:"PlannedGoodsReceiptTime"`
	InvoiceDocumentDate                    null.String  `boil:"InvoiceDocumentDate" json:"InvoiceDocumentDate,omitempty" toml:"InvoiceDocumentDate" yaml:"InvoiceDocumentDate,omitempty"`
	HeaderCompleteDeliveryIsDefined        null.Bool    `boil:"HeaderCompleteDeliveryIsDefined" json:"HeaderCompleteDeliveryIsDefined,omitempty" toml:"HeaderCompleteDeliveryIsDefined" yaml:"HeaderCompleteDeliveryIsDefined,omitempty"`
	HeaderDeliveryStatus                   null.String  `boil:"HeaderDeliveryStatus" json:"HeaderDeliveryStatus,omitempty" toml:"HeaderDeliveryStatus" yaml:"HeaderDeliveryStatus,omitempty"`
	GoodsIssueOrReceiptSlipNumber          null.String  `boil:"GoodsIssueOrReceiptSlipNumber" json:"GoodsIssueOrReceiptSlipNumber,omitempty" toml:"GoodsIssueOrReceiptSlipNumber" yaml:"GoodsIssueOrReceiptSlipNumber,omitempty"`
	HeaderBillingStatus                    null.String  `boil:"HeaderBillingStatus" json:"HeaderBillingStatus,omitempty" toml:"HeaderBillingStatus" yaml:"HeaderBillingStatus,omitempty"`
	HeaderBillingConfStatus                null.String  `boil:"HeaderBillingConfStatus" json:"HeaderBillingConfStatus,omitempty" toml:"HeaderBillingConfStatus" yaml:"HeaderBillingConfStatus,omitempty"`
	HeaderBillingBlockStatus               null.Bool    `boil:"HeaderBillingBlockStatus" json:"HeaderBillingBlockStatus,omitempty" toml:"HeaderBillingBlockStatus" yaml:"HeaderBillingBlockStatus,omitempty"`
	HeaderGrossWeight                      null.Float32 `boil:"HeaderGrossWeight" json:"HeaderGrossWeight,omitempty" toml:"HeaderGrossWeight" yaml:"HeaderGrossWeight,omitempty"`
	HeaderNetWeight                        null.Float32 `boil:"HeaderNetWeight" json:"HeaderNetWeight,omitempty" toml:"HeaderNetWeight" yaml:"HeaderNetWeight,omitempty"`
	HeaderWeightUnit                       null.String  `boil:"HeaderWeightUnit" json:"HeaderWeightUnit,omitempty" toml:"HeaderWeightUnit" yaml:"HeaderWeightUnit,omitempty"`
	Incoterms                              null.String  `boil:"Incoterms" json:"Incoterms,omitempty" toml:"Incoterms" yaml:"Incoterms,omitempty"`
	TransactionCurrency                    null.String  `boil:"TransactionCurrency" json:"TransactionCurrency,omitempty" toml:"TransactionCurrency" yaml:"TransactionCurrency,omitempty"`
	HeaderDeliveryBlockStatus              null.Bool    `boil:"HeaderDeliveryBlockStatus" json:"HeaderDeliveryBlockStatus,omitempty" toml:"HeaderDeliveryBlockStatus" yaml:"HeaderDeliveryBlockStatus,omitempty"`
	HeaderIssuingBlockStatus               null.Bool    `boil:"HeaderIssuingBlockStatus" json:"HeaderIssuingBlockStatus,omitempty" toml:"HeaderIssuingBlockStatus" yaml:"HeaderIssuingBlockStatus,omitempty"`
	HeaderReceivingBlockStatus             null.Bool    `boil:"HeaderReceivingBlockStatus" json:"HeaderReceivingBlockStatus,omitempty" toml:"HeaderReceivingBlockStatus" yaml:"HeaderReceivingBlockStatus,omitempty"`
	CreationDate                           string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                           string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                         string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                         string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsCancelled                            null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                    null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformDeliveryDocumentHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformDeliveryDocumentHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformDeliveryDocumentHeaderDatumColumns = struct {
	DeliveryDocument                       string
	SupplyChainRelationshipID              string
	SupplyChainRelationshipDeliveryID      string
	SupplyChainRelationshipDeliveryPlantID string
	SupplyChainRelationshipBillingID       string
	SupplyChainRelationshipPaymentID       string
	Buyer                                  string
	Seller                                 string
	DeliverToParty                         string
	DeliverFromParty                       string
	DeliverToPlant                         string
	DeliverFromPlant                       string
	BillToParty                            string
	BillFromParty                          string
	BillToCountry                          string
	BillFromCountry                        string
	Payer                                  string
	Payee                                  string
	IsExportImport                         string
	DeliverToPlantTimeZone                 string
	DeliverFromPlantTimeZone               string
	ReferenceDocument                      string
	ReferenceDocumentItem                  string
	OrderID                                string
	OrderItem                              string
	ProductionOrder                        string
	ProductionOrderItem                    string
	Operations                             string
	OperationsItem                         string
	BillOfMaterial                         string
	BillOfMaterialItem                     string
	ContractType                           string
	OrderValidityStartDate                 string
	OrderValidityEndDate                   string
	DeliveryDocumentDate                   string
	PlannedGoodsIssueDate                  string
	PlannedGoodsIssueTime                  string
	PlannedGoodsReceiptDate                string
	PlannedGoodsReceiptTime                string
	InvoiceDocumentDate                    string
	HeaderCompleteDeliveryIsDefined        string
	HeaderDeliveryStatus                   string
	GoodsIssueOrReceiptSlipNumber          string
	HeaderBillingStatus                    string
	HeaderBillingConfStatus                string
	HeaderBillingBlockStatus               string
	HeaderGrossWeight                      string
	HeaderNetWeight                        string
	HeaderWeightUnit                       string
	Incoterms                              string
	TransactionCurrency                    string
	HeaderDeliveryBlockStatus              string
	HeaderIssuingBlockStatus               string
	HeaderReceivingBlockStatus             string
	CreationDate                           string
	CreationTime                           string
	LastChangeDate                         string
	LastChangeTime                         string
	IsCancelled                            string
	IsMarkedForDeletion                    string
}{
	DeliveryDocument:                       "DeliveryDocument",
	SupplyChainRelationshipID:              "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:      "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID: "SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipBillingID:       "SupplyChainRelationshipBillingID",
	SupplyChainRelationshipPaymentID:       "SupplyChainRelationshipPaymentID",
	Buyer:                                  "Buyer",
	Seller:                                 "Seller",
	DeliverToParty:                         "DeliverToParty",
	DeliverFromParty:                       "DeliverFromParty",
	DeliverToPlant:                         "DeliverToPlant",
	DeliverFromPlant:                       "DeliverFromPlant",
	BillToParty:                            "BillToParty",
	BillFromParty:                          "BillFromParty",
	BillToCountry:                          "BillToCountry",
	BillFromCountry:                        "BillFromCountry",
	Payer:                                  "Payer",
	Payee:                                  "Payee",
	IsExportImport:                         "IsExportImport",
	DeliverToPlantTimeZone:                 "DeliverToPlantTimeZone",
	DeliverFromPlantTimeZone:               "DeliverFromPlantTimeZone",
	ReferenceDocument:                      "ReferenceDocument",
	ReferenceDocumentItem:                  "ReferenceDocumentItem",
	OrderID:                                "OrderID",
	OrderItem:                              "OrderItem",
	ProductionOrder:                        "ProductionOrder",
	ProductionOrderItem:                    "ProductionOrderItem",
	Operations:                             "Operations",
	OperationsItem:                         "OperationsItem",
	BillOfMaterial:                         "BillOfMaterial",
	BillOfMaterialItem:                     "BillOfMaterialItem",
	ContractType:                           "ContractType",
	OrderValidityStartDate:                 "OrderValidityStartDate",
	OrderValidityEndDate:                   "OrderValidityEndDate",
	DeliveryDocumentDate:                   "DeliveryDocumentDate",
	PlannedGoodsIssueDate:                  "PlannedGoodsIssueDate",
	PlannedGoodsIssueTime:                  "PlannedGoodsIssueTime",
	PlannedGoodsReceiptDate:                "PlannedGoodsReceiptDate",
	PlannedGoodsReceiptTime:                "PlannedGoodsReceiptTime",
	InvoiceDocumentDate:                    "InvoiceDocumentDate",
	HeaderCompleteDeliveryIsDefined:        "HeaderCompleteDeliveryIsDefined",
	HeaderDeliveryStatus:                   "HeaderDeliveryStatus",
	GoodsIssueOrReceiptSlipNumber:          "GoodsIssueOrReceiptSlipNumber",
	HeaderBillingStatus:                    "HeaderBillingStatus",
	HeaderBillingConfStatus:                "HeaderBillingConfStatus",
	HeaderBillingBlockStatus:               "HeaderBillingBlockStatus",
	HeaderGrossWeight:                      "HeaderGrossWeight",
	HeaderNetWeight:                        "HeaderNetWeight",
	HeaderWeightUnit:                       "HeaderWeightUnit",
	Incoterms:                              "Incoterms",
	TransactionCurrency:                    "TransactionCurrency",
	HeaderDeliveryBlockStatus:              "HeaderDeliveryBlockStatus",
	HeaderIssuingBlockStatus:               "HeaderIssuingBlockStatus",
	HeaderReceivingBlockStatus:             "HeaderReceivingBlockStatus",
	CreationDate:                           "CreationDate",
	CreationTime:                           "CreationTime",
	LastChangeDate:                         "LastChangeDate",
	LastChangeTime:                         "LastChangeTime",
	IsCancelled:                            "IsCancelled",
	IsMarkedForDeletion:                    "IsMarkedForDeletion",
}

var DataPlatformDeliveryDocumentHeaderDatumTableColumns = struct {
	DeliveryDocument                       string
	SupplyChainRelationshipID              string
	SupplyChainRelationshipDeliveryID      string
	SupplyChainRelationshipDeliveryPlantID string
	SupplyChainRelationshipBillingID       string
	SupplyChainRelationshipPaymentID       string
	Buyer                                  string
	Seller                                 string
	DeliverToParty                         string
	DeliverFromParty                       string
	DeliverToPlant                         string
	DeliverFromPlant                       string
	BillToParty                            string
	BillFromParty                          string
	BillToCountry                          string
	BillFromCountry                        string
	Payer                                  string
	Payee                                  string
	IsExportImport                         string
	DeliverToPlantTimeZone                 string
	DeliverFromPlantTimeZone               string
	ReferenceDocument                      string
	ReferenceDocumentItem                  string
	OrderID                                string
	OrderItem                              string
	ProductionOrder                        string
	ProductionOrderItem                    string
	Operations                             string
	OperationsItem                         string
	BillOfMaterial                         string
	BillOfMaterialItem                     string
	ContractType                           string
	OrderValidityStartDate                 string
	OrderValidityEndDate                   string
	DeliveryDocumentDate                   string
	PlannedGoodsIssueDate                  string
	PlannedGoodsIssueTime                  string
	PlannedGoodsReceiptDate                string
	PlannedGoodsReceiptTime                string
	InvoiceDocumentDate                    string
	HeaderCompleteDeliveryIsDefined        string
	HeaderDeliveryStatus                   string
	GoodsIssueOrReceiptSlipNumber          string
	HeaderBillingStatus                    string
	HeaderBillingConfStatus                string
	HeaderBillingBlockStatus               string
	HeaderGrossWeight                      string
	HeaderNetWeight                        string
	HeaderWeightUnit                       string
	Incoterms                              string
	TransactionCurrency                    string
	HeaderDeliveryBlockStatus              string
	HeaderIssuingBlockStatus               string
	HeaderReceivingBlockStatus             string
	CreationDate                           string
	CreationTime                           string
	LastChangeDate                         string
	LastChangeTime                         string
	IsCancelled                            string
	IsMarkedForDeletion                    string
}{
	DeliveryDocument:                       "data_platform_delivery_document_header_data.DeliveryDocument",
	SupplyChainRelationshipID:              "data_platform_delivery_document_header_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:      "data_platform_delivery_document_header_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID: "data_platform_delivery_document_header_data.SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipBillingID:       "data_platform_delivery_document_header_data.SupplyChainRelationshipBillingID",
	SupplyChainRelationshipPaymentID:       "data_platform_delivery_document_header_data.SupplyChainRelationshipPaymentID",
	Buyer:                                  "data_platform_delivery_document_header_data.Buyer",
	Seller:                                 "data_platform_delivery_document_header_data.Seller",
	DeliverToParty:                         "data_platform_delivery_document_header_data.DeliverToParty",
	DeliverFromParty:                       "data_platform_delivery_document_header_data.DeliverFromParty",
	DeliverToPlant:                         "data_platform_delivery_document_header_data.DeliverToPlant",
	DeliverFromPlant:                       "data_platform_delivery_document_header_data.DeliverFromPlant",
	BillToParty:                            "data_platform_delivery_document_header_data.BillToParty",
	BillFromParty:                          "data_platform_delivery_document_header_data.BillFromParty",
	BillToCountry:                          "data_platform_delivery_document_header_data.BillToCountry",
	BillFromCountry:                        "data_platform_delivery_document_header_data.BillFromCountry",
	Payer:                                  "data_platform_delivery_document_header_data.Payer",
	Payee:                                  "data_platform_delivery_document_header_data.Payee",
	IsExportImport:                         "data_platform_delivery_document_header_data.IsExportImport",
	DeliverToPlantTimeZone:                 "data_platform_delivery_document_header_data.DeliverToPlantTimeZone",
	DeliverFromPlantTimeZone:               "data_platform_delivery_document_header_data.DeliverFromPlantTimeZone",
	ReferenceDocument:                      "data_platform_delivery_document_header_data.ReferenceDocument",
	ReferenceDocumentItem:                  "data_platform_delivery_document_header_data.ReferenceDocumentItem",
	OrderID:                                "data_platform_delivery_document_header_data.OrderID",
	OrderItem:                              "data_platform_delivery_document_header_data.OrderItem",
	ProductionOrder:                        "data_platform_delivery_document_header_data.ProductionOrder",
	ProductionOrderItem:                    "data_platform_delivery_document_header_data.ProductionOrderItem",
	Operations:                             "data_platform_delivery_document_header_data.Operations",
	OperationsItem:                         "data_platform_delivery_document_header_data.OperationsItem",
	BillOfMaterial:                         "data_platform_delivery_document_header_data.BillOfMaterial",
	BillOfMaterialItem:                     "data_platform_delivery_document_header_data.BillOfMaterialItem",
	ContractType:                           "data_platform_delivery_document_header_data.ContractType",
	OrderValidityStartDate:                 "data_platform_delivery_document_header_data.OrderValidityStartDate",
	OrderValidityEndDate:                   "data_platform_delivery_document_header_data.OrderValidityEndDate",
	DeliveryDocumentDate:                   "data_platform_delivery_document_header_data.DeliveryDocumentDate",
	PlannedGoodsIssueDate:                  "data_platform_delivery_document_header_data.PlannedGoodsIssueDate",
	PlannedGoodsIssueTime:                  "data_platform_delivery_document_header_data.PlannedGoodsIssueTime",
	PlannedGoodsReceiptDate:                "data_platform_delivery_document_header_data.PlannedGoodsReceiptDate",
	PlannedGoodsReceiptTime:                "data_platform_delivery_document_header_data.PlannedGoodsReceiptTime",
	InvoiceDocumentDate:                    "data_platform_delivery_document_header_data.InvoiceDocumentDate",
	HeaderCompleteDeliveryIsDefined:        "data_platform_delivery_document_header_data.HeaderCompleteDeliveryIsDefined",
	HeaderDeliveryStatus:                   "data_platform_delivery_document_header_data.HeaderDeliveryStatus",
	GoodsIssueOrReceiptSlipNumber:          "data_platform_delivery_document_header_data.GoodsIssueOrReceiptSlipNumber",
	HeaderBillingStatus:                    "data_platform_delivery_document_header_data.HeaderBillingStatus",
	HeaderBillingConfStatus:                "data_platform_delivery_document_header_data.HeaderBillingConfStatus",
	HeaderBillingBlockStatus:               "data_platform_delivery_document_header_data.HeaderBillingBlockStatus",
	HeaderGrossWeight:                      "data_platform_delivery_document_header_data.HeaderGrossWeight",
	HeaderNetWeight:                        "data_platform_delivery_document_header_data.HeaderNetWeight",
	HeaderWeightUnit:                       "data_platform_delivery_document_header_data.HeaderWeightUnit",
	Incoterms:                              "data_platform_delivery_document_header_data.Incoterms",
	TransactionCurrency:                    "data_platform_delivery_document_header_data.TransactionCurrency",
	HeaderDeliveryBlockStatus:              "data_platform_delivery_document_header_data.HeaderDeliveryBlockStatus",
	HeaderIssuingBlockStatus:               "data_platform_delivery_document_header_data.HeaderIssuingBlockStatus",
	HeaderReceivingBlockStatus:             "data_platform_delivery_document_header_data.HeaderReceivingBlockStatus",
	CreationDate:                           "data_platform_delivery_document_header_data.CreationDate",
	CreationTime:                           "data_platform_delivery_document_header_data.CreationTime",
	LastChangeDate:                         "data_platform_delivery_document_header_data.LastChangeDate",
	LastChangeTime:                         "data_platform_delivery_document_header_data.LastChangeTime",
	IsCancelled:                            "data_platform_delivery_document_header_data.IsCancelled",
	IsMarkedForDeletion:                    "data_platform_delivery_document_header_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformDeliveryDocumentHeaderDatumWhere = struct {
	DeliveryDocument                       whereHelperint
	SupplyChainRelationshipID              whereHelperint
	SupplyChainRelationshipDeliveryID      whereHelperint
	SupplyChainRelationshipDeliveryPlantID whereHelperint
	SupplyChainRelationshipBillingID       whereHelpernull_Int
	SupplyChainRelationshipPaymentID       whereHelpernull_Int
	Buyer                                  whereHelperint
	Seller                                 whereHelperint
	DeliverToParty                         whereHelperint
	DeliverFromParty                       whereHelperint
	DeliverToPlant                         whereHelperstring
	DeliverFromPlant                       whereHelperstring
	BillToParty                            whereHelpernull_Int
	BillFromParty                          whereHelpernull_Int
	BillToCountry                          whereHelpernull_String
	BillFromCountry                        whereHelpernull_String
	Payer                                  whereHelpernull_Int
	Payee                                  whereHelpernull_Int
	IsExportImport                         whereHelpernull_Bool
	DeliverToPlantTimeZone                 whereHelpernull_String
	DeliverFromPlantTimeZone               whereHelpernull_String
	ReferenceDocument                      whereHelpernull_Int
	ReferenceDocumentItem                  whereHelpernull_Int
	OrderID                                whereHelpernull_Int
	OrderItem                              whereHelpernull_Int
	ProductionOrder                        whereHelpernull_Int
	ProductionOrderItem                    whereHelpernull_Int
	Operations                             whereHelpernull_Int
	OperationsItem                         whereHelpernull_Int
	BillOfMaterial                         whereHelpernull_Int
	BillOfMaterialItem                     whereHelpernull_Int
	ContractType                           whereHelpernull_String
	OrderValidityStartDate                 whereHelpernull_String
	OrderValidityEndDate                   whereHelpernull_String
	DeliveryDocumentDate                   whereHelperstring
	PlannedGoodsIssueDate                  whereHelperstring
	PlannedGoodsIssueTime                  whereHelperstring
	PlannedGoodsReceiptDate                whereHelperstring
	PlannedGoodsReceiptTime                whereHelperstring
	InvoiceDocumentDate                    whereHelpernull_String
	HeaderCompleteDeliveryIsDefined        whereHelpernull_Bool
	HeaderDeliveryStatus                   whereHelpernull_String
	GoodsIssueOrReceiptSlipNumber          whereHelpernull_String
	HeaderBillingStatus                    whereHelpernull_String
	HeaderBillingConfStatus                whereHelpernull_String
	HeaderBillingBlockStatus               whereHelpernull_Bool
	HeaderGrossWeight                      whereHelpernull_Float32
	HeaderNetWeight                        whereHelpernull_Float32
	HeaderWeightUnit                       whereHelpernull_String
	Incoterms                              whereHelpernull_String
	TransactionCurrency                    whereHelpernull_String
	HeaderDeliveryBlockStatus              whereHelpernull_Bool
	HeaderIssuingBlockStatus               whereHelpernull_Bool
	HeaderReceivingBlockStatus             whereHelpernull_Bool
	CreationDate                           whereHelperstring
	CreationTime                           whereHelperstring
	LastChangeDate                         whereHelperstring
	LastChangeTime                         whereHelperstring
	IsCancelled                            whereHelpernull_Bool
	IsMarkedForDeletion                    whereHelpernull_Bool
}{
	DeliveryDocument:                       whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliveryDocument`"},
	SupplyChainRelationshipID:              whereHelperint{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:      whereHelperint{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID: whereHelperint{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	SupplyChainRelationshipBillingID:       whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipBillingID`"},
	SupplyChainRelationshipPaymentID:       whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`SupplyChainRelationshipPaymentID`"},
	Buyer:                                  whereHelperint{field: "`data_platform_delivery_document_header_data`.`Buyer`"},
	Seller:                                 whereHelperint{field: "`data_platform_delivery_document_header_data`.`Seller`"},
	DeliverToParty:                         whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliverToParty`"},
	DeliverFromParty:                       whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliverFromParty`"},
	DeliverToPlant:                         whereHelperstring{field: "`data_platform_delivery_document_header_data`.`DeliverToPlant`"},
	DeliverFromPlant:                       whereHelperstring{field: "`data_platform_delivery_document_header_data`.`DeliverFromPlant`"},
	BillToParty:                            whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillToParty`"},
	BillFromParty:                          whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillFromParty`"},
	BillToCountry:                          whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`BillToCountry`"},
	BillFromCountry:                        whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`BillFromCountry`"},
	Payer:                                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Payer`"},
	Payee:                                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Payee`"},
	IsExportImport:                         whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsExportImport`"},
	DeliverToPlantTimeZone:                 whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`DeliverToPlantTimeZone`"},
	DeliverFromPlantTimeZone:               whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`DeliverFromPlantTimeZone`"},
	ReferenceDocument:                      whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReferenceDocument`"},
	ReferenceDocumentItem:                  whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReferenceDocumentItem`"},
	OrderID:                                whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OrderID`"},
	OrderItem:                              whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OrderItem`"},
	ProductionOrder:                        whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ProductionOrder`"},
	ProductionOrderItem:                    whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ProductionOrderItem`"},
	Operations:                             whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Operations`"},
	OperationsItem:                         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OperationsItem`"},
	BillOfMaterial:                         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillOfMaterial`"},
	BillOfMaterialItem:                     whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`BillOfMaterialItem`"},
	ContractType:                           whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`ContractType`"},
	OrderValidityStartDate:                 whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`OrderValidityStartDate`"},
	OrderValidityEndDate:                   whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`OrderValidityEndDate`"},
	DeliveryDocumentDate:                   whereHelperstring{field: "`data_platform_delivery_document_header_data`.`DeliveryDocumentDate`"},
	PlannedGoodsIssueDate:                  whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsIssueDate`"},
	PlannedGoodsIssueTime:                  whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsIssueTime`"},
	PlannedGoodsReceiptDate:                whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsReceiptDate`"},
	PlannedGoodsReceiptTime:                whereHelperstring{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsReceiptTime`"},
	InvoiceDocumentDate:                    whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`InvoiceDocumentDate`"},
	HeaderCompleteDeliveryIsDefined:        whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderCompleteDeliveryIsDefined`"},
	HeaderDeliveryStatus:                   whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderDeliveryStatus`"},
	GoodsIssueOrReceiptSlipNumber:          whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`GoodsIssueOrReceiptSlipNumber`"},
	HeaderBillingStatus:                    whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderBillingStatus`"},
	HeaderBillingConfStatus:                whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderBillingConfStatus`"},
	HeaderBillingBlockStatus:               whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderBillingBlockStatus`"},
	HeaderGrossWeight:                      whereHelpernull_Float32{field: "`data_platform_delivery_document_header_data`.`HeaderGrossWeight`"},
	HeaderNetWeight:                        whereHelpernull_Float32{field: "`data_platform_delivery_document_header_data`.`HeaderNetWeight`"},
	HeaderWeightUnit:                       whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderWeightUnit`"},
	Incoterms:                              whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`Incoterms`"},
	TransactionCurrency:                    whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`TransactionCurrency`"},
	HeaderDeliveryBlockStatus:              whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderDeliveryBlockStatus`"},
	HeaderIssuingBlockStatus:               whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderIssuingBlockStatus`"},
	HeaderReceivingBlockStatus:             whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderReceivingBlockStatus`"},
	CreationDate:                           whereHelperstring{field: "`data_platform_delivery_document_header_data`.`CreationDate`"},
	CreationTime:                           whereHelperstring{field: "`data_platform_delivery_document_header_data`.`CreationTime`"},
	LastChangeDate:                         whereHelperstring{field: "`data_platform_delivery_document_header_data`.`LastChangeDate`"},
	LastChangeTime:                         whereHelperstring{field: "`data_platform_delivery_document_header_data`.`LastChangeTime`"},
	IsCancelled:                            whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsCancelled`"},
	IsMarkedForDeletion:                    whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsMarkedForDeletion`"},
}

// DataPlatformDeliveryDocumentHeaderDatumRels is where relationship names are stored.
var DataPlatformDeliveryDocumentHeaderDatumRels = struct {
	BillFromCountryDataPlatformCountryCountryDatum            string
	BillToCountryDataPlatformCountryCountryDatum              string
	DeliverToPlantDataPlatformTimeZoneTimeZoneDatum           string
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum string
	Incoterm                                                  string
	OrderIDDataPlatformOrdersItemDatum                        string
	ProductionOrderDataPlatformProductionOrderItemDatum       string
	BillFromPartyDataPlatformSCRBillingRelationDatum          string
	BuyerDataPlatformSCRDeliveryRelationDatum                 string
	BuyerDataPlatformSCRDeliveryPlantRelationDatum            string
	BillFromPartyDataPlatformSCRPaymentRelationDatum          string
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum      string
}{
	BillFromCountryDataPlatformCountryCountryDatum:            "BillFromCountryDataPlatformCountryCountryDatum",
	BillToCountryDataPlatformCountryCountryDatum:              "BillToCountryDataPlatformCountryCountryDatum",
	DeliverToPlantDataPlatformTimeZoneTimeZoneDatum:           "DeliverToPlantDataPlatformTimeZoneTimeZoneDatum",
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: "HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum",
	Incoterm:                           "Incoterm",
	OrderIDDataPlatformOrdersItemDatum: "OrderIDDataPlatformOrdersItemDatum",
	ProductionOrderDataPlatformProductionOrderItemDatum:  "ProductionOrderDataPlatformProductionOrderItemDatum",
	BillFromPartyDataPlatformSCRBillingRelationDatum:     "BillFromPartyDataPlatformSCRBillingRelationDatum",
	BuyerDataPlatformSCRDeliveryRelationDatum:            "BuyerDataPlatformSCRDeliveryRelationDatum",
	BuyerDataPlatformSCRDeliveryPlantRelationDatum:       "BuyerDataPlatformSCRDeliveryPlantRelationDatum",
	BillFromPartyDataPlatformSCRPaymentRelationDatum:     "BillFromPartyDataPlatformSCRPaymentRelationDatum",
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum: "TransactionCurrencyDataPlatformCurrencyCurrencyDatum",
}

// dataPlatformDeliveryDocumentHeaderDatumR is where relationships are stored.
type dataPlatformDeliveryDocumentHeaderDatumR struct {
	BillFromCountryDataPlatformCountryCountryDatum            *DataPlatformCountryCountryDatum           `boil:"BillFromCountryDataPlatformCountryCountryDatum" json:"BillFromCountryDataPlatformCountryCountryDatum" toml:"BillFromCountryDataPlatformCountryCountryDatum" yaml:"BillFromCountryDataPlatformCountryCountryDatum"`
	BillToCountryDataPlatformCountryCountryDatum              *DataPlatformCountryCountryDatum           `boil:"BillToCountryDataPlatformCountryCountryDatum" json:"BillToCountryDataPlatformCountryCountryDatum" toml:"BillToCountryDataPlatformCountryCountryDatum" yaml:"BillToCountryDataPlatformCountryCountryDatum"`
	DeliverToPlantDataPlatformTimeZoneTimeZoneDatum           *DataPlatformTimeZoneTimeZoneDatum         `boil:"DeliverToPlantDataPlatformTimeZoneTimeZoneDatum" json:"DeliverToPlantDataPlatformTimeZoneTimeZoneDatum" toml:"DeliverToPlantDataPlatformTimeZoneTimeZoneDatum" yaml:"DeliverToPlantDataPlatformTimeZoneTimeZoneDatum"`
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum `boil:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	Incoterm                                                  *DataPlatformIncotermsIncotermsDatum       `boil:"Incoterm" json:"Incoterm" toml:"Incoterm" yaml:"Incoterm"`
	OrderIDDataPlatformOrdersItemDatum                        *DataPlatformOrdersItemDatum               `boil:"OrderIDDataPlatformOrdersItemDatum" json:"OrderIDDataPlatformOrdersItemDatum" toml:"OrderIDDataPlatformOrdersItemDatum" yaml:"OrderIDDataPlatformOrdersItemDatum"`
	ProductionOrderDataPlatformProductionOrderItemDatum       *DataPlatformProductionOrderItemDatum      `boil:"ProductionOrderDataPlatformProductionOrderItemDatum" json:"ProductionOrderDataPlatformProductionOrderItemDatum" toml:"ProductionOrderDataPlatformProductionOrderItemDatum" yaml:"ProductionOrderDataPlatformProductionOrderItemDatum"`
	BillFromPartyDataPlatformSCRBillingRelationDatum          *DataPlatformSCRBillingRelationDatum       `boil:"BillFromPartyDataPlatformSCRBillingRelationDatum" json:"BillFromPartyDataPlatformSCRBillingRelationDatum" toml:"BillFromPartyDataPlatformSCRBillingRelationDatum" yaml:"BillFromPartyDataPlatformSCRBillingRelationDatum"`
	BuyerDataPlatformSCRDeliveryRelationDatum                 *DataPlatformSCRDeliveryRelationDatum      `boil:"BuyerDataPlatformSCRDeliveryRelationDatum" json:"BuyerDataPlatformSCRDeliveryRelationDatum" toml:"BuyerDataPlatformSCRDeliveryRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryRelationDatum"`
	BuyerDataPlatformSCRDeliveryPlantRelationDatum            *DataPlatformSCRDeliveryPlantRelationDatum `boil:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" json:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" toml:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryPlantRelationDatum"`
	BillFromPartyDataPlatformSCRPaymentRelationDatum          *DataPlatformSCRPaymentRelationDatum       `boil:"BillFromPartyDataPlatformSCRPaymentRelationDatum" json:"BillFromPartyDataPlatformSCRPaymentRelationDatum" toml:"BillFromPartyDataPlatformSCRPaymentRelationDatum" yaml:"BillFromPartyDataPlatformSCRPaymentRelationDatum"`
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum      *DataPlatformCurrencyCurrencyDatum         `boil:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" json:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" toml:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" yaml:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformDeliveryDocumentHeaderDatumR) NewStruct() *dataPlatformDeliveryDocumentHeaderDatumR {
	return &dataPlatformDeliveryDocumentHeaderDatumR{}
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillFromCountryDataPlatformCountryCountryDatum() *DataPlatformCountryCountryDatum {
	if r == nil {
		return nil
	}
	return r.BillFromCountryDataPlatformCountryCountryDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillToCountryDataPlatformCountryCountryDatum() *DataPlatformCountryCountryDatum {
	if r == nil {
		return nil
	}
	return r.BillToCountryDataPlatformCountryCountryDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliverToPlantDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPlantDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetIncoterm() *DataPlatformIncotermsIncotermsDatum {
	if r == nil {
		return nil
	}
	return r.Incoterm
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetOrderIDDataPlatformOrdersItemDatum() *DataPlatformOrdersItemDatum {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetProductionOrderDataPlatformProductionOrderItemDatum() *DataPlatformProductionOrderItemDatum {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillFromPartyDataPlatformSCRBillingRelationDatum() *DataPlatformSCRBillingRelationDatum {
	if r == nil {
		return nil
	}
	return r.BillFromPartyDataPlatformSCRBillingRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBuyerDataPlatformSCRDeliveryRelationDatum() *DataPlatformSCRDeliveryRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBuyerDataPlatformSCRDeliveryPlantRelationDatum() *DataPlatformSCRDeliveryPlantRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryPlantRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBillFromPartyDataPlatformSCRPaymentRelationDatum() *DataPlatformSCRPaymentRelationDatum {
	if r == nil {
		return nil
	}
	return r.BillFromPartyDataPlatformSCRPaymentRelationDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetTransactionCurrencyDataPlatformCurrencyCurrencyDatum() *DataPlatformCurrencyCurrencyDatum {
	if r == nil {
		return nil
	}
	return r.TransactionCurrencyDataPlatformCurrencyCurrencyDatum
}

// dataPlatformDeliveryDocumentHeaderDatumL is where Load methods for each relationship are stored.
type dataPlatformDeliveryDocumentHeaderDatumL struct{}

var (
	dataPlatformDeliveryDocumentHeaderDatumAllColumns            = []string{"DeliveryDocument", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipBillingID", "SupplyChainRelationshipPaymentID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "BillToParty", "BillFromParty", "BillToCountry", "BillFromCountry", "Payer", "Payee", "IsExportImport", "DeliverToPlantTimeZone", "DeliverFromPlantTimeZone", "ReferenceDocument", "ReferenceDocumentItem", "OrderID", "OrderItem", "ProductionOrder", "ProductionOrderItem", "Operations", "OperationsItem", "BillOfMaterial", "BillOfMaterialItem", "ContractType", "OrderValidityStartDate", "OrderValidityEndDate", "DeliveryDocumentDate", "PlannedGoodsIssueDate", "PlannedGoodsIssueTime", "PlannedGoodsReceiptDate", "PlannedGoodsReceiptTime", "InvoiceDocumentDate", "HeaderCompleteDeliveryIsDefined", "HeaderDeliveryStatus", "GoodsIssueOrReceiptSlipNumber", "HeaderBillingStatus", "HeaderBillingConfStatus", "HeaderBillingBlockStatus", "HeaderGrossWeight", "HeaderNetWeight", "HeaderWeightUnit", "Incoterms", "TransactionCurrency", "HeaderDeliveryBlockStatus", "HeaderIssuingBlockStatus", "HeaderReceivingBlockStatus", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault = []string{"DeliveryDocument", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipBillingID", "SupplyChainRelationshipPaymentID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "BillToParty", "BillFromParty", "BillToCountry", "BillFromCountry", "Payer", "Payee", "IsExportImport", "DeliverToPlantTimeZone", "DeliverFromPlantTimeZone", "ReferenceDocument", "ReferenceDocumentItem", "OrderID", "OrderItem", "ProductionOrder", "ProductionOrderItem", "Operations", "OperationsItem", "BillOfMaterial", "BillOfMaterialItem", "ContractType", "OrderValidityStartDate", "OrderValidityEndDate", "DeliveryDocumentDate", "PlannedGoodsIssueDate", "PlannedGoodsIssueTime", "PlannedGoodsReceiptDate", "PlannedGoodsReceiptTime", "InvoiceDocumentDate", "HeaderCompleteDeliveryIsDefined", "HeaderDeliveryStatus", "GoodsIssueOrReceiptSlipNumber", "HeaderBillingStatus", "HeaderBillingConfStatus", "HeaderBillingBlockStatus", "HeaderGrossWeight", "HeaderNetWeight", "HeaderWeightUnit", "Incoterms", "TransactionCurrency", "HeaderDeliveryBlockStatus", "HeaderIssuingBlockStatus", "HeaderReceivingBlockStatus", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault    = []string{}
	dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns     = []string{"DeliveryDocument"}
	dataPlatformDeliveryDocumentHeaderDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformDeliveryDocumentHeaderDatumSlice is an alias for a slice of pointers to DataPlatformDeliveryDocumentHeaderDatum.
	// This should almost always be used instead of []DataPlatformDeliveryDocumentHeaderDatum.
	DataPlatformDeliveryDocumentHeaderDatumSlice []*DataPlatformDeliveryDocumentHeaderDatum

	dataPlatformDeliveryDocumentHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformDeliveryDocumentHeaderDatumType                 = reflect.TypeOf(&DataPlatformDeliveryDocumentHeaderDatum{})
	dataPlatformDeliveryDocumentHeaderDatumMapping              = queries.MakeStructMapping(dataPlatformDeliveryDocumentHeaderDatumType)
	dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns)
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumInsertCache          = make(map[string]insertCache)
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformDeliveryDocumentHeaderDatum record from the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformDeliveryDocumentHeaderDatum, error) {
	o := &DataPlatformDeliveryDocumentHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_delivery_document_header_data")
	}

	return o, nil
}

// All returns all DataPlatformDeliveryDocumentHeaderDatum records from the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformDeliveryDocumentHeaderDatumSlice, error) {
	var o []*DataPlatformDeliveryDocumentHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformDeliveryDocumentHeaderDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformDeliveryDocumentHeaderDatum records in the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_delivery_document_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_delivery_document_header_data exists")
	}

	return count > 0, nil
}

// BillFromCountryDataPlatformCountryCountryDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillFromCountryDataPlatformCountryCountryDatum(mods ...qm.QueryMod) dataPlatformCountryCountryDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Country` = ?", o.BillFromCountry),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCountryCountryData(queryMods...)
}

// BillToCountryDataPlatformCountryCountryDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillToCountryDataPlatformCountryCountryDatum(mods ...qm.QueryMod) dataPlatformCountryCountryDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Country` = ?", o.BillToCountry),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCountryCountryData(queryMods...)
}

// DeliverToPlantDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliverToPlantDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.DeliverToPlant),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.HeaderWeightUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// Incoterm pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Incoterm(mods ...qm.QueryMod) dataPlatformIncotermsIncotermsDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Incoterms` = ?", o.Incoterms),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformIncotermsIncotermsData(queryMods...)
}

// OrderIDDataPlatformOrdersItemDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) OrderIDDataPlatformOrdersItemDatum(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OrderID` = ?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOrdersItemData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) ProductionOrderDataPlatformProductionOrderItemDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionOrder` = ?", o.ProductionOrder),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemData(queryMods...)
}

// BillFromPartyDataPlatformSCRBillingRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillFromPartyDataPlatformSCRBillingRelationDatum(mods ...qm.QueryMod) dataPlatformSCRBillingRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillFromParty` = ?", o.BillFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRBillingRelationData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BuyerDataPlatformSCRDeliveryRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryRelationData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryPlantRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BuyerDataPlatformSCRDeliveryPlantRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryPlantRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryPlantRelationData(queryMods...)
}

// BillFromPartyDataPlatformSCRPaymentRelationDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BillFromPartyDataPlatformSCRPaymentRelationDatum(mods ...qm.QueryMod) dataPlatformSCRPaymentRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillFromParty` = ?", o.BillFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRPaymentRelationData(queryMods...)
}

// TransactionCurrencyDataPlatformCurrencyCurrencyDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) TransactionCurrencyDataPlatformCurrencyCurrencyDatum(mods ...qm.QueryMod) dataPlatformCurrencyCurrencyDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Currency` = ?", o.TransactionCurrency),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCurrencyCurrencyData(queryMods...)
}

// LoadBillFromCountryDataPlatformCountryCountryDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillFromCountryDataPlatformCountryCountryDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillFromCountry) {
			args = append(args, object.BillFromCountry)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillFromCountry) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillFromCountry) {
				args = append(args, obj.BillFromCountry)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_country_country_data`),
		qm.WhereIn(`data_platform_country_country_data.Country in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCountryCountryDatum")
	}

	var resultSlice []*DataPlatformCountryCountryDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCountryCountryDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_country_country_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_country_country_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillFromCountryDataPlatformCountryCountryDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillFromCountry, foreign.Country) {
				local.R.BillFromCountryDataPlatformCountryCountryDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillToCountryDataPlatformCountryCountryDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillToCountryDataPlatformCountryCountryDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillToCountry) {
			args = append(args, object.BillToCountry)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillToCountry) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillToCountry) {
				args = append(args, obj.BillToCountry)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_country_country_data`),
		qm.WhereIn(`data_platform_country_country_data.Country in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCountryCountryDatum")
	}

	var resultSlice []*DataPlatformCountryCountryDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCountryCountryDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_country_country_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_country_country_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillToCountryDataPlatformCountryCountryDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillToCountry, foreign.Country) {
				local.R.BillToCountryDataPlatformCountryCountryDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPlantDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliverToPlantDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.DeliverToPlant)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliverToPlant {
					continue Outer
				}
			}

			args = append(args, obj.DeliverToPlant)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPlantDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliverToPlant == foreign.TimeZone {
				local.R.DeliverToPlantDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.HeaderWeightUnit) {
			args = append(args, object.HeaderWeightUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.HeaderWeightUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.HeaderWeightUnit) {
				args = append(args, obj.HeaderWeightUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.HeaderWeightUnit, foreign.QuantityUnit) {
				local.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadIncoterm allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadIncoterm(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Incoterms) {
			args = append(args, object.Incoterms)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Incoterms) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Incoterms) {
				args = append(args, obj.Incoterms)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_incoterms_incoterms_data`),
		qm.WhereIn(`data_platform_incoterms_incoterms_data.Incoterms in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformIncotermsIncotermsDatum")
	}

	var resultSlice []*DataPlatformIncotermsIncotermsDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformIncotermsIncotermsDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_incoterms_incoterms_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_incoterms_incoterms_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Incoterm = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Incoterms, foreign.Incoterms) {
				local.R.Incoterm = foreign
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadOrderIDDataPlatformOrdersItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.OrderID) {
			args = append(args, object.OrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrderID) {
				args = append(args, obj.OrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOrdersItemDatum")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOrdersItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrderIDDataPlatformOrdersItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformOrdersItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.ProductionOrder) {
			args = append(args, object.ProductionOrder)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductionOrder) {
				args = append(args, obj.ProductionOrder)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_data`),
		qm.WhereIn(`data_platform_production_order_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillFromPartyDataPlatformSCRBillingRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillFromPartyDataPlatformSCRBillingRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillFromParty) {
			args = append(args, object.BillFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillFromParty) {
				args = append(args, obj.BillFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_billing_relation_data`),
		qm.WhereIn(`data_platform_scr_billing_relation_data.BillFromParty in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRBillingRelationDatum")
	}

	var resultSlice []*DataPlatformSCRBillingRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRBillingRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_billing_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_billing_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillFromPartyDataPlatformSCRBillingRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillFromParty, foreign.BillFromParty) {
				local.R.BillFromPartyDataPlatformSCRBillingRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryPlantRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBuyerDataPlatformSCRDeliveryPlantRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_plant_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_plant_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryPlantRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryPlantRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryPlantRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_plant_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_plant_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillFromPartyDataPlatformSCRPaymentRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBillFromPartyDataPlatformSCRPaymentRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.BillFromParty) {
			args = append(args, object.BillFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillFromParty) {
				args = append(args, obj.BillFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_payment_relation_data`),
		qm.WhereIn(`data_platform_scr_payment_relation_data.BillFromParty in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRPaymentRelationDatum")
	}

	var resultSlice []*DataPlatformSCRPaymentRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRPaymentRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_payment_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_payment_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillFromParty, foreign.BillFromParty) {
				local.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadTransactionCurrencyDataPlatformCurrencyCurrencyDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.TransactionCurrency) {
			args = append(args, object.TransactionCurrency)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.TransactionCurrency) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.TransactionCurrency) {
				args = append(args, obj.TransactionCurrency)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_currency_currency_data`),
		qm.WhereIn(`data_platform_currency_currency_data.Currency in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCurrencyCurrencyDatum")
	}

	var resultSlice []*DataPlatformCurrencyCurrencyDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCurrencyCurrencyDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_currency_currency_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_currency_currency_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TransactionCurrency, foreign.Currency) {
				local.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = foreign
				break
			}
		}
	}

	return nil
}

// SetBillFromCountryDataPlatformCountryCountryDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillFromCountryDataPlatformCountryCountryDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillFromCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCountryCountryDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillFromCountry"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Country, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillFromCountry, related.Country)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillFromCountryDataPlatformCountryCountryDatum: related,
		}
	} else {
		o.R.BillFromCountryDataPlatformCountryCountryDatum = related
	}

	return nil
}

// RemoveBillFromCountryDataPlatformCountryCountryDatum relationship.
// Sets o.R.BillFromCountryDataPlatformCountryCountryDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillFromCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCountryCountryDatum) error {
	var err error

	queries.SetScanner(&o.BillFromCountry, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillFromCountry")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillFromCountryDataPlatformCountryCountryDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBillToCountryDataPlatformCountryCountryDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillToCountryDataPlatformCountryCountryDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillToCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCountryCountryDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillToCountry"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Country, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillToCountry, related.Country)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillToCountryDataPlatformCountryCountryDatum: related,
		}
	} else {
		o.R.BillToCountryDataPlatformCountryCountryDatum = related
	}

	return nil
}

// RemoveBillToCountryDataPlatformCountryCountryDatum relationship.
// Sets o.R.BillToCountryDataPlatformCountryCountryDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillToCountryDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCountryCountryDatum) error {
	var err error

	queries.SetScanner(&o.BillToCountry, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillToCountry")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillToCountryDataPlatformCountryCountryDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverToPlantDataPlatformTimeZoneTimeZoneDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.DeliverToPlantDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetDeliverToPlantDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToPlant"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliverToPlant = related.TimeZone
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliverToPlantDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.DeliverToPlantDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// SetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"HeaderWeightUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.HeaderWeightUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// RemoveHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.HeaderWeightUnit, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("HeaderWeightUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetIncoterm of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.Incoterm to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetIncoterm(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Incoterms"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Incoterms, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Incoterms, related.Incoterms)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			Incoterm: related,
		}
	} else {
		o.R.Incoterm = related
	}

	return nil
}

// RemoveIncoterm relationship.
// Sets o.R.Incoterm to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveIncoterm(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error

	queries.SetScanner(&o.Incoterms, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Incoterms")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Incoterm = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetOrderIDDataPlatformOrdersItemDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOrdersItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OrderID, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrderID, related.OrderID)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			OrderIDDataPlatformOrdersItemDatum: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemDatum = related
	}

	return nil
}

// RemoveOrderIDDataPlatformOrdersItemDatum relationship.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformOrdersItemDatum) error {
	var err error

	queries.SetScanner(&o.OrderID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformOrdersItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductionOrderDataPlatformProductionOrderItemDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionOrder, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductionOrder, related.ProductionOrder)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			ProductionOrderDataPlatformProductionOrderItemDatum: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = related
	}

	return nil
}

// RemoveProductionOrderDataPlatformProductionOrderItemDatum relationship.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionOrderItemDatum) error {
	var err error

	queries.SetScanner(&o.ProductionOrder, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBillFromPartyDataPlatformSCRBillingRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillFromPartyDataPlatformSCRBillingRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillFromPartyDataPlatformSCRBillingRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRBillingRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillFromParty, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillFromParty, related.BillFromParty)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillFromPartyDataPlatformSCRBillingRelationDatum: related,
		}
	} else {
		o.R.BillFromPartyDataPlatformSCRBillingRelationDatum = related
	}

	return nil
}

// RemoveBillFromPartyDataPlatformSCRBillingRelationDatum relationship.
// Sets o.R.BillFromPartyDataPlatformSCRBillingRelationDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillFromPartyDataPlatformSCRBillingRelationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformSCRBillingRelationDatum) error {
	var err error

	queries.SetScanner(&o.BillFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillFromPartyDataPlatformSCRBillingRelationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BuyerDataPlatformSCRDeliveryRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryRelationDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryPlantRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBuyerDataPlatformSCRDeliveryPlantRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryPlantRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BuyerDataPlatformSCRDeliveryPlantRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = related
	}

	return nil
}

// SetBillFromPartyDataPlatformSCRPaymentRelationDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBillFromPartyDataPlatformSCRPaymentRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRPaymentRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillFromParty, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillFromParty, related.BillFromParty)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BillFromPartyDataPlatformSCRPaymentRelationDatum: related,
		}
	} else {
		o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = related
	}

	return nil
}

// RemoveBillFromPartyDataPlatformSCRPaymentRelationDatum relationship.
// Sets o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBillFromPartyDataPlatformSCRPaymentRelationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformSCRPaymentRelationDatum) error {
	var err error

	queries.SetScanner(&o.BillFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillFromPartyDataPlatformSCRPaymentRelationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetTransactionCurrencyDataPlatformCurrencyCurrencyDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum to related.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCurrencyCurrencyDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"TransactionCurrency"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Currency, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TransactionCurrency, related.Currency)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			TransactionCurrencyDataPlatformCurrencyCurrencyDatum: related,
		}
	} else {
		o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = related
	}

	return nil
}

// RemoveTransactionCurrencyDataPlatformCurrencyCurrencyDatum relationship.
// Sets o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum to nil.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCurrencyCurrencyDatum) error {
	var err error

	queries.SetScanner(&o.TransactionCurrency, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("TransactionCurrency")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// DataPlatformDeliveryDocumentHeaderData retrieves all the records using an executor.
func DataPlatformDeliveryDocumentHeaderData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDatumQuery {
	mods = append(mods, qm.From("`data_platform_delivery_document_header_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_delivery_document_header_data`.*"})
	}

	return dataPlatformDeliveryDocumentHeaderDatumQuery{q}
}

// FindDataPlatformDeliveryDocumentHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformDeliveryDocumentHeaderDatum(ctx context.Context, exec boil.ContextExecutor, deliveryDocument int, selectCols ...string) (*DataPlatformDeliveryDocumentHeaderDatum, error) {
	dataPlatformDeliveryDocumentHeaderDatumObj := &DataPlatformDeliveryDocumentHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_delivery_document_header_data` where `DeliveryDocument`=?", sel,
	)

	q := queries.Raw(query, deliveryDocument)

	err := q.Bind(ctx, exec, dataPlatformDeliveryDocumentHeaderDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_delivery_document_header_data")
	}

	return dataPlatformDeliveryDocumentHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_delivery_document_header_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumInsertCache[key]
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_delivery_document_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_delivery_document_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_delivery_document_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_delivery_document_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.DeliveryDocument,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_delivery_document_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumInsertCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformDeliveryDocumentHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumUpdateCache[key]
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_delivery_document_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, append(wl, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_delivery_document_header_data row")
	}

	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumUpdateCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_delivery_document_header_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformDeliveryDocumentHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformDeliveryDocumentHeaderDatum slice")
	}

	return nil
}

var mySQLDataPlatformDeliveryDocumentHeaderDatumUniqueColumns = []string{
	"DeliveryDocument",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_delivery_document_header_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformDeliveryDocumentHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumUpsertCache[key]
	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_delivery_document_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_delivery_document_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_delivery_document_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_delivery_document_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_delivery_document_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_delivery_document_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumUpsertCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformDeliveryDocumentHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformDeliveryDocumentHeaderDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_delivery_document_header_data` WHERE `DeliveryDocument`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_delivery_document_header_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformDeliveryDocumentHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_delivery_document_header_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformDeliveryDocumentHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_delivery_document_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformDeliveryDocumentHeaderDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformDeliveryDocumentHeaderDatum(ctx, exec, o.DeliveryDocument)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformDeliveryDocumentHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformDeliveryDocumentHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_delivery_document_header_data`.* FROM `data_platform_delivery_document_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformDeliveryDocumentHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformDeliveryDocumentHeaderDatumExists checks if the DataPlatformDeliveryDocumentHeaderDatum row exists.
func DataPlatformDeliveryDocumentHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, deliveryDocument int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_delivery_document_header_data` where `DeliveryDocument`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, deliveryDocument)
	}
	row := exec.QueryRowContext(ctx, sql, deliveryDocument)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_delivery_document_header_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformDeliveryDocumentHeaderDatum row exists.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformDeliveryDocumentHeaderDatumExists(ctx, exec, o.DeliveryDocument)
}
