// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformDeliveryDocumentHeaderDatum is an object representing the database table.
type DataPlatformDeliveryDocumentHeaderDatum struct {
	DeliveryDocument              int          `boil:"DeliveryDocument" json:"DeliveryDocument" toml:"DeliveryDocument" yaml:"DeliveryDocument"`
	Buyer                         null.Int     `boil:"Buyer" json:"Buyer,omitempty" toml:"Buyer" yaml:"Buyer,omitempty"`
	Seller                        null.Int     `boil:"Seller" json:"Seller,omitempty" toml:"Seller" yaml:"Seller,omitempty"`
	ReferenceDocument             null.Int     `boil:"ReferenceDocument" json:"ReferenceDocument,omitempty" toml:"ReferenceDocument" yaml:"ReferenceDocument,omitempty"`
	ReferenceDocumentItem         null.Int     `boil:"ReferenceDocumentItem" json:"ReferenceDocumentItem,omitempty" toml:"ReferenceDocumentItem" yaml:"ReferenceDocumentItem,omitempty"`
	OrderID                       null.Int     `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	OrderItem                     null.Int     `boil:"OrderItem" json:"OrderItem,omitempty" toml:"OrderItem" yaml:"OrderItem,omitempty"`
	ContractType                  null.String  `boil:"ContractType" json:"ContractType,omitempty" toml:"ContractType" yaml:"ContractType,omitempty"`
	OrderValidityStartDate        null.Time    `boil:"OrderValidityStartDate" json:"OrderValidityStartDate,omitempty" toml:"OrderValidityStartDate" yaml:"OrderValidityStartDate,omitempty"`
	OrderValidityEndDate          null.Time    `boil:"OrderValidityEndDate" json:"OrderValidityEndDate,omitempty" toml:"OrderValidityEndDate" yaml:"OrderValidityEndDate,omitempty"`
	InvoiceScheduleStartDate      null.Time    `boil:"InvoiceScheduleStartDate" json:"InvoiceScheduleStartDate,omitempty" toml:"InvoiceScheduleStartDate" yaml:"InvoiceScheduleStartDate,omitempty"`
	InvoiceScheduleEndDate        null.Time    `boil:"InvoiceScheduleEndDate" json:"InvoiceScheduleEndDate,omitempty" toml:"InvoiceScheduleEndDate" yaml:"InvoiceScheduleEndDate,omitempty"`
	IssuingLocationTimeZone       null.String  `boil:"IssuingLocationTimeZone" json:"IssuingLocationTimeZone,omitempty" toml:"IssuingLocationTimeZone" yaml:"IssuingLocationTimeZone,omitempty"`
	ReceivingLocationTimeZone     null.String  `boil:"ReceivingLocationTimeZone" json:"ReceivingLocationTimeZone,omitempty" toml:"ReceivingLocationTimeZone" yaml:"ReceivingLocationTimeZone,omitempty"`
	DocumentDate                  null.String    `boil:"DocumentDate" json:"DocumentDate,omitempty" toml:"DocumentDate" yaml:"DocumentDate,omitempty"`
	PlannedGoodsIssueDate         null.Time    `boil:"PlannedGoodsIssueDate" json:"PlannedGoodsIssueDate,omitempty" toml:"PlannedGoodsIssueDate" yaml:"PlannedGoodsIssueDate,omitempty"`
	PlannedGoodsIssueTime         null.String  `boil:"PlannedGoodsIssueTime" json:"PlannedGoodsIssueTime,omitempty" toml:"PlannedGoodsIssueTime" yaml:"PlannedGoodsIssueTime,omitempty"`
	PlannedGoodsReceiptDate       null.Time    `boil:"PlannedGoodsReceiptDate" json:"PlannedGoodsReceiptDate,omitempty" toml:"PlannedGoodsReceiptDate" yaml:"PlannedGoodsReceiptDate,omitempty"`
	PlannedGoodsReceiptTime       null.String  `boil:"PlannedGoodsReceiptTime" json:"PlannedGoodsReceiptTime,omitempty" toml:"PlannedGoodsReceiptTime" yaml:"PlannedGoodsReceiptTime,omitempty"`
	BillingDocumentDate           null.Time    `boil:"BillingDocumentDate" json:"BillingDocumentDate,omitempty" toml:"BillingDocumentDate" yaml:"BillingDocumentDate,omitempty"`
	CompleteDeliveryIsDefined     null.Bool    `boil:"CompleteDeliveryIsDefined" json:"CompleteDeliveryIsDefined,omitempty" toml:"CompleteDeliveryIsDefined" yaml:"CompleteDeliveryIsDefined,omitempty"`
	OverallDeliveryStatus         null.String  `boil:"OverallDeliveryStatus" json:"OverallDeliveryStatus,omitempty" toml:"OverallDeliveryStatus" yaml:"OverallDeliveryStatus,omitempty"`
	CreationDate                  null.Time    `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	CreationTime                  null.String  `boil:"CreationTime" json:"CreationTime,omitempty" toml:"CreationTime" yaml:"CreationTime,omitempty"`
	IssuingBlockReason            null.Bool    `boil:"IssuingBlockReason" json:"IssuingBlockReason,omitempty" toml:"IssuingBlockReason" yaml:"IssuingBlockReason,omitempty"`
	ReceivingBlockReason          null.Bool    `boil:"ReceivingBlockReason" json:"ReceivingBlockReason,omitempty" toml:"ReceivingBlockReason" yaml:"ReceivingBlockReason,omitempty"`
	GoodsIssueOrReceiptSlipNumber null.String  `boil:"GoodsIssueOrReceiptSlipNumber" json:"GoodsIssueOrReceiptSlipNumber,omitempty" toml:"GoodsIssueOrReceiptSlipNumber" yaml:"GoodsIssueOrReceiptSlipNumber,omitempty"`
	HeaderBillingStatus           null.String  `boil:"HeaderBillingStatus" json:"HeaderBillingStatus,omitempty" toml:"HeaderBillingStatus" yaml:"HeaderBillingStatus,omitempty"`
	HeaderBillingConfStatus       null.String  `boil:"HeaderBillingConfStatus" json:"HeaderBillingConfStatus,omitempty" toml:"HeaderBillingConfStatus" yaml:"HeaderBillingConfStatus,omitempty"`
	HeaderBillingBlockReason      null.Bool    `boil:"HeaderBillingBlockReason" json:"HeaderBillingBlockReason,omitempty" toml:"HeaderBillingBlockReason" yaml:"HeaderBillingBlockReason,omitempty"`
	HeaderGrossWeight             null.Float32 `boil:"HeaderGrossWeight" json:"HeaderGrossWeight,omitempty" toml:"HeaderGrossWeight" yaml:"HeaderGrossWeight,omitempty"`
	HeaderNetWeight               null.Float32 `boil:"HeaderNetWeight" json:"HeaderNetWeight,omitempty" toml:"HeaderNetWeight" yaml:"HeaderNetWeight,omitempty"`
	HeaderWeightUnit              null.String  `boil:"HeaderWeightUnit" json:"HeaderWeightUnit,omitempty" toml:"HeaderWeightUnit" yaml:"HeaderWeightUnit,omitempty"`
	Incoterms                     null.String  `boil:"Incoterms" json:"Incoterms,omitempty" toml:"Incoterms" yaml:"Incoterms,omitempty"`
	IsExportImportDelivery        null.Bool    `boil:"IsExportImportDelivery" json:"IsExportImportDelivery,omitempty" toml:"IsExportImportDelivery" yaml:"IsExportImportDelivery,omitempty"`
	LastChangeDate                null.Time    `boil:"LastChangeDate" json:"LastChangeDate,omitempty" toml:"LastChangeDate" yaml:"LastChangeDate,omitempty"`
	IssuingPlantBusinessPartner   null.Int     `boil:"IssuingPlantBusinessPartner" json:"IssuingPlantBusinessPartner,omitempty" toml:"IssuingPlantBusinessPartner" yaml:"IssuingPlantBusinessPartner,omitempty"`
	IssuingPlant                  null.String  `boil:"IssuingPlant" json:"IssuingPlant,omitempty" toml:"IssuingPlant" yaml:"IssuingPlant,omitempty"`
	ReceivingPlantBusinessPartner null.Int     `boil:"ReceivingPlantBusinessPartner" json:"ReceivingPlantBusinessPartner,omitempty" toml:"ReceivingPlantBusinessPartner" yaml:"ReceivingPlantBusinessPartner,omitempty"`
	ReceivingPlant                null.String  `boil:"ReceivingPlant" json:"ReceivingPlant,omitempty" toml:"ReceivingPlant" yaml:"ReceivingPlant,omitempty"`
	DeliverToParty                null.Int     `boil:"DeliverToParty" json:"DeliverToParty,omitempty" toml:"DeliverToParty" yaml:"DeliverToParty,omitempty"`
	DeliverFromParty              null.Int     `boil:"DeliverFromParty" json:"DeliverFromParty,omitempty" toml:"DeliverFromParty" yaml:"DeliverFromParty,omitempty"`
	TransactionCurrency           null.String  `boil:"TransactionCurrency" json:"TransactionCurrency,omitempty" toml:"TransactionCurrency" yaml:"TransactionCurrency,omitempty"`
	OverallDelivReltdBillgStatus  null.String  `boil:"OverallDelivReltdBillgStatus" json:"OverallDelivReltdBillgStatus,omitempty" toml:"OverallDelivReltdBillgStatus" yaml:"OverallDelivReltdBillgStatus,omitempty"`

	R *dataPlatformDeliveryDocumentHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformDeliveryDocumentHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformDeliveryDocumentHeaderDatumColumns = struct {
	DeliveryDocument              string
	Buyer                         string
	Seller                        string
	ReferenceDocument             string
	ReferenceDocumentItem         string
	OrderID                       string
	OrderItem                     string
	ContractType                  string
	OrderValidityStartDate        string
	OrderValidityEndDate          string
	InvoiceScheduleStartDate      string
	InvoiceScheduleEndDate        string
	IssuingLocationTimeZone       string
	ReceivingLocationTimeZone     string
	DocumentDate                  string
	PlannedGoodsIssueDate         string
	PlannedGoodsIssueTime         string
	PlannedGoodsReceiptDate       string
	PlannedGoodsReceiptTime       string
	BillingDocumentDate           string
	CompleteDeliveryIsDefined     string
	OverallDeliveryStatus         string
	CreationDate                  string
	CreationTime                  string
	IssuingBlockReason            string
	ReceivingBlockReason          string
	GoodsIssueOrReceiptSlipNumber string
	HeaderBillingStatus           string
	HeaderBillingConfStatus       string
	HeaderBillingBlockReason      string
	HeaderGrossWeight             string
	HeaderNetWeight               string
	HeaderWeightUnit              string
	Incoterms                     string
	IsExportImportDelivery        string
	LastChangeDate                string
	IssuingPlantBusinessPartner   string
	IssuingPlant                  string
	ReceivingPlantBusinessPartner string
	ReceivingPlant                string
	DeliverToParty                string
	DeliverFromParty              string
	TransactionCurrency           string
	OverallDelivReltdBillgStatus  string
}{
	DeliveryDocument:              "DeliveryDocument",
	Buyer:                         "Buyer",
	Seller:                        "Seller",
	ReferenceDocument:             "ReferenceDocument",
	ReferenceDocumentItem:         "ReferenceDocumentItem",
	OrderID:                       "OrderID",
	OrderItem:                     "OrderItem",
	ContractType:                  "ContractType",
	OrderValidityStartDate:        "OrderValidityStartDate",
	OrderValidityEndDate:          "OrderValidityEndDate",
	InvoiceScheduleStartDate:      "InvoiceScheduleStartDate",
	InvoiceScheduleEndDate:        "InvoiceScheduleEndDate",
	IssuingLocationTimeZone:       "IssuingLocationTimeZone",
	ReceivingLocationTimeZone:     "ReceivingLocationTimeZone",
	DocumentDate:                  "DocumentDate",
	PlannedGoodsIssueDate:         "PlannedGoodsIssueDate",
	PlannedGoodsIssueTime:         "PlannedGoodsIssueTime",
	PlannedGoodsReceiptDate:       "PlannedGoodsReceiptDate",
	PlannedGoodsReceiptTime:       "PlannedGoodsReceiptTime",
	BillingDocumentDate:           "BillingDocumentDate",
	CompleteDeliveryIsDefined:     "CompleteDeliveryIsDefined",
	OverallDeliveryStatus:         "OverallDeliveryStatus",
	CreationDate:                  "CreationDate",
	CreationTime:                  "CreationTime",
	IssuingBlockReason:            "IssuingBlockReason",
	ReceivingBlockReason:          "ReceivingBlockReason",
	GoodsIssueOrReceiptSlipNumber: "GoodsIssueOrReceiptSlipNumber",
	HeaderBillingStatus:           "HeaderBillingStatus",
	HeaderBillingConfStatus:       "HeaderBillingConfStatus",
	HeaderBillingBlockReason:      "HeaderBillingBlockReason",
	HeaderGrossWeight:             "HeaderGrossWeight",
	HeaderNetWeight:               "HeaderNetWeight",
	HeaderWeightUnit:              "HeaderWeightUnit",
	Incoterms:                     "Incoterms",
	IsExportImportDelivery:        "IsExportImportDelivery",
	LastChangeDate:                "LastChangeDate",
	IssuingPlantBusinessPartner:   "IssuingPlantBusinessPartner",
	IssuingPlant:                  "IssuingPlant",
	ReceivingPlantBusinessPartner: "ReceivingPlantBusinessPartner",
	ReceivingPlant:                "ReceivingPlant",
	DeliverToParty:                "DeliverToParty",
	DeliverFromParty:              "DeliverFromParty",
	TransactionCurrency:           "TransactionCurrency",
	OverallDelivReltdBillgStatus:  "OverallDelivReltdBillgStatus",
}

var DataPlatformDeliveryDocumentHeaderDatumTableColumns = struct {
	DeliveryDocument              string
	Buyer                         string
	Seller                        string
	ReferenceDocument             string
	ReferenceDocumentItem         string
	OrderID                       string
	OrderItem                     string
	ContractType                  string
	OrderValidityStartDate        string
	OrderValidityEndDate          string
	InvoiceScheduleStartDate      string
	InvoiceScheduleEndDate        string
	IssuingLocationTimeZone       string
	ReceivingLocationTimeZone     string
	DocumentDate                  string
	PlannedGoodsIssueDate         string
	PlannedGoodsIssueTime         string
	PlannedGoodsReceiptDate       string
	PlannedGoodsReceiptTime       string
	BillingDocumentDate           string
	CompleteDeliveryIsDefined     string
	OverallDeliveryStatus         string
	CreationDate                  string
	CreationTime                  string
	IssuingBlockReason            string
	ReceivingBlockReason          string
	GoodsIssueOrReceiptSlipNumber string
	HeaderBillingStatus           string
	HeaderBillingConfStatus       string
	HeaderBillingBlockReason      string
	HeaderGrossWeight             string
	HeaderNetWeight               string
	HeaderWeightUnit              string
	Incoterms                     string
	IsExportImportDelivery        string
	LastChangeDate                string
	IssuingPlantBusinessPartner   string
	IssuingPlant                  string
	ReceivingPlantBusinessPartner string
	ReceivingPlant                string
	DeliverToParty                string
	DeliverFromParty              string
	TransactionCurrency           string
	OverallDelivReltdBillgStatus  string
}{
	DeliveryDocument:              "data_platform_delivery_document_header_data.DeliveryDocument",
	Buyer:                         "data_platform_delivery_document_header_data.Buyer",
	Seller:                        "data_platform_delivery_document_header_data.Seller",
	ReferenceDocument:             "data_platform_delivery_document_header_data.ReferenceDocument",
	ReferenceDocumentItem:         "data_platform_delivery_document_header_data.ReferenceDocumentItem",
	OrderID:                       "data_platform_delivery_document_header_data.OrderID",
	OrderItem:                     "data_platform_delivery_document_header_data.OrderItem",
	ContractType:                  "data_platform_delivery_document_header_data.ContractType",
	OrderValidityStartDate:        "data_platform_delivery_document_header_data.OrderValidityStartDate",
	OrderValidityEndDate:          "data_platform_delivery_document_header_data.OrderValidityEndDate",
	InvoiceScheduleStartDate:      "data_platform_delivery_document_header_data.InvoiceScheduleStartDate",
	InvoiceScheduleEndDate:        "data_platform_delivery_document_header_data.InvoiceScheduleEndDate",
	IssuingLocationTimeZone:       "data_platform_delivery_document_header_data.IssuingLocationTimeZone",
	ReceivingLocationTimeZone:     "data_platform_delivery_document_header_data.ReceivingLocationTimeZone",
	DocumentDate:                  "data_platform_delivery_document_header_data.DocumentDate",
	PlannedGoodsIssueDate:         "data_platform_delivery_document_header_data.PlannedGoodsIssueDate",
	PlannedGoodsIssueTime:         "data_platform_delivery_document_header_data.PlannedGoodsIssueTime",
	PlannedGoodsReceiptDate:       "data_platform_delivery_document_header_data.PlannedGoodsReceiptDate",
	PlannedGoodsReceiptTime:       "data_platform_delivery_document_header_data.PlannedGoodsReceiptTime",
	BillingDocumentDate:           "data_platform_delivery_document_header_data.BillingDocumentDate",
	CompleteDeliveryIsDefined:     "data_platform_delivery_document_header_data.CompleteDeliveryIsDefined",
	OverallDeliveryStatus:         "data_platform_delivery_document_header_data.OverallDeliveryStatus",
	CreationDate:                  "data_platform_delivery_document_header_data.CreationDate",
	CreationTime:                  "data_platform_delivery_document_header_data.CreationTime",
	IssuingBlockReason:            "data_platform_delivery_document_header_data.IssuingBlockReason",
	ReceivingBlockReason:          "data_platform_delivery_document_header_data.ReceivingBlockReason",
	GoodsIssueOrReceiptSlipNumber: "data_platform_delivery_document_header_data.GoodsIssueOrReceiptSlipNumber",
	HeaderBillingStatus:           "data_platform_delivery_document_header_data.HeaderBillingStatus",
	HeaderBillingConfStatus:       "data_platform_delivery_document_header_data.HeaderBillingConfStatus",
	HeaderBillingBlockReason:      "data_platform_delivery_document_header_data.HeaderBillingBlockReason",
	HeaderGrossWeight:             "data_platform_delivery_document_header_data.HeaderGrossWeight",
	HeaderNetWeight:               "data_platform_delivery_document_header_data.HeaderNetWeight",
	HeaderWeightUnit:              "data_platform_delivery_document_header_data.HeaderWeightUnit",
	Incoterms:                     "data_platform_delivery_document_header_data.Incoterms",
	IsExportImportDelivery:        "data_platform_delivery_document_header_data.IsExportImportDelivery",
	LastChangeDate:                "data_platform_delivery_document_header_data.LastChangeDate",
	IssuingPlantBusinessPartner:   "data_platform_delivery_document_header_data.IssuingPlantBusinessPartner",
	IssuingPlant:                  "data_platform_delivery_document_header_data.IssuingPlant",
	ReceivingPlantBusinessPartner: "data_platform_delivery_document_header_data.ReceivingPlantBusinessPartner",
	ReceivingPlant:                "data_platform_delivery_document_header_data.ReceivingPlant",
	DeliverToParty:                "data_platform_delivery_document_header_data.DeliverToParty",
	DeliverFromParty:              "data_platform_delivery_document_header_data.DeliverFromParty",
	TransactionCurrency:           "data_platform_delivery_document_header_data.TransactionCurrency",
	OverallDelivReltdBillgStatus:  "data_platform_delivery_document_header_data.OverallDelivReltdBillgStatus",
}

// Generated where

type whereHelpernull_Float32 struct{ field string }

func (w whereHelpernull_Float32) EQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float32) NEQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float32) LT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float32) LTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float32) GT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float32) GTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float32) NIN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var DataPlatformDeliveryDocumentHeaderDatumWhere = struct {
	DeliveryDocument              whereHelperint
	Buyer                         whereHelpernull_Int
	Seller                        whereHelpernull_Int
	ReferenceDocument             whereHelpernull_Int
	ReferenceDocumentItem         whereHelpernull_Int
	OrderID                       whereHelpernull_Int
	OrderItem                     whereHelpernull_Int
	ContractType                  whereHelpernull_String
	OrderValidityStartDate        whereHelpernull_Time
	OrderValidityEndDate          whereHelpernull_Time
	InvoiceScheduleStartDate      whereHelpernull_Time
	InvoiceScheduleEndDate        whereHelpernull_Time
	IssuingLocationTimeZone       whereHelpernull_String
	ReceivingLocationTimeZone     whereHelpernull_String
	DocumentDate                  whereHelpernull_Time
	PlannedGoodsIssueDate         whereHelpernull_Time
	PlannedGoodsIssueTime         whereHelpernull_String
	PlannedGoodsReceiptDate       whereHelpernull_Time
	PlannedGoodsReceiptTime       whereHelpernull_String
	BillingDocumentDate           whereHelpernull_Time
	CompleteDeliveryIsDefined     whereHelpernull_Bool
	OverallDeliveryStatus         whereHelpernull_String
	CreationDate                  whereHelpernull_Time
	CreationTime                  whereHelpernull_String
	IssuingBlockReason            whereHelpernull_Bool
	ReceivingBlockReason          whereHelpernull_Bool
	GoodsIssueOrReceiptSlipNumber whereHelpernull_String
	HeaderBillingStatus           whereHelpernull_String
	HeaderBillingConfStatus       whereHelpernull_String
	HeaderBillingBlockReason      whereHelpernull_Bool
	HeaderGrossWeight             whereHelpernull_Float32
	HeaderNetWeight               whereHelpernull_Float32
	HeaderWeightUnit              whereHelpernull_String
	Incoterms                     whereHelpernull_String
	IsExportImportDelivery        whereHelpernull_Bool
	LastChangeDate                whereHelpernull_Time
	IssuingPlantBusinessPartner   whereHelpernull_Int
	IssuingPlant                  whereHelpernull_String
	ReceivingPlantBusinessPartner whereHelpernull_Int
	ReceivingPlant                whereHelpernull_String
	DeliverToParty                whereHelpernull_Int
	DeliverFromParty              whereHelpernull_Int
	TransactionCurrency           whereHelpernull_String
	OverallDelivReltdBillgStatus  whereHelpernull_String
}{
	DeliveryDocument:              whereHelperint{field: "`data_platform_delivery_document_header_data`.`DeliveryDocument`"},
	Buyer:                         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Buyer`"},
	Seller:                        whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`Seller`"},
	ReferenceDocument:             whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReferenceDocument`"},
	ReferenceDocumentItem:         whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReferenceDocumentItem`"},
	OrderID:                       whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OrderID`"},
	OrderItem:                     whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`OrderItem`"},
	ContractType:                  whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`ContractType`"},
	OrderValidityStartDate:        whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`OrderValidityStartDate`"},
	OrderValidityEndDate:          whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`OrderValidityEndDate`"},
	InvoiceScheduleStartDate:      whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`InvoiceScheduleStartDate`"},
	InvoiceScheduleEndDate:        whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`InvoiceScheduleEndDate`"},
	IssuingLocationTimeZone:       whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`IssuingLocationTimeZone`"},
	ReceivingLocationTimeZone:     whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`ReceivingLocationTimeZone`"},
	DocumentDate:                  whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`DocumentDate`"},
	PlannedGoodsIssueDate:         whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsIssueDate`"},
	PlannedGoodsIssueTime:         whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsIssueTime`"},
	PlannedGoodsReceiptDate:       whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsReceiptDate`"},
	PlannedGoodsReceiptTime:       whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`PlannedGoodsReceiptTime`"},
	BillingDocumentDate:           whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`BillingDocumentDate`"},
	CompleteDeliveryIsDefined:     whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`CompleteDeliveryIsDefined`"},
	OverallDeliveryStatus:         whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`OverallDeliveryStatus`"},
	CreationDate:                  whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`CreationDate`"},
	CreationTime:                  whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`CreationTime`"},
	IssuingBlockReason:            whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IssuingBlockReason`"},
	ReceivingBlockReason:          whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`ReceivingBlockReason`"},
	GoodsIssueOrReceiptSlipNumber: whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`GoodsIssueOrReceiptSlipNumber`"},
	HeaderBillingStatus:           whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderBillingStatus`"},
	HeaderBillingConfStatus:       whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderBillingConfStatus`"},
	HeaderBillingBlockReason:      whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`HeaderBillingBlockReason`"},
	HeaderGrossWeight:             whereHelpernull_Float32{field: "`data_platform_delivery_document_header_data`.`HeaderGrossWeight`"},
	HeaderNetWeight:               whereHelpernull_Float32{field: "`data_platform_delivery_document_header_data`.`HeaderNetWeight`"},
	HeaderWeightUnit:              whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`HeaderWeightUnit`"},
	Incoterms:                     whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`Incoterms`"},
	IsExportImportDelivery:        whereHelpernull_Bool{field: "`data_platform_delivery_document_header_data`.`IsExportImportDelivery`"},
	LastChangeDate:                whereHelpernull_Time{field: "`data_platform_delivery_document_header_data`.`LastChangeDate`"},
	IssuingPlantBusinessPartner:   whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`IssuingPlantBusinessPartner`"},
	IssuingPlant:                  whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`IssuingPlant`"},
	ReceivingPlantBusinessPartner: whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`ReceivingPlantBusinessPartner`"},
	ReceivingPlant:                whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`ReceivingPlant`"},
	DeliverToParty:                whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`DeliverToParty`"},
	DeliverFromParty:              whereHelpernull_Int{field: "`data_platform_delivery_document_header_data`.`DeliverFromParty`"},
	TransactionCurrency:           whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`TransactionCurrency`"},
	OverallDelivReltdBillgStatus:  whereHelpernull_String{field: "`data_platform_delivery_document_header_data`.`OverallDelivReltdBillgStatus`"},
}

// DataPlatformDeliveryDocumentHeaderDatumRels is where relationship names are stored.
var DataPlatformDeliveryDocumentHeaderDatumRels = struct {
	BuyerDataPlatformBusinessPartnerGeneralDatum              string
	DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum   string
	DeliverToPartyDataPlatformBusinessPartnerGeneralDatum     string
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum string
	Incoterm                                                  string
	IssuingPlantDataPlatformPlantGeneralDatum                 string
	ReceivingPlantDataPlatformPlantGeneralDatum               string
	SellerDataPlatformBusinessPartnerGeneralDatum             string
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum      string
}{
	BuyerDataPlatformBusinessPartnerGeneralDatum:              "BuyerDataPlatformBusinessPartnerGeneralDatum",
	DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum:   "DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum",
	DeliverToPartyDataPlatformBusinessPartnerGeneralDatum:     "DeliverToPartyDataPlatformBusinessPartnerGeneralDatum",
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: "HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum",
	Incoterm: "Incoterm",
	IssuingPlantDataPlatformPlantGeneralDatum:            "IssuingPlantDataPlatformPlantGeneralDatum",
	ReceivingPlantDataPlatformPlantGeneralDatum:          "ReceivingPlantDataPlatformPlantGeneralDatum",
	SellerDataPlatformBusinessPartnerGeneralDatum:        "SellerDataPlatformBusinessPartnerGeneralDatum",
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum: "TransactionCurrencyDataPlatformCurrencyCurrencyDatum",
}

// dataPlatformDeliveryDocumentHeaderDatumR is where relationships are stored.
type dataPlatformDeliveryDocumentHeaderDatumR struct {
	BuyerDataPlatformBusinessPartnerGeneralDatum              *DataPlatformBusinessPartnerGeneralDatum   `boil:"BuyerDataPlatformBusinessPartnerGeneralDatum" json:"BuyerDataPlatformBusinessPartnerGeneralDatum" toml:"BuyerDataPlatformBusinessPartnerGeneralDatum" yaml:"BuyerDataPlatformBusinessPartnerGeneralDatum"`
	DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum   *DataPlatformBusinessPartnerGeneralDatum   `boil:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum" json:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum" toml:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum" yaml:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum"`
	DeliverToPartyDataPlatformBusinessPartnerGeneralDatum     *DataPlatformBusinessPartnerGeneralDatum   `boil:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum" json:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum" toml:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum" yaml:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum"`
	HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum `boil:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	Incoterm                                                  *DataPlatformIncotermsIncotermsDatum       `boil:"Incoterm" json:"Incoterm" toml:"Incoterm" yaml:"Incoterm"`
	IssuingPlantDataPlatformPlantGeneralDatum                 *DataPlatformPlantGeneralDatum             `boil:"IssuingPlantDataPlatformPlantGeneralDatum" json:"IssuingPlantDataPlatformPlantGeneralDatum" toml:"IssuingPlantDataPlatformPlantGeneralDatum" yaml:"IssuingPlantDataPlatformPlantGeneralDatum"`
	ReceivingPlantDataPlatformPlantGeneralDatum               *DataPlatformPlantGeneralDatum             `boil:"ReceivingPlantDataPlatformPlantGeneralDatum" json:"ReceivingPlantDataPlatformPlantGeneralDatum" toml:"ReceivingPlantDataPlatformPlantGeneralDatum" yaml:"ReceivingPlantDataPlatformPlantGeneralDatum"`
	SellerDataPlatformBusinessPartnerGeneralDatum             *DataPlatformBusinessPartnerGeneralDatum   `boil:"SellerDataPlatformBusinessPartnerGeneralDatum" json:"SellerDataPlatformBusinessPartnerGeneralDatum" toml:"SellerDataPlatformBusinessPartnerGeneralDatum" yaml:"SellerDataPlatformBusinessPartnerGeneralDatum"`
	TransactionCurrencyDataPlatformCurrencyCurrencyDatum      *DataPlatformCurrencyCurrencyDatum         `boil:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" json:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" toml:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum" yaml:"TransactionCurrencyDataPlatformCurrencyCurrencyDatum"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformDeliveryDocumentHeaderDatumR) NewStruct() *dataPlatformDeliveryDocumentHeaderDatumR {
	return &dataPlatformDeliveryDocumentHeaderDatumR{}
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetBuyerDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetDeliverToPartyDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetIncoterm() *DataPlatformIncotermsIncotermsDatum {
	if r == nil {
		return nil
	}
	return r.Incoterm
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetIssuingPlantDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.IssuingPlantDataPlatformPlantGeneralDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetReceivingPlantDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.ReceivingPlantDataPlatformPlantGeneralDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetSellerDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.SellerDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformDeliveryDocumentHeaderDatumR) GetTransactionCurrencyDataPlatformCurrencyCurrencyDatum() *DataPlatformCurrencyCurrencyDatum {
	if r == nil {
		return nil
	}
	return r.TransactionCurrencyDataPlatformCurrencyCurrencyDatum
}

// dataPlatformDeliveryDocumentHeaderDatumL is where Load methods for each relationship are stored.
type dataPlatformDeliveryDocumentHeaderDatumL struct{}

var (
	dataPlatformDeliveryDocumentHeaderDatumAllColumns            = []string{"DeliveryDocument", "Buyer", "Seller", "ReferenceDocument", "ReferenceDocumentItem", "OrderID", "OrderItem", "ContractType", "OrderValidityStartDate", "OrderValidityEndDate", "InvoiceScheduleStartDate", "InvoiceScheduleEndDate", "IssuingLocationTimeZone", "ReceivingLocationTimeZone", "DocumentDate", "PlannedGoodsIssueDate", "PlannedGoodsIssueTime", "PlannedGoodsReceiptDate", "PlannedGoodsReceiptTime", "BillingDocumentDate", "CompleteDeliveryIsDefined", "OverallDeliveryStatus", "CreationDate", "CreationTime", "IssuingBlockReason", "ReceivingBlockReason", "GoodsIssueOrReceiptSlipNumber", "HeaderBillingStatus", "HeaderBillingConfStatus", "HeaderBillingBlockReason", "HeaderGrossWeight", "HeaderNetWeight", "HeaderWeightUnit", "Incoterms", "IsExportImportDelivery", "LastChangeDate", "IssuingPlantBusinessPartner", "IssuingPlant", "ReceivingPlantBusinessPartner", "ReceivingPlant", "DeliverToParty", "DeliverFromParty", "TransactionCurrency", "OverallDelivReltdBillgStatus"}
	dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault = []string{"DeliveryDocument", "Buyer", "Seller", "ReferenceDocument", "ReferenceDocumentItem", "OrderID", "OrderItem", "ContractType", "OrderValidityStartDate", "OrderValidityEndDate", "InvoiceScheduleStartDate", "InvoiceScheduleEndDate", "IssuingLocationTimeZone", "ReceivingLocationTimeZone", "DocumentDate", "PlannedGoodsIssueDate", "PlannedGoodsIssueTime", "PlannedGoodsReceiptDate", "PlannedGoodsReceiptTime", "BillingDocumentDate", "CompleteDeliveryIsDefined", "OverallDeliveryStatus", "CreationDate", "CreationTime", "IssuingBlockReason", "ReceivingBlockReason", "GoodsIssueOrReceiptSlipNumber", "HeaderBillingStatus", "HeaderBillingConfStatus", "HeaderBillingBlockReason", "HeaderGrossWeight", "HeaderNetWeight", "HeaderWeightUnit", "Incoterms", "IsExportImportDelivery", "LastChangeDate", "IssuingPlantBusinessPartner", "IssuingPlant", "ReceivingPlantBusinessPartner", "ReceivingPlant", "DeliverToParty", "DeliverFromParty", "TransactionCurrency", "OverallDelivReltdBillgStatus"}
	dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault    = []string{}
	dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns     = []string{"DeliveryDocument"}
	dataPlatformDeliveryDocumentHeaderDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformDeliveryDocumentHeaderDatumSlice is an alias for a slice of pointers to DataPlatformDeliveryDocumentHeaderDatum.
	// This should almost always be used instead of []DataPlatformDeliveryDocumentHeaderDatum.
	DataPlatformDeliveryDocumentHeaderDatumSlice []*DataPlatformDeliveryDocumentHeaderDatum
	// DataPlatformDeliveryDocumentHeaderDatumHook is the signature for custom DataPlatformDeliveryDocumentHeaderDatum hook methods
	DataPlatformDeliveryDocumentHeaderDatumHook func(context.Context, boil.ContextExecutor, *DataPlatformDeliveryDocumentHeaderDatum) error

	dataPlatformDeliveryDocumentHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformDeliveryDocumentHeaderDatumType                 = reflect.TypeOf(&DataPlatformDeliveryDocumentHeaderDatum{})
	dataPlatformDeliveryDocumentHeaderDatumMapping              = queries.MakeStructMapping(dataPlatformDeliveryDocumentHeaderDatumType)
	dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns)
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumInsertCache          = make(map[string]insertCache)
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut       sync.RWMutex
	dataPlatformDeliveryDocumentHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dataPlatformDeliveryDocumentHeaderDatumAfterSelectHooks []DataPlatformDeliveryDocumentHeaderDatumHook

var dataPlatformDeliveryDocumentHeaderDatumBeforeInsertHooks []DataPlatformDeliveryDocumentHeaderDatumHook
var dataPlatformDeliveryDocumentHeaderDatumAfterInsertHooks []DataPlatformDeliveryDocumentHeaderDatumHook

var dataPlatformDeliveryDocumentHeaderDatumBeforeUpdateHooks []DataPlatformDeliveryDocumentHeaderDatumHook
var dataPlatformDeliveryDocumentHeaderDatumAfterUpdateHooks []DataPlatformDeliveryDocumentHeaderDatumHook

var dataPlatformDeliveryDocumentHeaderDatumBeforeDeleteHooks []DataPlatformDeliveryDocumentHeaderDatumHook
var dataPlatformDeliveryDocumentHeaderDatumAfterDeleteHooks []DataPlatformDeliveryDocumentHeaderDatumHook

var dataPlatformDeliveryDocumentHeaderDatumBeforeUpsertHooks []DataPlatformDeliveryDocumentHeaderDatumHook
var dataPlatformDeliveryDocumentHeaderDatumAfterUpsertHooks []DataPlatformDeliveryDocumentHeaderDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DataPlatformDeliveryDocumentHeaderDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformDeliveryDocumentHeaderDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDataPlatformDeliveryDocumentHeaderDatumHook registers your hook function for all future operations.
func AddDataPlatformDeliveryDocumentHeaderDatumHook(hookPoint boil.HookPoint, dataPlatformDeliveryDocumentHeaderDatumHook DataPlatformDeliveryDocumentHeaderDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		dataPlatformDeliveryDocumentHeaderDatumAfterSelectHooks = append(dataPlatformDeliveryDocumentHeaderDatumAfterSelectHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.BeforeInsertHook:
		dataPlatformDeliveryDocumentHeaderDatumBeforeInsertHooks = append(dataPlatformDeliveryDocumentHeaderDatumBeforeInsertHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.AfterInsertHook:
		dataPlatformDeliveryDocumentHeaderDatumAfterInsertHooks = append(dataPlatformDeliveryDocumentHeaderDatumAfterInsertHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.BeforeUpdateHook:
		dataPlatformDeliveryDocumentHeaderDatumBeforeUpdateHooks = append(dataPlatformDeliveryDocumentHeaderDatumBeforeUpdateHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.AfterUpdateHook:
		dataPlatformDeliveryDocumentHeaderDatumAfterUpdateHooks = append(dataPlatformDeliveryDocumentHeaderDatumAfterUpdateHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.BeforeDeleteHook:
		dataPlatformDeliveryDocumentHeaderDatumBeforeDeleteHooks = append(dataPlatformDeliveryDocumentHeaderDatumBeforeDeleteHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.AfterDeleteHook:
		dataPlatformDeliveryDocumentHeaderDatumAfterDeleteHooks = append(dataPlatformDeliveryDocumentHeaderDatumAfterDeleteHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.BeforeUpsertHook:
		dataPlatformDeliveryDocumentHeaderDatumBeforeUpsertHooks = append(dataPlatformDeliveryDocumentHeaderDatumBeforeUpsertHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	case boil.AfterUpsertHook:
		dataPlatformDeliveryDocumentHeaderDatumAfterUpsertHooks = append(dataPlatformDeliveryDocumentHeaderDatumAfterUpsertHooks, dataPlatformDeliveryDocumentHeaderDatumHook)
	}
}

// One returns a single dataPlatformDeliveryDocumentHeaderDatum record from the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformDeliveryDocumentHeaderDatum, error) {
	o := &DataPlatformDeliveryDocumentHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_delivery_document_header_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DataPlatformDeliveryDocumentHeaderDatum records from the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformDeliveryDocumentHeaderDatumSlice, error) {
	var o []*DataPlatformDeliveryDocumentHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformDeliveryDocumentHeaderDatum slice")
	}

	if len(dataPlatformDeliveryDocumentHeaderDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DataPlatformDeliveryDocumentHeaderDatum records in the query.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_delivery_document_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_delivery_document_header_data exists")
	}

	return count > 0, nil
}

// BuyerDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) BuyerDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// DeliverToPartyDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) DeliverToPartyDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.HeaderWeightUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// Incoterm pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Incoterm(mods ...qm.QueryMod) dataPlatformIncotermsIncotermsDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Incoterms` = ?", o.Incoterms),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformIncotermsIncotermsData(queryMods...)
}

// IssuingPlantDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) IssuingPlantDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Plant` = ?", o.IssuingPlant),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// ReceivingPlantDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) ReceivingPlantDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Plant` = ?", o.ReceivingPlant),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// SellerDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SellerDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.Seller),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// TransactionCurrencyDataPlatformCurrencyCurrencyDatum pointed to by the foreign key.
func (o *DataPlatformDeliveryDocumentHeaderDatum) TransactionCurrencyDataPlatformCurrencyCurrencyDatum(mods ...qm.QueryMod) dataPlatformCurrencyCurrencyDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Currency` = ?", o.TransactionCurrency),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCurrencyCurrencyData(queryMods...)
}

// LoadBuyerDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadBuyerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Buyer) {
			args = append(args, object.Buyer)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Buyer) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Buyer) {
				args = append(args, obj.Buyer)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(dataPlatformBusinessPartnerGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformBusinessPartnerGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
		}
		foreign.R.BuyerDataPlatformDeliveryDocumentHeaderData = append(foreign.R.BuyerDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Buyer, foreign.BusinessPartner) {
				local.R.BuyerDataPlatformBusinessPartnerGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
				}
				foreign.R.BuyerDataPlatformDeliveryDocumentHeaderData = append(foreign.R.BuyerDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.DeliverFromParty) {
			args = append(args, object.DeliverFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromParty) {
				args = append(args, obj.DeliverFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(dataPlatformBusinessPartnerGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
		}
		foreign.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData = append(foreign.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromParty, foreign.BusinessPartner) {
				local.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
				}
				foreign.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData = append(foreign.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadDeliverToPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.DeliverToParty) {
			args = append(args, object.DeliverToParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverToParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverToParty) {
				args = append(args, obj.DeliverToParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(dataPlatformBusinessPartnerGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
		}
		foreign.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData = append(foreign.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverToParty, foreign.BusinessPartner) {
				local.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
				}
				foreign.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData = append(foreign.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.HeaderWeightUnit) {
			args = append(args, object.HeaderWeightUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.HeaderWeightUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.HeaderWeightUnit) {
				args = append(args, obj.HeaderWeightUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(dataPlatformQuantityUnitQuantityUnitDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
		}
		foreign.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData = append(foreign.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.HeaderWeightUnit, foreign.QuantityUnit) {
				local.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
				}
				foreign.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData = append(foreign.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadIncoterm allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadIncoterm(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Incoterms) {
			args = append(args, object.Incoterms)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Incoterms) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Incoterms) {
				args = append(args, obj.Incoterms)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_incoterms_incoterms_data`),
		qm.WhereIn(`data_platform_incoterms_incoterms_data.Incoterms in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformIncotermsIncotermsDatum")
	}

	var resultSlice []*DataPlatformIncotermsIncotermsDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformIncotermsIncotermsDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_incoterms_incoterms_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_incoterms_incoterms_data")
	}

	if len(dataPlatformIncotermsIncotermsDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Incoterm = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformIncotermsIncotermsDatumR{}
		}
		foreign.R.IncotermDataPlatformDeliveryDocumentHeaderData = append(foreign.R.IncotermDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Incoterms, foreign.Incoterms) {
				local.R.Incoterm = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformIncotermsIncotermsDatumR{}
				}
				foreign.R.IncotermDataPlatformDeliveryDocumentHeaderData = append(foreign.R.IncotermDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadIssuingPlantDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadIssuingPlantDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.IssuingPlant) {
			args = append(args, object.IssuingPlant)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.IssuingPlant) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.IssuingPlant) {
				args = append(args, obj.IssuingPlant)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.Plant in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(dataPlatformPlantGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IssuingPlantDataPlatformPlantGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformPlantGeneralDatumR{}
		}
		foreign.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData = append(foreign.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.IssuingPlant, foreign.Plant) {
				local.R.IssuingPlantDataPlatformPlantGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformPlantGeneralDatumR{}
				}
				foreign.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData = append(foreign.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadReceivingPlantDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadReceivingPlantDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.ReceivingPlant) {
			args = append(args, object.ReceivingPlant)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ReceivingPlant) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ReceivingPlant) {
				args = append(args, obj.ReceivingPlant)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.Plant in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(dataPlatformPlantGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ReceivingPlantDataPlatformPlantGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformPlantGeneralDatumR{}
		}
		foreign.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData = append(foreign.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ReceivingPlant, foreign.Plant) {
				local.R.ReceivingPlantDataPlatformPlantGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformPlantGeneralDatumR{}
				}
				foreign.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData = append(foreign.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadSellerDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadSellerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.Seller) {
			args = append(args, object.Seller)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Seller) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Seller) {
				args = append(args, obj.Seller)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(dataPlatformBusinessPartnerGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SellerDataPlatformBusinessPartnerGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
		}
		foreign.R.SellerDataPlatformDeliveryDocumentHeaderData = append(foreign.R.SellerDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Seller, foreign.BusinessPartner) {
				local.R.SellerDataPlatformBusinessPartnerGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
				}
				foreign.R.SellerDataPlatformDeliveryDocumentHeaderData = append(foreign.R.SellerDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// LoadTransactionCurrencyDataPlatformCurrencyCurrencyDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformDeliveryDocumentHeaderDatumL) LoadTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformDeliveryDocumentHeaderDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformDeliveryDocumentHeaderDatum
	var object *DataPlatformDeliveryDocumentHeaderDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformDeliveryDocumentHeaderDatum.(*DataPlatformDeliveryDocumentHeaderDatum)
		if !ok {
			object = new(DataPlatformDeliveryDocumentHeaderDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformDeliveryDocumentHeaderDatum.(*[]*DataPlatformDeliveryDocumentHeaderDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformDeliveryDocumentHeaderDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformDeliveryDocumentHeaderDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
		}
		if !queries.IsNil(object.TransactionCurrency) {
			args = append(args, object.TransactionCurrency)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformDeliveryDocumentHeaderDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.TransactionCurrency) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.TransactionCurrency) {
				args = append(args, obj.TransactionCurrency)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_currency_currency_data`),
		qm.WhereIn(`data_platform_currency_currency_data.Currency in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCurrencyCurrencyDatum")
	}

	var resultSlice []*DataPlatformCurrencyCurrencyDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCurrencyCurrencyDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_currency_currency_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_currency_currency_data")
	}

	if len(dataPlatformCurrencyCurrencyDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformCurrencyCurrencyDatumR{}
		}
		foreign.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData = append(foreign.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TransactionCurrency, foreign.Currency) {
				local.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformCurrencyCurrencyDatumR{}
				}
				foreign.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData = append(foreign.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData, local)
				break
			}
		}
	}

	return nil
}

// SetBuyerDataPlatformBusinessPartnerGeneralDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.BuyerDataPlatformBusinessPartnerGeneralDatum to related.
// Adds o to related.R.BuyerDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetBuyerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Buyer, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			BuyerDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformBusinessPartnerGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformBusinessPartnerGeneralDatumR{
			BuyerDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.BuyerDataPlatformDeliveryDocumentHeaderData = append(related.R.BuyerDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveBuyerDataPlatformBusinessPartnerGeneralDatum relationship.
// Sets o.R.BuyerDataPlatformBusinessPartnerGeneralDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveBuyerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error

	queries.SetScanner(&o.Buyer, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("Buyer")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BuyerDataPlatformBusinessPartnerGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BuyerDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.Buyer, ri.Buyer) {
			continue
		}

		ln := len(related.R.BuyerDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.BuyerDataPlatformDeliveryDocumentHeaderData[i] = related.R.BuyerDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.BuyerDataPlatformDeliveryDocumentHeaderData = related.R.BuyerDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum to related.
// Adds o to related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformBusinessPartnerGeneralDatumR{
			DeliverFromPartyDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData = append(related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum relationship.
// Sets o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromParty, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("DeliverFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.DeliverFromParty, ri.DeliverFromParty) {
			continue
		}

		ln := len(related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData[i] = related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData = related.R.DeliverFromPartyDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetDeliverToPartyDataPlatformBusinessPartnerGeneralDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum to related.
// Adds o to related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetDeliverToPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverToParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			DeliverToPartyDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformBusinessPartnerGeneralDatumR{
			DeliverToPartyDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData = append(related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveDeliverToPartyDataPlatformBusinessPartnerGeneralDatum relationship.
// Sets o.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveDeliverToPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error

	queries.SetScanner(&o.DeliverToParty, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("DeliverToParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.DeliverToParty, ri.DeliverToParty) {
			continue
		}

		ln := len(related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData[i] = related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData = related.R.DeliverToPartyDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
// Adds o to related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"HeaderWeightUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.HeaderWeightUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformQuantityUnitQuantityUnitDatumR{
			HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData = append(related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveHeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.HeaderWeightUnit, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("HeaderWeightUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.HeaderWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.HeaderWeightUnit, ri.HeaderWeightUnit) {
			continue
		}

		ln := len(related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData[i] = related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData = related.R.HeaderWeightUnitDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetIncoterm of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.Incoterm to related.
// Adds o to related.R.IncotermDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetIncoterm(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Incoterms"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Incoterms, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Incoterms, related.Incoterms)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			Incoterm: related,
		}
	} else {
		o.R.Incoterm = related
	}

	if related.R == nil {
		related.R = &dataPlatformIncotermsIncotermsDatumR{
			IncotermDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.IncotermDataPlatformDeliveryDocumentHeaderData = append(related.R.IncotermDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveIncoterm relationship.
// Sets o.R.Incoterm to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveIncoterm(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error

	queries.SetScanner(&o.Incoterms, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("Incoterms")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Incoterm = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.IncotermDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.Incoterms, ri.Incoterms) {
			continue
		}

		ln := len(related.R.IncotermDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.IncotermDataPlatformDeliveryDocumentHeaderData[i] = related.R.IncotermDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.IncotermDataPlatformDeliveryDocumentHeaderData = related.R.IncotermDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetIssuingPlantDataPlatformPlantGeneralDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.IssuingPlantDataPlatformPlantGeneralDatum to related.
// Adds o to related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetIssuingPlantDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"IssuingPlant"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Plant, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.IssuingPlant, related.Plant)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			IssuingPlantDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.IssuingPlantDataPlatformPlantGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformPlantGeneralDatumR{
			IssuingPlantDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData = append(related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveIssuingPlantDataPlatformPlantGeneralDatum relationship.
// Sets o.R.IssuingPlantDataPlatformPlantGeneralDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveIssuingPlantDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantGeneralDatum) error {
	var err error

	queries.SetScanner(&o.IssuingPlant, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("IssuingPlant")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.IssuingPlantDataPlatformPlantGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.IssuingPlant, ri.IssuingPlant) {
			continue
		}

		ln := len(related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData[i] = related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData = related.R.IssuingPlantDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetReceivingPlantDataPlatformPlantGeneralDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.ReceivingPlantDataPlatformPlantGeneralDatum to related.
// Adds o to related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetReceivingPlantDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ReceivingPlant"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Plant, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ReceivingPlant, related.Plant)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			ReceivingPlantDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.ReceivingPlantDataPlatformPlantGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformPlantGeneralDatumR{
			ReceivingPlantDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData = append(related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveReceivingPlantDataPlatformPlantGeneralDatum relationship.
// Sets o.R.ReceivingPlantDataPlatformPlantGeneralDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveReceivingPlantDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantGeneralDatum) error {
	var err error

	queries.SetScanner(&o.ReceivingPlant, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("ReceivingPlant")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ReceivingPlantDataPlatformPlantGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.ReceivingPlant, ri.ReceivingPlant) {
			continue
		}

		ln := len(related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData[i] = related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData = related.R.ReceivingPlantDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetSellerDataPlatformBusinessPartnerGeneralDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.SellerDataPlatformBusinessPartnerGeneralDatum to related.
// Adds o to related.R.SellerDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetSellerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Seller"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Seller, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			SellerDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.SellerDataPlatformBusinessPartnerGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformBusinessPartnerGeneralDatumR{
			SellerDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.SellerDataPlatformDeliveryDocumentHeaderData = append(related.R.SellerDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveSellerDataPlatformBusinessPartnerGeneralDatum relationship.
// Sets o.R.SellerDataPlatformBusinessPartnerGeneralDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveSellerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error

	queries.SetScanner(&o.Seller, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("Seller")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SellerDataPlatformBusinessPartnerGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SellerDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.Seller, ri.Seller) {
			continue
		}

		ln := len(related.R.SellerDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.SellerDataPlatformDeliveryDocumentHeaderData[i] = related.R.SellerDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.SellerDataPlatformDeliveryDocumentHeaderData = related.R.SellerDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// SetTransactionCurrencyDataPlatformCurrencyCurrencyDatum of the dataPlatformDeliveryDocumentHeaderDatum to the related item.
// Sets o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum to related.
// Adds o to related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformDeliveryDocumentHeaderDatum) SetTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCurrencyCurrencyDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"TransactionCurrency"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Currency, o.DeliveryDocument}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TransactionCurrency, related.Currency)
	if o.R == nil {
		o.R = &dataPlatformDeliveryDocumentHeaderDatumR{
			TransactionCurrencyDataPlatformCurrencyCurrencyDatum: related,
		}
	} else {
		o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformCurrencyCurrencyDatumR{
			TransactionCurrencyDataPlatformDeliveryDocumentHeaderData: DataPlatformDeliveryDocumentHeaderDatumSlice{o},
		}
	} else {
		related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData = append(related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData, o)
	}

	return nil
}

// RemoveTransactionCurrencyDataPlatformCurrencyCurrencyDatum relationship.
// Sets o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformDeliveryDocumentHeaderDatum) RemoveTransactionCurrencyDataPlatformCurrencyCurrencyDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCurrencyCurrencyDatum) error {
	var err error

	queries.SetScanner(&o.TransactionCurrency, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("TransactionCurrency")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.TransactionCurrencyDataPlatformCurrencyCurrencyDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData {
		if queries.Equal(o.TransactionCurrency, ri.TransactionCurrency) {
			continue
		}

		ln := len(related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData)
		if ln > 1 && i < ln-1 {
			related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData[i] = related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData[ln-1]
		}
		related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData = related.R.TransactionCurrencyDataPlatformDeliveryDocumentHeaderData[:ln-1]
		break
	}
	return nil
}

// DataPlatformDeliveryDocumentHeaderData retrieves all the records using an executor.
func DataPlatformDeliveryDocumentHeaderData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDatumQuery {
	mods = append(mods, qm.From("`data_platform_delivery_document_header_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_delivery_document_header_data`.*"})
	}

	return dataPlatformDeliveryDocumentHeaderDatumQuery{q}
}

// FindDataPlatformDeliveryDocumentHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformDeliveryDocumentHeaderDatum(ctx context.Context, exec boil.ContextExecutor, deliveryDocument int, selectCols ...string) (*DataPlatformDeliveryDocumentHeaderDatum, error) {
	dataPlatformDeliveryDocumentHeaderDatumObj := &DataPlatformDeliveryDocumentHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_delivery_document_header_data` where `DeliveryDocument`=?", sel,
	)

	q := queries.Raw(query, deliveryDocument)

	err := q.Bind(ctx, exec, dataPlatformDeliveryDocumentHeaderDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_delivery_document_header_data")
	}

	if err = dataPlatformDeliveryDocumentHeaderDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return dataPlatformDeliveryDocumentHeaderDatumObj, err
	}

	return dataPlatformDeliveryDocumentHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_delivery_document_header_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumInsertCache[key]
	dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_delivery_document_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_delivery_document_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_delivery_document_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_delivery_document_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.DeliveryDocument,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_delivery_document_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumInsertCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DataPlatformDeliveryDocumentHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumUpdateCache[key]
	dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update data_platform_delivery_document_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, append(wl, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update data_platform_delivery_document_header_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for data_platform_delivery_document_header_data")
	}

	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumUpdateCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for data_platform_delivery_document_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for data_platform_delivery_document_header_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformDeliveryDocumentHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in dataPlatformDeliveryDocumentHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all dataPlatformDeliveryDocumentHeaderDatum")
	}
	return rowsAff, nil
}

var mySQLDataPlatformDeliveryDocumentHeaderDatumUniqueColumns = []string{
	"DeliveryDocument",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_delivery_document_header_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformDeliveryDocumentHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformDeliveryDocumentHeaderDatumUpsertCache[key]
	dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithDefault,
			dataPlatformDeliveryDocumentHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformDeliveryDocumentHeaderDatumAllColumns,
			dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_delivery_document_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_delivery_document_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_delivery_document_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_delivery_document_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformDeliveryDocumentHeaderDatumType, dataPlatformDeliveryDocumentHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_delivery_document_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_delivery_document_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.Lock()
		dataPlatformDeliveryDocumentHeaderDatumUpsertCache[key] = cache
		dataPlatformDeliveryDocumentHeaderDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DataPlatformDeliveryDocumentHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no DataPlatformDeliveryDocumentHeaderDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_delivery_document_header_data` WHERE `DeliveryDocument`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from data_platform_delivery_document_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for data_platform_delivery_document_header_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformDeliveryDocumentHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no dataPlatformDeliveryDocumentHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from data_platform_delivery_document_header_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for data_platform_delivery_document_header_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformDeliveryDocumentHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(dataPlatformDeliveryDocumentHeaderDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_delivery_document_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from dataPlatformDeliveryDocumentHeaderDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for data_platform_delivery_document_header_data")
	}

	if len(dataPlatformDeliveryDocumentHeaderDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformDeliveryDocumentHeaderDatum(ctx, exec, o.DeliveryDocument)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformDeliveryDocumentHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformDeliveryDocumentHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_delivery_document_header_data`.* FROM `data_platform_delivery_document_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformDeliveryDocumentHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformDeliveryDocumentHeaderDatumExists checks if the DataPlatformDeliveryDocumentHeaderDatum row exists.
func DataPlatformDeliveryDocumentHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, deliveryDocument int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_delivery_document_header_data` where `DeliveryDocument`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, deliveryDocument)
	}
	row := exec.QueryRowContext(ctx, sql, deliveryDocument)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_delivery_document_header_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformDeliveryDocumentHeaderDatum row exists.
func (o *DataPlatformDeliveryDocumentHeaderDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformDeliveryDocumentHeaderDatumExists(ctx, exec, o.DeliveryDocument)
}
