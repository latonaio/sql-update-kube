// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformProductionOrderItemDatum is an object representing the database table.
type DataPlatformProductionOrderItemDatum struct {
	ProductionOrder                               int          `boil:"ProductionOrder" json:"ProductionOrder" toml:"ProductionOrder" yaml:"ProductionOrder"`
	ProductionOrderItem                           int          `boil:"ProductionOrderItem" json:"ProductionOrderItem" toml:"ProductionOrderItem" yaml:"ProductionOrderItem"`
	PrecedingProductionOrderItem                  null.Int     `boil:"PrecedingProductionOrderItem" json:"PrecedingProductionOrderItem,omitempty" toml:"PrecedingProductionOrderItem" yaml:"PrecedingProductionOrderItem,omitempty"`
	FollowingProductionOrderItem                  null.Int     `boil:"FollowingProductionOrderItem" json:"FollowingProductionOrderItem,omitempty" toml:"FollowingProductionOrderItem" yaml:"FollowingProductionOrderItem,omitempty"`
	SupplyChainRelationshipID                     int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipProductionPlantID      int          `boil:"SupplyChainRelationshipProductionPlantID" json:"SupplyChainRelationshipProductionPlantID" toml:"SupplyChainRelationshipProductionPlantID" yaml:"SupplyChainRelationshipProductionPlantID"`
	SupplyChainRelationshipDeliveryID             int          `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID"`
	SupplyChainRelationshipDeliveryPlantID        int          `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID"`
	ProductionOrderType                           string       `boil:"ProductionOrderType" json:"ProductionOrderType" toml:"ProductionOrderType" yaml:"ProductionOrderType"`
	Product                                       string       `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	Buyer                                         int          `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Seller                                        int          `boil:"Seller" json:"Seller" toml:"Seller" yaml:"Seller"`
	ProductionPlantBusinessPartner                int          `boil:"ProductionPlantBusinessPartner" json:"ProductionPlantBusinessPartner" toml:"ProductionPlantBusinessPartner" yaml:"ProductionPlantBusinessPartner"`
	ProductionPlant                               string       `boil:"ProductionPlant" json:"ProductionPlant" toml:"ProductionPlant" yaml:"ProductionPlant"`
	ProductionPlantStorageLocation                string       `boil:"ProductionPlantStorageLocation" json:"ProductionPlantStorageLocation" toml:"ProductionPlantStorageLocation" yaml:"ProductionPlantStorageLocation"`
	DeliverFromParty                              int          `boil:"DeliverFromParty" json:"DeliverFromParty" toml:"DeliverFromParty" yaml:"DeliverFromParty"`
	DeliverFromPlant                              string       `boil:"DeliverFromPlant" json:"DeliverFromPlant" toml:"DeliverFromPlant" yaml:"DeliverFromPlant"`
	DeliverFromPlantStorageLocation               string       `boil:"DeliverFromPlantStorageLocation" json:"DeliverFromPlantStorageLocation" toml:"DeliverFromPlantStorageLocation" yaml:"DeliverFromPlantStorageLocation"`
	DeliverToParty                                int          `boil:"DeliverToParty" json:"DeliverToParty" toml:"DeliverToParty" yaml:"DeliverToParty"`
	DeliverToPlant                                string       `boil:"DeliverToPlant" json:"DeliverToPlant" toml:"DeliverToPlant" yaml:"DeliverToPlant"`
	DeliverToPlantStorageLocation                 string       `boil:"DeliverToPlantStorageLocation" json:"DeliverToPlantStorageLocation" toml:"DeliverToPlantStorageLocation" yaml:"DeliverToPlantStorageLocation"`
	ProductBaseUnit                               string       `boil:"ProductBaseUnit" json:"ProductBaseUnit" toml:"ProductBaseUnit" yaml:"ProductBaseUnit"`
	ProductProductionUnit                         string       `boil:"ProductProductionUnit" json:"ProductProductionUnit" toml:"ProductProductionUnit" yaml:"ProductProductionUnit"`
	ProductDeliveryUnit                           string       `boil:"ProductDeliveryUnit" json:"ProductDeliveryUnit" toml:"ProductDeliveryUnit" yaml:"ProductDeliveryUnit"`
	MRPArea                                       null.String  `boil:"MRPArea" json:"MRPArea,omitempty" toml:"MRPArea" yaml:"MRPArea,omitempty"`
	MRPController                                 null.String  `boil:"MRPController" json:"MRPController,omitempty" toml:"MRPController" yaml:"MRPController,omitempty"`
	ProductionVersion                             null.Int     `boil:"ProductionVersion" json:"ProductionVersion,omitempty" toml:"ProductionVersion" yaml:"ProductionVersion,omitempty"`
	ProductionVersionItem                         null.Int     `boil:"ProductionVersionItem" json:"ProductionVersionItem,omitempty" toml:"ProductionVersionItem" yaml:"ProductionVersionItem,omitempty"`
	BillOfMaterial                                int          `boil:"BillOfMaterial" json:"BillOfMaterial" toml:"BillOfMaterial" yaml:"BillOfMaterial"`
	Operations                                    int          `boil:"Operations" json:"Operations" toml:"Operations" yaml:"Operations"`
	ProductionOrderQuantityInBaseUnit             float32      `boil:"ProductionOrderQuantityInBaseUnit" json:"ProductionOrderQuantityInBaseUnit" toml:"ProductionOrderQuantityInBaseUnit" yaml:"ProductionOrderQuantityInBaseUnit"`
	ProductionOrderQuantityInProductionUnit       float32      `boil:"ProductionOrderQuantityInProductionUnit" json:"ProductionOrderQuantityInProductionUnit" toml:"ProductionOrderQuantityInProductionUnit" yaml:"ProductionOrderQuantityInProductionUnit"`
	ProductionOrderQuantityInDeliveryUnit         float32      `boil:"ProductionOrderQuantityInDeliveryUnit" json:"ProductionOrderQuantityInDeliveryUnit" toml:"ProductionOrderQuantityInDeliveryUnit" yaml:"ProductionOrderQuantityInDeliveryUnit"`
	ProductionOrderPlannedScrapQtyInBaseUnit      null.Float32 `boil:"ProductionOrderPlannedScrapQtyInBaseUnit" json:"ProductionOrderPlannedScrapQtyInBaseUnit,omitempty" toml:"ProductionOrderPlannedScrapQtyInBaseUnit" yaml:"ProductionOrderPlannedScrapQtyInBaseUnit,omitempty"`
	ProductionOrderMinimumLotSizeQuantity         float32      `boil:"ProductionOrderMinimumLotSizeQuantity" json:"ProductionOrderMinimumLotSizeQuantity" toml:"ProductionOrderMinimumLotSizeQuantity" yaml:"ProductionOrderMinimumLotSizeQuantity"`
	ProductionOrderStandardLotSizeQuantity        float32      `boil:"ProductionOrderStandardLotSizeQuantity" json:"ProductionOrderStandardLotSizeQuantity" toml:"ProductionOrderStandardLotSizeQuantity" yaml:"ProductionOrderStandardLotSizeQuantity"`
	ProductionOrderMaximumLotSizeQuantity         float32      `boil:"ProductionOrderMaximumLotSizeQuantity" json:"ProductionOrderMaximumLotSizeQuantity" toml:"ProductionOrderMaximumLotSizeQuantity" yaml:"ProductionOrderMaximumLotSizeQuantity"`
	ProductionOrderLotSizeRoundingQuantity        null.Float32 `boil:"ProductionOrderLotSizeRoundingQuantity" json:"ProductionOrderLotSizeRoundingQuantity,omitempty" toml:"ProductionOrderLotSizeRoundingQuantity" yaml:"ProductionOrderLotSizeRoundingQuantity,omitempty"`
	ProductionOrderLotSizeIsFixed                 null.Bool    `boil:"ProductionOrderLotSizeIsFixed" json:"ProductionOrderLotSizeIsFixed,omitempty" toml:"ProductionOrderLotSizeIsFixed" yaml:"ProductionOrderLotSizeIsFixed,omitempty"`
	ProductionOrderPlannedStartDate               string       `boil:"ProductionOrderPlannedStartDate" json:"ProductionOrderPlannedStartDate" toml:"ProductionOrderPlannedStartDate" yaml:"ProductionOrderPlannedStartDate"`
	ProductionOrderPlannedStartTime               string       `boil:"ProductionOrderPlannedStartTime" json:"ProductionOrderPlannedStartTime" toml:"ProductionOrderPlannedStartTime" yaml:"ProductionOrderPlannedStartTime"`
	ProductionOrderPlannedEndDate                 string       `boil:"ProductionOrderPlannedEndDate" json:"ProductionOrderPlannedEndDate" toml:"ProductionOrderPlannedEndDate" yaml:"ProductionOrderPlannedEndDate"`
	ProductionOrderPlannedEndTime                 string       `boil:"ProductionOrderPlannedEndTime" json:"ProductionOrderPlannedEndTime" toml:"ProductionOrderPlannedEndTime" yaml:"ProductionOrderPlannedEndTime"`
	ProductionOrderActualReleaseDate              null.String  `boil:"ProductionOrderActualReleaseDate" json:"ProductionOrderActualReleaseDate,omitempty" toml:"ProductionOrderActualReleaseDate" yaml:"ProductionOrderActualReleaseDate,omitempty"`
	ProductionOrderActualReleaseTime              null.String  `boil:"ProductionOrderActualReleaseTime" json:"ProductionOrderActualReleaseTime,omitempty" toml:"ProductionOrderActualReleaseTime" yaml:"ProductionOrderActualReleaseTime,omitempty"`
	ProductionOrderActualStartDate                null.String  `boil:"ProductionOrderActualStartDate" json:"ProductionOrderActualStartDate,omitempty" toml:"ProductionOrderActualStartDate" yaml:"ProductionOrderActualStartDate,omitempty"`
	ProductionOrderActualStartTime                null.String  `boil:"ProductionOrderActualStartTime" json:"ProductionOrderActualStartTime,omitempty" toml:"ProductionOrderActualStartTime" yaml:"ProductionOrderActualStartTime,omitempty"`
	ProductionOrderActualEndDate                  null.String  `boil:"ProductionOrderActualEndDate" json:"ProductionOrderActualEndDate,omitempty" toml:"ProductionOrderActualEndDate" yaml:"ProductionOrderActualEndDate,omitempty"`
	ProductionOrderActualEndTime                  null.String  `boil:"ProductionOrderActualEndTime" json:"ProductionOrderActualEndTime,omitempty" toml:"ProductionOrderActualEndTime" yaml:"ProductionOrderActualEndTime,omitempty"`
	ConfirmedYieldQuantityInBaseUnit              null.Float32 `boil:"ConfirmedYieldQuantityInBaseUnit" json:"ConfirmedYieldQuantityInBaseUnit,omitempty" toml:"ConfirmedYieldQuantityInBaseUnit" yaml:"ConfirmedYieldQuantityInBaseUnit,omitempty"`
	ConfirmedYieldQuantityInProductionUnit        null.Float32 `boil:"ConfirmedYieldQuantityInProductionUnit" json:"ConfirmedYieldQuantityInProductionUnit,omitempty" toml:"ConfirmedYieldQuantityInProductionUnit" yaml:"ConfirmedYieldQuantityInProductionUnit,omitempty"`
	ScrappedQuantityInBaseUnit                    null.Float32 `boil:"ScrappedQuantityInBaseUnit" json:"ScrappedQuantityInBaseUnit,omitempty" toml:"ScrappedQuantityInBaseUnit" yaml:"ScrappedQuantityInBaseUnit,omitempty"`
	PlannedOrder                                  null.Int     `boil:"PlannedOrder" json:"PlannedOrder,omitempty" toml:"PlannedOrder" yaml:"PlannedOrder,omitempty"`
	PlannedOrderItem                              null.Int     `boil:"PlannedOrderItem" json:"PlannedOrderItem,omitempty" toml:"PlannedOrderItem" yaml:"PlannedOrderItem,omitempty"`
	OrderID                                       null.Int     `boil:"OrderID" json:"OrderID,omitempty" toml:"OrderID" yaml:"OrderID,omitempty"`
	OrderItem                                     null.Int     `boil:"OrderItem" json:"OrderItem,omitempty" toml:"OrderItem" yaml:"OrderItem,omitempty"`
	ProductIsBatchManagedInProductionPlant        null.Bool    `boil:"ProductIsBatchManagedInProductionPlant" json:"ProductIsBatchManagedInProductionPlant,omitempty" toml:"ProductIsBatchManagedInProductionPlant" yaml:"ProductIsBatchManagedInProductionPlant,omitempty"`
	BatchMgmtPolicyInProductionOrder              null.String  `boil:"BatchMgmtPolicyInProductionOrder" json:"BatchMgmtPolicyInProductionOrder,omitempty" toml:"BatchMgmtPolicyInProductionOrder" yaml:"BatchMgmtPolicyInProductionOrder,omitempty"`
	ProductionOrderTargetedBatch                  null.String  `boil:"ProductionOrderTargetedBatch" json:"ProductionOrderTargetedBatch,omitempty" toml:"ProductionOrderTargetedBatch" yaml:"ProductionOrderTargetedBatch,omitempty"`
	ProductionOrderTargetedBatchValidityStartDate null.String  `boil:"ProductionOrderTargetedBatchValidityStartDate" json:"ProductionOrderTargetedBatchValidityStartDate,omitempty" toml:"ProductionOrderTargetedBatchValidityStartDate" yaml:"ProductionOrderTargetedBatchValidityStartDate,omitempty"`
	ProductionOrderTargetedBatchValidityStartTime null.String  `boil:"ProductionOrderTargetedBatchValidityStartTime" json:"ProductionOrderTargetedBatchValidityStartTime,omitempty" toml:"ProductionOrderTargetedBatchValidityStartTime" yaml:"ProductionOrderTargetedBatchValidityStartTime,omitempty"`
	ProductionOrderTargetedBatchValidityEndDate   null.String  `boil:"ProductionOrderTargetedBatchValidityEndDate" json:"ProductionOrderTargetedBatchValidityEndDate,omitempty" toml:"ProductionOrderTargetedBatchValidityEndDate" yaml:"ProductionOrderTargetedBatchValidityEndDate,omitempty"`
	ProductionOrderTargetedBatchValidityEndTime   null.String  `boil:"ProductionOrderTargetedBatchValidityEndTime" json:"ProductionOrderTargetedBatchValidityEndTime,omitempty" toml:"ProductionOrderTargetedBatchValidityEndTime" yaml:"ProductionOrderTargetedBatchValidityEndTime,omitempty"`
	ProductionOrderItemText                       null.String  `boil:"ProductionOrderItemText" json:"ProductionOrderItemText,omitempty" toml:"ProductionOrderItemText" yaml:"ProductionOrderItemText,omitempty"`
	CreationDate                                  string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                                  string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                                string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                                string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsReleased                                    null.Bool    `boil:"IsReleased" json:"IsReleased,omitempty" toml:"IsReleased" yaml:"IsReleased,omitempty"`
	IsPartiallyConfirmed                          null.Bool    `boil:"IsPartiallyConfirmed" json:"IsPartiallyConfirmed,omitempty" toml:"IsPartiallyConfirmed" yaml:"IsPartiallyConfirmed,omitempty"`
	IsConfirmed                                   null.Bool    `boil:"IsConfirmed" json:"IsConfirmed,omitempty" toml:"IsConfirmed" yaml:"IsConfirmed,omitempty"`
	IsLocked                                      null.Bool    `boil:"IsLocked" json:"IsLocked,omitempty" toml:"IsLocked" yaml:"IsLocked,omitempty"`
	IsCancelled                                   null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                           null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformProductionOrderItemDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformProductionOrderItemDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformProductionOrderItemDatumColumns = struct {
	ProductionOrder                               string
	ProductionOrderItem                           string
	PrecedingProductionOrderItem                  string
	FollowingProductionOrderItem                  string
	SupplyChainRelationshipID                     string
	SupplyChainRelationshipProductionPlantID      string
	SupplyChainRelationshipDeliveryID             string
	SupplyChainRelationshipDeliveryPlantID        string
	ProductionOrderType                           string
	Product                                       string
	Buyer                                         string
	Seller                                        string
	ProductionPlantBusinessPartner                string
	ProductionPlant                               string
	ProductionPlantStorageLocation                string
	DeliverFromParty                              string
	DeliverFromPlant                              string
	DeliverFromPlantStorageLocation               string
	DeliverToParty                                string
	DeliverToPlant                                string
	DeliverToPlantStorageLocation                 string
	ProductBaseUnit                               string
	ProductProductionUnit                         string
	ProductDeliveryUnit                           string
	MRPArea                                       string
	MRPController                                 string
	ProductionVersion                             string
	ProductionVersionItem                         string
	BillOfMaterial                                string
	Operations                                    string
	ProductionOrderQuantityInBaseUnit             string
	ProductionOrderQuantityInProductionUnit       string
	ProductionOrderQuantityInDeliveryUnit         string
	ProductionOrderPlannedScrapQtyInBaseUnit      string
	ProductionOrderMinimumLotSizeQuantity         string
	ProductionOrderStandardLotSizeQuantity        string
	ProductionOrderMaximumLotSizeQuantity         string
	ProductionOrderLotSizeRoundingQuantity        string
	ProductionOrderLotSizeIsFixed                 string
	ProductionOrderPlannedStartDate               string
	ProductionOrderPlannedStartTime               string
	ProductionOrderPlannedEndDate                 string
	ProductionOrderPlannedEndTime                 string
	ProductionOrderActualReleaseDate              string
	ProductionOrderActualReleaseTime              string
	ProductionOrderActualStartDate                string
	ProductionOrderActualStartTime                string
	ProductionOrderActualEndDate                  string
	ProductionOrderActualEndTime                  string
	ConfirmedYieldQuantityInBaseUnit              string
	ConfirmedYieldQuantityInProductionUnit        string
	ScrappedQuantityInBaseUnit                    string
	PlannedOrder                                  string
	PlannedOrderItem                              string
	OrderID                                       string
	OrderItem                                     string
	ProductIsBatchManagedInProductionPlant        string
	BatchMgmtPolicyInProductionOrder              string
	ProductionOrderTargetedBatch                  string
	ProductionOrderTargetedBatchValidityStartDate string
	ProductionOrderTargetedBatchValidityStartTime string
	ProductionOrderTargetedBatchValidityEndDate   string
	ProductionOrderTargetedBatchValidityEndTime   string
	ProductionOrderItemText                       string
	CreationDate                                  string
	CreationTime                                  string
	LastChangeDate                                string
	LastChangeTime                                string
	IsReleased                                    string
	IsPartiallyConfirmed                          string
	IsConfirmed                                   string
	IsLocked                                      string
	IsCancelled                                   string
	IsMarkedForDeletion                           string
}{
	ProductionOrder:                               "ProductionOrder",
	ProductionOrderItem:                           "ProductionOrderItem",
	PrecedingProductionOrderItem:                  "PrecedingProductionOrderItem",
	FollowingProductionOrderItem:                  "FollowingProductionOrderItem",
	SupplyChainRelationshipID:                     "SupplyChainRelationshipID",
	SupplyChainRelationshipProductionPlantID:      "SupplyChainRelationshipProductionPlantID",
	SupplyChainRelationshipDeliveryID:             "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:        "SupplyChainRelationshipDeliveryPlantID",
	ProductionOrderType:                           "ProductionOrderType",
	Product:                                       "Product",
	Buyer:                                         "Buyer",
	Seller:                                        "Seller",
	ProductionPlantBusinessPartner:                "ProductionPlantBusinessPartner",
	ProductionPlant:                               "ProductionPlant",
	ProductionPlantStorageLocation:                "ProductionPlantStorageLocation",
	DeliverFromParty:                              "DeliverFromParty",
	DeliverFromPlant:                              "DeliverFromPlant",
	DeliverFromPlantStorageLocation:               "DeliverFromPlantStorageLocation",
	DeliverToParty:                                "DeliverToParty",
	DeliverToPlant:                                "DeliverToPlant",
	DeliverToPlantStorageLocation:                 "DeliverToPlantStorageLocation",
	ProductBaseUnit:                               "ProductBaseUnit",
	ProductProductionUnit:                         "ProductProductionUnit",
	ProductDeliveryUnit:                           "ProductDeliveryUnit",
	MRPArea:                                       "MRPArea",
	MRPController:                                 "MRPController",
	ProductionVersion:                             "ProductionVersion",
	ProductionVersionItem:                         "ProductionVersionItem",
	BillOfMaterial:                                "BillOfMaterial",
	Operations:                                    "Operations",
	ProductionOrderQuantityInBaseUnit:             "ProductionOrderQuantityInBaseUnit",
	ProductionOrderQuantityInProductionUnit:       "ProductionOrderQuantityInProductionUnit",
	ProductionOrderQuantityInDeliveryUnit:         "ProductionOrderQuantityInDeliveryUnit",
	ProductionOrderPlannedScrapQtyInBaseUnit:      "ProductionOrderPlannedScrapQtyInBaseUnit",
	ProductionOrderMinimumLotSizeQuantity:         "ProductionOrderMinimumLotSizeQuantity",
	ProductionOrderStandardLotSizeQuantity:        "ProductionOrderStandardLotSizeQuantity",
	ProductionOrderMaximumLotSizeQuantity:         "ProductionOrderMaximumLotSizeQuantity",
	ProductionOrderLotSizeRoundingQuantity:        "ProductionOrderLotSizeRoundingQuantity",
	ProductionOrderLotSizeIsFixed:                 "ProductionOrderLotSizeIsFixed",
	ProductionOrderPlannedStartDate:               "ProductionOrderPlannedStartDate",
	ProductionOrderPlannedStartTime:               "ProductionOrderPlannedStartTime",
	ProductionOrderPlannedEndDate:                 "ProductionOrderPlannedEndDate",
	ProductionOrderPlannedEndTime:                 "ProductionOrderPlannedEndTime",
	ProductionOrderActualReleaseDate:              "ProductionOrderActualReleaseDate",
	ProductionOrderActualReleaseTime:              "ProductionOrderActualReleaseTime",
	ProductionOrderActualStartDate:                "ProductionOrderActualStartDate",
	ProductionOrderActualStartTime:                "ProductionOrderActualStartTime",
	ProductionOrderActualEndDate:                  "ProductionOrderActualEndDate",
	ProductionOrderActualEndTime:                  "ProductionOrderActualEndTime",
	ConfirmedYieldQuantityInBaseUnit:              "ConfirmedYieldQuantityInBaseUnit",
	ConfirmedYieldQuantityInProductionUnit:        "ConfirmedYieldQuantityInProductionUnit",
	ScrappedQuantityInBaseUnit:                    "ScrappedQuantityInBaseUnit",
	PlannedOrder:                                  "PlannedOrder",
	PlannedOrderItem:                              "PlannedOrderItem",
	OrderID:                                       "OrderID",
	OrderItem:                                     "OrderItem",
	ProductIsBatchManagedInProductionPlant:        "ProductIsBatchManagedInProductionPlant",
	BatchMgmtPolicyInProductionOrder:              "BatchMgmtPolicyInProductionOrder",
	ProductionOrderTargetedBatch:                  "ProductionOrderTargetedBatch",
	ProductionOrderTargetedBatchValidityStartDate: "ProductionOrderTargetedBatchValidityStartDate",
	ProductionOrderTargetedBatchValidityStartTime: "ProductionOrderTargetedBatchValidityStartTime",
	ProductionOrderTargetedBatchValidityEndDate:   "ProductionOrderTargetedBatchValidityEndDate",
	ProductionOrderTargetedBatchValidityEndTime:   "ProductionOrderTargetedBatchValidityEndTime",
	ProductionOrderItemText:                       "ProductionOrderItemText",
	CreationDate:                                  "CreationDate",
	CreationTime:                                  "CreationTime",
	LastChangeDate:                                "LastChangeDate",
	LastChangeTime:                                "LastChangeTime",
	IsReleased:                                    "IsReleased",
	IsPartiallyConfirmed:                          "IsPartiallyConfirmed",
	IsConfirmed:                                   "IsConfirmed",
	IsLocked:                                      "IsLocked",
	IsCancelled:                                   "IsCancelled",
	IsMarkedForDeletion:                           "IsMarkedForDeletion",
}

var DataPlatformProductionOrderItemDatumTableColumns = struct {
	ProductionOrder                               string
	ProductionOrderItem                           string
	PrecedingProductionOrderItem                  string
	FollowingProductionOrderItem                  string
	SupplyChainRelationshipID                     string
	SupplyChainRelationshipProductionPlantID      string
	SupplyChainRelationshipDeliveryID             string
	SupplyChainRelationshipDeliveryPlantID        string
	ProductionOrderType                           string
	Product                                       string
	Buyer                                         string
	Seller                                        string
	ProductionPlantBusinessPartner                string
	ProductionPlant                               string
	ProductionPlantStorageLocation                string
	DeliverFromParty                              string
	DeliverFromPlant                              string
	DeliverFromPlantStorageLocation               string
	DeliverToParty                                string
	DeliverToPlant                                string
	DeliverToPlantStorageLocation                 string
	ProductBaseUnit                               string
	ProductProductionUnit                         string
	ProductDeliveryUnit                           string
	MRPArea                                       string
	MRPController                                 string
	ProductionVersion                             string
	ProductionVersionItem                         string
	BillOfMaterial                                string
	Operations                                    string
	ProductionOrderQuantityInBaseUnit             string
	ProductionOrderQuantityInProductionUnit       string
	ProductionOrderQuantityInDeliveryUnit         string
	ProductionOrderPlannedScrapQtyInBaseUnit      string
	ProductionOrderMinimumLotSizeQuantity         string
	ProductionOrderStandardLotSizeQuantity        string
	ProductionOrderMaximumLotSizeQuantity         string
	ProductionOrderLotSizeRoundingQuantity        string
	ProductionOrderLotSizeIsFixed                 string
	ProductionOrderPlannedStartDate               string
	ProductionOrderPlannedStartTime               string
	ProductionOrderPlannedEndDate                 string
	ProductionOrderPlannedEndTime                 string
	ProductionOrderActualReleaseDate              string
	ProductionOrderActualReleaseTime              string
	ProductionOrderActualStartDate                string
	ProductionOrderActualStartTime                string
	ProductionOrderActualEndDate                  string
	ProductionOrderActualEndTime                  string
	ConfirmedYieldQuantityInBaseUnit              string
	ConfirmedYieldQuantityInProductionUnit        string
	ScrappedQuantityInBaseUnit                    string
	PlannedOrder                                  string
	PlannedOrderItem                              string
	OrderID                                       string
	OrderItem                                     string
	ProductIsBatchManagedInProductionPlant        string
	BatchMgmtPolicyInProductionOrder              string
	ProductionOrderTargetedBatch                  string
	ProductionOrderTargetedBatchValidityStartDate string
	ProductionOrderTargetedBatchValidityStartTime string
	ProductionOrderTargetedBatchValidityEndDate   string
	ProductionOrderTargetedBatchValidityEndTime   string
	ProductionOrderItemText                       string
	CreationDate                                  string
	CreationTime                                  string
	LastChangeDate                                string
	LastChangeTime                                string
	IsReleased                                    string
	IsPartiallyConfirmed                          string
	IsConfirmed                                   string
	IsLocked                                      string
	IsCancelled                                   string
	IsMarkedForDeletion                           string
}{
	ProductionOrder:                               "data_platform_production_order_item_data.ProductionOrder",
	ProductionOrderItem:                           "data_platform_production_order_item_data.ProductionOrderItem",
	PrecedingProductionOrderItem:                  "data_platform_production_order_item_data.PrecedingProductionOrderItem",
	FollowingProductionOrderItem:                  "data_platform_production_order_item_data.FollowingProductionOrderItem",
	SupplyChainRelationshipID:                     "data_platform_production_order_item_data.SupplyChainRelationshipID",
	SupplyChainRelationshipProductionPlantID:      "data_platform_production_order_item_data.SupplyChainRelationshipProductionPlantID",
	SupplyChainRelationshipDeliveryID:             "data_platform_production_order_item_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:        "data_platform_production_order_item_data.SupplyChainRelationshipDeliveryPlantID",
	ProductionOrderType:                           "data_platform_production_order_item_data.ProductionOrderType",
	Product:                                       "data_platform_production_order_item_data.Product",
	Buyer:                                         "data_platform_production_order_item_data.Buyer",
	Seller:                                        "data_platform_production_order_item_data.Seller",
	ProductionPlantBusinessPartner:                "data_platform_production_order_item_data.ProductionPlantBusinessPartner",
	ProductionPlant:                               "data_platform_production_order_item_data.ProductionPlant",
	ProductionPlantStorageLocation:                "data_platform_production_order_item_data.ProductionPlantStorageLocation",
	DeliverFromParty:                              "data_platform_production_order_item_data.DeliverFromParty",
	DeliverFromPlant:                              "data_platform_production_order_item_data.DeliverFromPlant",
	DeliverFromPlantStorageLocation:               "data_platform_production_order_item_data.DeliverFromPlantStorageLocation",
	DeliverToParty:                                "data_platform_production_order_item_data.DeliverToParty",
	DeliverToPlant:                                "data_platform_production_order_item_data.DeliverToPlant",
	DeliverToPlantStorageLocation:                 "data_platform_production_order_item_data.DeliverToPlantStorageLocation",
	ProductBaseUnit:                               "data_platform_production_order_item_data.ProductBaseUnit",
	ProductProductionUnit:                         "data_platform_production_order_item_data.ProductProductionUnit",
	ProductDeliveryUnit:                           "data_platform_production_order_item_data.ProductDeliveryUnit",
	MRPArea:                                       "data_platform_production_order_item_data.MRPArea",
	MRPController:                                 "data_platform_production_order_item_data.MRPController",
	ProductionVersion:                             "data_platform_production_order_item_data.ProductionVersion",
	ProductionVersionItem:                         "data_platform_production_order_item_data.ProductionVersionItem",
	BillOfMaterial:                                "data_platform_production_order_item_data.BillOfMaterial",
	Operations:                                    "data_platform_production_order_item_data.Operations",
	ProductionOrderQuantityInBaseUnit:             "data_platform_production_order_item_data.ProductionOrderQuantityInBaseUnit",
	ProductionOrderQuantityInProductionUnit:       "data_platform_production_order_item_data.ProductionOrderQuantityInProductionUnit",
	ProductionOrderQuantityInDeliveryUnit:         "data_platform_production_order_item_data.ProductionOrderQuantityInDeliveryUnit",
	ProductionOrderPlannedScrapQtyInBaseUnit:      "data_platform_production_order_item_data.ProductionOrderPlannedScrapQtyInBaseUnit",
	ProductionOrderMinimumLotSizeQuantity:         "data_platform_production_order_item_data.ProductionOrderMinimumLotSizeQuantity",
	ProductionOrderStandardLotSizeQuantity:        "data_platform_production_order_item_data.ProductionOrderStandardLotSizeQuantity",
	ProductionOrderMaximumLotSizeQuantity:         "data_platform_production_order_item_data.ProductionOrderMaximumLotSizeQuantity",
	ProductionOrderLotSizeRoundingQuantity:        "data_platform_production_order_item_data.ProductionOrderLotSizeRoundingQuantity",
	ProductionOrderLotSizeIsFixed:                 "data_platform_production_order_item_data.ProductionOrderLotSizeIsFixed",
	ProductionOrderPlannedStartDate:               "data_platform_production_order_item_data.ProductionOrderPlannedStartDate",
	ProductionOrderPlannedStartTime:               "data_platform_production_order_item_data.ProductionOrderPlannedStartTime",
	ProductionOrderPlannedEndDate:                 "data_platform_production_order_item_data.ProductionOrderPlannedEndDate",
	ProductionOrderPlannedEndTime:                 "data_platform_production_order_item_data.ProductionOrderPlannedEndTime",
	ProductionOrderActualReleaseDate:              "data_platform_production_order_item_data.ProductionOrderActualReleaseDate",
	ProductionOrderActualReleaseTime:              "data_platform_production_order_item_data.ProductionOrderActualReleaseTime",
	ProductionOrderActualStartDate:                "data_platform_production_order_item_data.ProductionOrderActualStartDate",
	ProductionOrderActualStartTime:                "data_platform_production_order_item_data.ProductionOrderActualStartTime",
	ProductionOrderActualEndDate:                  "data_platform_production_order_item_data.ProductionOrderActualEndDate",
	ProductionOrderActualEndTime:                  "data_platform_production_order_item_data.ProductionOrderActualEndTime",
	ConfirmedYieldQuantityInBaseUnit:              "data_platform_production_order_item_data.ConfirmedYieldQuantityInBaseUnit",
	ConfirmedYieldQuantityInProductionUnit:        "data_platform_production_order_item_data.ConfirmedYieldQuantityInProductionUnit",
	ScrappedQuantityInBaseUnit:                    "data_platform_production_order_item_data.ScrappedQuantityInBaseUnit",
	PlannedOrder:                                  "data_platform_production_order_item_data.PlannedOrder",
	PlannedOrderItem:                              "data_platform_production_order_item_data.PlannedOrderItem",
	OrderID:                                       "data_platform_production_order_item_data.OrderID",
	OrderItem:                                     "data_platform_production_order_item_data.OrderItem",
	ProductIsBatchManagedInProductionPlant:        "data_platform_production_order_item_data.ProductIsBatchManagedInProductionPlant",
	BatchMgmtPolicyInProductionOrder:              "data_platform_production_order_item_data.BatchMgmtPolicyInProductionOrder",
	ProductionOrderTargetedBatch:                  "data_platform_production_order_item_data.ProductionOrderTargetedBatch",
	ProductionOrderTargetedBatchValidityStartDate: "data_platform_production_order_item_data.ProductionOrderTargetedBatchValidityStartDate",
	ProductionOrderTargetedBatchValidityStartTime: "data_platform_production_order_item_data.ProductionOrderTargetedBatchValidityStartTime",
	ProductionOrderTargetedBatchValidityEndDate:   "data_platform_production_order_item_data.ProductionOrderTargetedBatchValidityEndDate",
	ProductionOrderTargetedBatchValidityEndTime:   "data_platform_production_order_item_data.ProductionOrderTargetedBatchValidityEndTime",
	ProductionOrderItemText:                       "data_platform_production_order_item_data.ProductionOrderItemText",
	CreationDate:                                  "data_platform_production_order_item_data.CreationDate",
	CreationTime:                                  "data_platform_production_order_item_data.CreationTime",
	LastChangeDate:                                "data_platform_production_order_item_data.LastChangeDate",
	LastChangeTime:                                "data_platform_production_order_item_data.LastChangeTime",
	IsReleased:                                    "data_platform_production_order_item_data.IsReleased",
	IsPartiallyConfirmed:                          "data_platform_production_order_item_data.IsPartiallyConfirmed",
	IsConfirmed:                                   "data_platform_production_order_item_data.IsConfirmed",
	IsLocked:                                      "data_platform_production_order_item_data.IsLocked",
	IsCancelled:                                   "data_platform_production_order_item_data.IsCancelled",
	IsMarkedForDeletion:                           "data_platform_production_order_item_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformProductionOrderItemDatumWhere = struct {
	ProductionOrder                               whereHelperint
	ProductionOrderItem                           whereHelperint
	PrecedingProductionOrderItem                  whereHelpernull_Int
	FollowingProductionOrderItem                  whereHelpernull_Int
	SupplyChainRelationshipID                     whereHelperint
	SupplyChainRelationshipProductionPlantID      whereHelperint
	SupplyChainRelationshipDeliveryID             whereHelperint
	SupplyChainRelationshipDeliveryPlantID        whereHelperint
	ProductionOrderType                           whereHelperstring
	Product                                       whereHelperstring
	Buyer                                         whereHelperint
	Seller                                        whereHelperint
	ProductionPlantBusinessPartner                whereHelperint
	ProductionPlant                               whereHelperstring
	ProductionPlantStorageLocation                whereHelperstring
	DeliverFromParty                              whereHelperint
	DeliverFromPlant                              whereHelperstring
	DeliverFromPlantStorageLocation               whereHelperstring
	DeliverToParty                                whereHelperint
	DeliverToPlant                                whereHelperstring
	DeliverToPlantStorageLocation                 whereHelperstring
	ProductBaseUnit                               whereHelperstring
	ProductProductionUnit                         whereHelperstring
	ProductDeliveryUnit                           whereHelperstring
	MRPArea                                       whereHelpernull_String
	MRPController                                 whereHelpernull_String
	ProductionVersion                             whereHelpernull_Int
	ProductionVersionItem                         whereHelpernull_Int
	BillOfMaterial                                whereHelperint
	Operations                                    whereHelperint
	ProductionOrderQuantityInBaseUnit             whereHelperfloat32
	ProductionOrderQuantityInProductionUnit       whereHelperfloat32
	ProductionOrderQuantityInDeliveryUnit         whereHelperfloat32
	ProductionOrderPlannedScrapQtyInBaseUnit      whereHelpernull_Float32
	ProductionOrderMinimumLotSizeQuantity         whereHelperfloat32
	ProductionOrderStandardLotSizeQuantity        whereHelperfloat32
	ProductionOrderMaximumLotSizeQuantity         whereHelperfloat32
	ProductionOrderLotSizeRoundingQuantity        whereHelpernull_Float32
	ProductionOrderLotSizeIsFixed                 whereHelpernull_Bool
	ProductionOrderPlannedStartDate               whereHelperstring
	ProductionOrderPlannedStartTime               whereHelperstring
	ProductionOrderPlannedEndDate                 whereHelperstring
	ProductionOrderPlannedEndTime                 whereHelperstring
	ProductionOrderActualReleaseDate              whereHelpernull_String
	ProductionOrderActualReleaseTime              whereHelpernull_String
	ProductionOrderActualStartDate                whereHelpernull_String
	ProductionOrderActualStartTime                whereHelpernull_String
	ProductionOrderActualEndDate                  whereHelpernull_String
	ProductionOrderActualEndTime                  whereHelpernull_String
	ConfirmedYieldQuantityInBaseUnit              whereHelpernull_Float32
	ConfirmedYieldQuantityInProductionUnit        whereHelpernull_Float32
	ScrappedQuantityInBaseUnit                    whereHelpernull_Float32
	PlannedOrder                                  whereHelpernull_Int
	PlannedOrderItem                              whereHelpernull_Int
	OrderID                                       whereHelpernull_Int
	OrderItem                                     whereHelpernull_Int
	ProductIsBatchManagedInProductionPlant        whereHelpernull_Bool
	BatchMgmtPolicyInProductionOrder              whereHelpernull_String
	ProductionOrderTargetedBatch                  whereHelpernull_String
	ProductionOrderTargetedBatchValidityStartDate whereHelpernull_String
	ProductionOrderTargetedBatchValidityStartTime whereHelpernull_String
	ProductionOrderTargetedBatchValidityEndDate   whereHelpernull_String
	ProductionOrderTargetedBatchValidityEndTime   whereHelpernull_String
	ProductionOrderItemText                       whereHelpernull_String
	CreationDate                                  whereHelperstring
	CreationTime                                  whereHelperstring
	LastChangeDate                                whereHelperstring
	LastChangeTime                                whereHelperstring
	IsReleased                                    whereHelpernull_Bool
	IsPartiallyConfirmed                          whereHelpernull_Bool
	IsConfirmed                                   whereHelpernull_Bool
	IsLocked                                      whereHelpernull_Bool
	IsCancelled                                   whereHelpernull_Bool
	IsMarkedForDeletion                           whereHelpernull_Bool
}{
	ProductionOrder:                               whereHelperint{field: "`data_platform_production_order_item_data`.`ProductionOrder`"},
	ProductionOrderItem:                           whereHelperint{field: "`data_platform_production_order_item_data`.`ProductionOrderItem`"},
	PrecedingProductionOrderItem:                  whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`PrecedingProductionOrderItem`"},
	FollowingProductionOrderItem:                  whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`FollowingProductionOrderItem`"},
	SupplyChainRelationshipID:                     whereHelperint{field: "`data_platform_production_order_item_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipProductionPlantID:      whereHelperint{field: "`data_platform_production_order_item_data`.`SupplyChainRelationshipProductionPlantID`"},
	SupplyChainRelationshipDeliveryID:             whereHelperint{field: "`data_platform_production_order_item_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID:        whereHelperint{field: "`data_platform_production_order_item_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	ProductionOrderType:                           whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionOrderType`"},
	Product:                                       whereHelperstring{field: "`data_platform_production_order_item_data`.`Product`"},
	Buyer:                                         whereHelperint{field: "`data_platform_production_order_item_data`.`Buyer`"},
	Seller:                                        whereHelperint{field: "`data_platform_production_order_item_data`.`Seller`"},
	ProductionPlantBusinessPartner:                whereHelperint{field: "`data_platform_production_order_item_data`.`ProductionPlantBusinessPartner`"},
	ProductionPlant:                               whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionPlant`"},
	ProductionPlantStorageLocation:                whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionPlantStorageLocation`"},
	DeliverFromParty:                              whereHelperint{field: "`data_platform_production_order_item_data`.`DeliverFromParty`"},
	DeliverFromPlant:                              whereHelperstring{field: "`data_platform_production_order_item_data`.`DeliverFromPlant`"},
	DeliverFromPlantStorageLocation:               whereHelperstring{field: "`data_platform_production_order_item_data`.`DeliverFromPlantStorageLocation`"},
	DeliverToParty:                                whereHelperint{field: "`data_platform_production_order_item_data`.`DeliverToParty`"},
	DeliverToPlant:                                whereHelperstring{field: "`data_platform_production_order_item_data`.`DeliverToPlant`"},
	DeliverToPlantStorageLocation:                 whereHelperstring{field: "`data_platform_production_order_item_data`.`DeliverToPlantStorageLocation`"},
	ProductBaseUnit:                               whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductBaseUnit`"},
	ProductProductionUnit:                         whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductProductionUnit`"},
	ProductDeliveryUnit:                           whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductDeliveryUnit`"},
	MRPArea:                                       whereHelpernull_String{field: "`data_platform_production_order_item_data`.`MRPArea`"},
	MRPController:                                 whereHelpernull_String{field: "`data_platform_production_order_item_data`.`MRPController`"},
	ProductionVersion:                             whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`ProductionVersion`"},
	ProductionVersionItem:                         whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`ProductionVersionItem`"},
	BillOfMaterial:                                whereHelperint{field: "`data_platform_production_order_item_data`.`BillOfMaterial`"},
	Operations:                                    whereHelperint{field: "`data_platform_production_order_item_data`.`Operations`"},
	ProductionOrderQuantityInBaseUnit:             whereHelperfloat32{field: "`data_platform_production_order_item_data`.`ProductionOrderQuantityInBaseUnit`"},
	ProductionOrderQuantityInProductionUnit:       whereHelperfloat32{field: "`data_platform_production_order_item_data`.`ProductionOrderQuantityInProductionUnit`"},
	ProductionOrderQuantityInDeliveryUnit:         whereHelperfloat32{field: "`data_platform_production_order_item_data`.`ProductionOrderQuantityInDeliveryUnit`"},
	ProductionOrderPlannedScrapQtyInBaseUnit:      whereHelpernull_Float32{field: "`data_platform_production_order_item_data`.`ProductionOrderPlannedScrapQtyInBaseUnit`"},
	ProductionOrderMinimumLotSizeQuantity:         whereHelperfloat32{field: "`data_platform_production_order_item_data`.`ProductionOrderMinimumLotSizeQuantity`"},
	ProductionOrderStandardLotSizeQuantity:        whereHelperfloat32{field: "`data_platform_production_order_item_data`.`ProductionOrderStandardLotSizeQuantity`"},
	ProductionOrderMaximumLotSizeQuantity:         whereHelperfloat32{field: "`data_platform_production_order_item_data`.`ProductionOrderMaximumLotSizeQuantity`"},
	ProductionOrderLotSizeRoundingQuantity:        whereHelpernull_Float32{field: "`data_platform_production_order_item_data`.`ProductionOrderLotSizeRoundingQuantity`"},
	ProductionOrderLotSizeIsFixed:                 whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`ProductionOrderLotSizeIsFixed`"},
	ProductionOrderPlannedStartDate:               whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionOrderPlannedStartDate`"},
	ProductionOrderPlannedStartTime:               whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionOrderPlannedStartTime`"},
	ProductionOrderPlannedEndDate:                 whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionOrderPlannedEndDate`"},
	ProductionOrderPlannedEndTime:                 whereHelperstring{field: "`data_platform_production_order_item_data`.`ProductionOrderPlannedEndTime`"},
	ProductionOrderActualReleaseDate:              whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderActualReleaseDate`"},
	ProductionOrderActualReleaseTime:              whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderActualReleaseTime`"},
	ProductionOrderActualStartDate:                whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderActualStartDate`"},
	ProductionOrderActualStartTime:                whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderActualStartTime`"},
	ProductionOrderActualEndDate:                  whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderActualEndDate`"},
	ProductionOrderActualEndTime:                  whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderActualEndTime`"},
	ConfirmedYieldQuantityInBaseUnit:              whereHelpernull_Float32{field: "`data_platform_production_order_item_data`.`ConfirmedYieldQuantityInBaseUnit`"},
	ConfirmedYieldQuantityInProductionUnit:        whereHelpernull_Float32{field: "`data_platform_production_order_item_data`.`ConfirmedYieldQuantityInProductionUnit`"},
	ScrappedQuantityInBaseUnit:                    whereHelpernull_Float32{field: "`data_platform_production_order_item_data`.`ScrappedQuantityInBaseUnit`"},
	PlannedOrder:                                  whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`PlannedOrder`"},
	PlannedOrderItem:                              whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`PlannedOrderItem`"},
	OrderID:                                       whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`OrderID`"},
	OrderItem:                                     whereHelpernull_Int{field: "`data_platform_production_order_item_data`.`OrderItem`"},
	ProductIsBatchManagedInProductionPlant:        whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`ProductIsBatchManagedInProductionPlant`"},
	BatchMgmtPolicyInProductionOrder:              whereHelpernull_String{field: "`data_platform_production_order_item_data`.`BatchMgmtPolicyInProductionOrder`"},
	ProductionOrderTargetedBatch:                  whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderTargetedBatch`"},
	ProductionOrderTargetedBatchValidityStartDate: whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderTargetedBatchValidityStartDate`"},
	ProductionOrderTargetedBatchValidityStartTime: whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderTargetedBatchValidityStartTime`"},
	ProductionOrderTargetedBatchValidityEndDate:   whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderTargetedBatchValidityEndDate`"},
	ProductionOrderTargetedBatchValidityEndTime:   whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderTargetedBatchValidityEndTime`"},
	ProductionOrderItemText:                       whereHelpernull_String{field: "`data_platform_production_order_item_data`.`ProductionOrderItemText`"},
	CreationDate:                                  whereHelperstring{field: "`data_platform_production_order_item_data`.`CreationDate`"},
	CreationTime:                                  whereHelperstring{field: "`data_platform_production_order_item_data`.`CreationTime`"},
	LastChangeDate:                                whereHelperstring{field: "`data_platform_production_order_item_data`.`LastChangeDate`"},
	LastChangeTime:                                whereHelperstring{field: "`data_platform_production_order_item_data`.`LastChangeTime`"},
	IsReleased:                                    whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`IsReleased`"},
	IsPartiallyConfirmed:                          whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`IsPartiallyConfirmed`"},
	IsConfirmed:                                   whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`IsConfirmed`"},
	IsLocked:                                      whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`IsLocked`"},
	IsCancelled:                                   whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`IsCancelled`"},
	IsMarkedForDeletion:                           whereHelpernull_Bool{field: "`data_platform_production_order_item_data`.`IsMarkedForDeletion`"},
}

// DataPlatformProductionOrderItemDatumRels is where relationship names are stored.
var DataPlatformProductionOrderItemDatumRels = struct {
	BillOfMaterialDataPlatformBillOfMaterialHeaderDatum            string
	DeliverFromPartyDataPlatformPlantStorageLocationDatum          string
	DeliverToPartyDataPlatformPlantStorageLocationDatum            string
	Operation                                                      string
	OrderIDDataPlatformOrdersItemDatum                             string
	ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum       string
	ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum   string
	ProductDataPlatformBatchMasterRecordBatchDatum                 string
	ProductionPlantDataPlatformPlantStorageLocationDatum           string
	ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum string
	BuyerDataPlatformSCRDeliveryRelationDatum                      string
	BuyerDataPlatformSCRGeneralDatum                               string
	ProductionOrderDataPlatformProductionOrderHeaderDatum          string
	ProductionOrderDataPlatformDeliveryDocumentHeaderData          string
	ProductionOrderDataPlatformDeliveryDocumentItemData            string
	ProductionOrderDataPlatformOrdersHeaderData                    string
	ProductionOrderDataPlatformOrdersItemData                      string
	ProductionOrderDataPlatformProductionOrderItemComponentData    string
	ProductionOrderDataPlatformProductionOrderItemOperationData    string
	ProductionOrderDataPlatformPurchaseRequisitionHeaderData       string
	ProductionOrderDataPlatformPurchaseRequisitionItemData         string
}{
	BillOfMaterialDataPlatformBillOfMaterialHeaderDatum:   "BillOfMaterialDataPlatformBillOfMaterialHeaderDatum",
	DeliverFromPartyDataPlatformPlantStorageLocationDatum: "DeliverFromPartyDataPlatformPlantStorageLocationDatum",
	DeliverToPartyDataPlatformPlantStorageLocationDatum:   "DeliverToPartyDataPlatformPlantStorageLocationDatum",
	Operation:                          "Operation",
	OrderIDDataPlatformOrdersItemDatum: "OrderIDDataPlatformOrdersItemDatum",
	ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum:       "ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum",
	ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum:   "ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum",
	ProductDataPlatformBatchMasterRecordBatchDatum:                 "ProductDataPlatformBatchMasterRecordBatchDatum",
	ProductionPlantDataPlatformPlantStorageLocationDatum:           "ProductionPlantDataPlatformPlantStorageLocationDatum",
	ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum: "ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum",
	BuyerDataPlatformSCRDeliveryRelationDatum:                      "BuyerDataPlatformSCRDeliveryRelationDatum",
	BuyerDataPlatformSCRGeneralDatum:                               "BuyerDataPlatformSCRGeneralDatum",
	ProductionOrderDataPlatformProductionOrderHeaderDatum:          "ProductionOrderDataPlatformProductionOrderHeaderDatum",
	ProductionOrderDataPlatformDeliveryDocumentHeaderData:          "ProductionOrderDataPlatformDeliveryDocumentHeaderData",
	ProductionOrderDataPlatformDeliveryDocumentItemData:            "ProductionOrderDataPlatformDeliveryDocumentItemData",
	ProductionOrderDataPlatformOrdersHeaderData:                    "ProductionOrderDataPlatformOrdersHeaderData",
	ProductionOrderDataPlatformOrdersItemData:                      "ProductionOrderDataPlatformOrdersItemData",
	ProductionOrderDataPlatformProductionOrderItemComponentData:    "ProductionOrderDataPlatformProductionOrderItemComponentData",
	ProductionOrderDataPlatformProductionOrderItemOperationData:    "ProductionOrderDataPlatformProductionOrderItemOperationData",
	ProductionOrderDataPlatformPurchaseRequisitionHeaderData:       "ProductionOrderDataPlatformPurchaseRequisitionHeaderData",
	ProductionOrderDataPlatformPurchaseRequisitionItemData:         "ProductionOrderDataPlatformPurchaseRequisitionItemData",
}

// dataPlatformProductionOrderItemDatumR is where relationships are stored.
type dataPlatformProductionOrderItemDatumR struct {
	BillOfMaterialDataPlatformBillOfMaterialHeaderDatum            *DataPlatformBillOfMaterialHeaderDatum             `boil:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum" json:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum" toml:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum" yaml:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum"`
	DeliverFromPartyDataPlatformPlantStorageLocationDatum          *DataPlatformPlantStorageLocationDatum             `boil:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" json:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" toml:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" yaml:"DeliverFromPartyDataPlatformPlantStorageLocationDatum"`
	DeliverToPartyDataPlatformPlantStorageLocationDatum            *DataPlatformPlantStorageLocationDatum             `boil:"DeliverToPartyDataPlatformPlantStorageLocationDatum" json:"DeliverToPartyDataPlatformPlantStorageLocationDatum" toml:"DeliverToPartyDataPlatformPlantStorageLocationDatum" yaml:"DeliverToPartyDataPlatformPlantStorageLocationDatum"`
	Operation                                                      *DataPlatformOperationsHeaderDatum                 `boil:"Operation" json:"Operation" toml:"Operation" yaml:"Operation"`
	OrderIDDataPlatformOrdersItemDatum                             *DataPlatformOrdersItemDatum                       `boil:"OrderIDDataPlatformOrdersItemDatum" json:"OrderIDDataPlatformOrdersItemDatum" toml:"OrderIDDataPlatformOrdersItemDatum" yaml:"OrderIDDataPlatformOrdersItemDatum"`
	ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum       *DataPlatformQuantityUnitQuantityUnitDatum         `boil:"ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum   *DataPlatformQuantityUnitQuantityUnitDatum         `boil:"ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	ProductDataPlatformBatchMasterRecordBatchDatum                 *DataPlatformBatchMasterRecordBatchDatum           `boil:"ProductDataPlatformBatchMasterRecordBatchDatum" json:"ProductDataPlatformBatchMasterRecordBatchDatum" toml:"ProductDataPlatformBatchMasterRecordBatchDatum" yaml:"ProductDataPlatformBatchMasterRecordBatchDatum"`
	ProductionPlantDataPlatformPlantStorageLocationDatum           *DataPlatformPlantStorageLocationDatum             `boil:"ProductionPlantDataPlatformPlantStorageLocationDatum" json:"ProductionPlantDataPlatformPlantStorageLocationDatum" toml:"ProductionPlantDataPlatformPlantStorageLocationDatum" yaml:"ProductionPlantDataPlatformPlantStorageLocationDatum"`
	ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum         `boil:"ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	BuyerDataPlatformSCRDeliveryRelationDatum                      *DataPlatformSCRDeliveryRelationDatum              `boil:"BuyerDataPlatformSCRDeliveryRelationDatum" json:"BuyerDataPlatformSCRDeliveryRelationDatum" toml:"BuyerDataPlatformSCRDeliveryRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryRelationDatum"`
	BuyerDataPlatformSCRGeneralDatum                               *DataPlatformSCRGeneralDatum                       `boil:"BuyerDataPlatformSCRGeneralDatum" json:"BuyerDataPlatformSCRGeneralDatum" toml:"BuyerDataPlatformSCRGeneralDatum" yaml:"BuyerDataPlatformSCRGeneralDatum"`
	ProductionOrderDataPlatformProductionOrderHeaderDatum          *DataPlatformProductionOrderHeaderDatum            `boil:"ProductionOrderDataPlatformProductionOrderHeaderDatum" json:"ProductionOrderDataPlatformProductionOrderHeaderDatum" toml:"ProductionOrderDataPlatformProductionOrderHeaderDatum" yaml:"ProductionOrderDataPlatformProductionOrderHeaderDatum"`
	ProductionOrderDataPlatformDeliveryDocumentHeaderData          DataPlatformDeliveryDocumentHeaderDatumSlice       `boil:"ProductionOrderDataPlatformDeliveryDocumentHeaderData" json:"ProductionOrderDataPlatformDeliveryDocumentHeaderData" toml:"ProductionOrderDataPlatformDeliveryDocumentHeaderData" yaml:"ProductionOrderDataPlatformDeliveryDocumentHeaderData"`
	ProductionOrderDataPlatformDeliveryDocumentItemData            DataPlatformDeliveryDocumentItemDatumSlice         `boil:"ProductionOrderDataPlatformDeliveryDocumentItemData" json:"ProductionOrderDataPlatformDeliveryDocumentItemData" toml:"ProductionOrderDataPlatformDeliveryDocumentItemData" yaml:"ProductionOrderDataPlatformDeliveryDocumentItemData"`
	ProductionOrderDataPlatformOrdersHeaderData                    DataPlatformOrdersHeaderDatumSlice                 `boil:"ProductionOrderDataPlatformOrdersHeaderData" json:"ProductionOrderDataPlatformOrdersHeaderData" toml:"ProductionOrderDataPlatformOrdersHeaderData" yaml:"ProductionOrderDataPlatformOrdersHeaderData"`
	ProductionOrderDataPlatformOrdersItemData                      DataPlatformOrdersItemDatumSlice                   `boil:"ProductionOrderDataPlatformOrdersItemData" json:"ProductionOrderDataPlatformOrdersItemData" toml:"ProductionOrderDataPlatformOrdersItemData" yaml:"ProductionOrderDataPlatformOrdersItemData"`
	ProductionOrderDataPlatformProductionOrderItemComponentData    DataPlatformProductionOrderItemComponentDatumSlice `boil:"ProductionOrderDataPlatformProductionOrderItemComponentData" json:"ProductionOrderDataPlatformProductionOrderItemComponentData" toml:"ProductionOrderDataPlatformProductionOrderItemComponentData" yaml:"ProductionOrderDataPlatformProductionOrderItemComponentData"`
	ProductionOrderDataPlatformProductionOrderItemOperationData    DataPlatformProductionOrderItemOperationDatumSlice `boil:"ProductionOrderDataPlatformProductionOrderItemOperationData" json:"ProductionOrderDataPlatformProductionOrderItemOperationData" toml:"ProductionOrderDataPlatformProductionOrderItemOperationData" yaml:"ProductionOrderDataPlatformProductionOrderItemOperationData"`
	ProductionOrderDataPlatformPurchaseRequisitionHeaderData       DataPlatformPurchaseRequisitionHeaderDatumSlice    `boil:"ProductionOrderDataPlatformPurchaseRequisitionHeaderData" json:"ProductionOrderDataPlatformPurchaseRequisitionHeaderData" toml:"ProductionOrderDataPlatformPurchaseRequisitionHeaderData" yaml:"ProductionOrderDataPlatformPurchaseRequisitionHeaderData"`
	ProductionOrderDataPlatformPurchaseRequisitionItemData         DataPlatformPurchaseRequisitionItemDatumSlice      `boil:"ProductionOrderDataPlatformPurchaseRequisitionItemData" json:"ProductionOrderDataPlatformPurchaseRequisitionItemData" toml:"ProductionOrderDataPlatformPurchaseRequisitionItemData" yaml:"ProductionOrderDataPlatformPurchaseRequisitionItemData"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformProductionOrderItemDatumR) NewStruct() *dataPlatformProductionOrderItemDatumR {
	return &dataPlatformProductionOrderItemDatumR{}
}

func (r *dataPlatformProductionOrderItemDatumR) GetBillOfMaterialDataPlatformBillOfMaterialHeaderDatum() *DataPlatformBillOfMaterialHeaderDatum {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetDeliverFromPartyDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetDeliverToPartyDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetOperation() *DataPlatformOperationsHeaderDatum {
	if r == nil {
		return nil
	}
	return r.Operation
}

func (r *dataPlatformProductionOrderItemDatumR) GetOrderIDDataPlatformOrdersItemDatum() *DataPlatformOrdersItemDatum {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductDataPlatformBatchMasterRecordBatchDatum() *DataPlatformBatchMasterRecordBatchDatum {
	if r == nil {
		return nil
	}
	return r.ProductDataPlatformBatchMasterRecordBatchDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionPlantDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.ProductionPlantDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetBuyerDataPlatformSCRDeliveryRelationDatum() *DataPlatformSCRDeliveryRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryRelationDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetBuyerDataPlatformSCRGeneralDatum() *DataPlatformSCRGeneralDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRGeneralDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformProductionOrderHeaderDatum() *DataPlatformProductionOrderHeaderDatum {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderHeaderDatum
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformDeliveryDocumentHeaderData() DataPlatformDeliveryDocumentHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformDeliveryDocumentHeaderData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformDeliveryDocumentItemData() DataPlatformDeliveryDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformDeliveryDocumentItemData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformOrdersHeaderData() DataPlatformOrdersHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformOrdersHeaderData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformOrdersItemData() DataPlatformOrdersItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformOrdersItemData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformProductionOrderItemComponentData() DataPlatformProductionOrderItemComponentDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemComponentData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformProductionOrderItemOperationData() DataPlatformProductionOrderItemOperationDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemOperationData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformPurchaseRequisitionHeaderData() DataPlatformPurchaseRequisitionHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformPurchaseRequisitionHeaderData
}

func (r *dataPlatformProductionOrderItemDatumR) GetProductionOrderDataPlatformPurchaseRequisitionItemData() DataPlatformPurchaseRequisitionItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformPurchaseRequisitionItemData
}

// dataPlatformProductionOrderItemDatumL is where Load methods for each relationship are stored.
type dataPlatformProductionOrderItemDatumL struct{}

var (
	dataPlatformProductionOrderItemDatumAllColumns            = []string{"ProductionOrder", "ProductionOrderItem", "PrecedingProductionOrderItem", "FollowingProductionOrderItem", "SupplyChainRelationshipID", "SupplyChainRelationshipProductionPlantID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "ProductionOrderType", "Product", "Buyer", "Seller", "ProductionPlantBusinessPartner", "ProductionPlant", "ProductionPlantStorageLocation", "DeliverFromParty", "DeliverFromPlant", "DeliverFromPlantStorageLocation", "DeliverToParty", "DeliverToPlant", "DeliverToPlantStorageLocation", "ProductBaseUnit", "ProductProductionUnit", "ProductDeliveryUnit", "MRPArea", "MRPController", "ProductionVersion", "ProductionVersionItem", "BillOfMaterial", "Operations", "ProductionOrderQuantityInBaseUnit", "ProductionOrderQuantityInProductionUnit", "ProductionOrderQuantityInDeliveryUnit", "ProductionOrderPlannedScrapQtyInBaseUnit", "ProductionOrderMinimumLotSizeQuantity", "ProductionOrderStandardLotSizeQuantity", "ProductionOrderMaximumLotSizeQuantity", "ProductionOrderLotSizeRoundingQuantity", "ProductionOrderLotSizeIsFixed", "ProductionOrderPlannedStartDate", "ProductionOrderPlannedStartTime", "ProductionOrderPlannedEndDate", "ProductionOrderPlannedEndTime", "ProductionOrderActualReleaseDate", "ProductionOrderActualReleaseTime", "ProductionOrderActualStartDate", "ProductionOrderActualStartTime", "ProductionOrderActualEndDate", "ProductionOrderActualEndTime", "ConfirmedYieldQuantityInBaseUnit", "ConfirmedYieldQuantityInProductionUnit", "ScrappedQuantityInBaseUnit", "PlannedOrder", "PlannedOrderItem", "OrderID", "OrderItem", "ProductIsBatchManagedInProductionPlant", "BatchMgmtPolicyInProductionOrder", "ProductionOrderTargetedBatch", "ProductionOrderTargetedBatchValidityStartDate", "ProductionOrderTargetedBatchValidityStartTime", "ProductionOrderTargetedBatchValidityEndDate", "ProductionOrderTargetedBatchValidityEndTime", "ProductionOrderItemText", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsReleased", "IsPartiallyConfirmed", "IsConfirmed", "IsLocked", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformProductionOrderItemDatumColumnsWithoutDefault = []string{"ProductionOrder", "ProductionOrderItem", "PrecedingProductionOrderItem", "FollowingProductionOrderItem", "SupplyChainRelationshipID", "SupplyChainRelationshipProductionPlantID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "ProductionOrderType", "Product", "Buyer", "Seller", "ProductionPlantBusinessPartner", "ProductionPlant", "ProductionPlantStorageLocation", "DeliverFromParty", "DeliverFromPlant", "DeliverFromPlantStorageLocation", "DeliverToParty", "DeliverToPlant", "DeliverToPlantStorageLocation", "ProductBaseUnit", "ProductProductionUnit", "ProductDeliveryUnit", "MRPArea", "MRPController", "ProductionVersion", "ProductionVersionItem", "BillOfMaterial", "Operations", "ProductionOrderQuantityInBaseUnit", "ProductionOrderQuantityInProductionUnit", "ProductionOrderQuantityInDeliveryUnit", "ProductionOrderPlannedScrapQtyInBaseUnit", "ProductionOrderMinimumLotSizeQuantity", "ProductionOrderStandardLotSizeQuantity", "ProductionOrderMaximumLotSizeQuantity", "ProductionOrderLotSizeRoundingQuantity", "ProductionOrderLotSizeIsFixed", "ProductionOrderPlannedStartDate", "ProductionOrderPlannedStartTime", "ProductionOrderPlannedEndDate", "ProductionOrderPlannedEndTime", "ProductionOrderActualReleaseDate", "ProductionOrderActualReleaseTime", "ProductionOrderActualStartDate", "ProductionOrderActualStartTime", "ProductionOrderActualEndDate", "ProductionOrderActualEndTime", "ConfirmedYieldQuantityInBaseUnit", "ConfirmedYieldQuantityInProductionUnit", "ScrappedQuantityInBaseUnit", "PlannedOrder", "PlannedOrderItem", "OrderID", "OrderItem", "ProductIsBatchManagedInProductionPlant", "BatchMgmtPolicyInProductionOrder", "ProductionOrderTargetedBatch", "ProductionOrderTargetedBatchValidityStartDate", "ProductionOrderTargetedBatchValidityStartTime", "ProductionOrderTargetedBatchValidityEndDate", "ProductionOrderTargetedBatchValidityEndTime", "ProductionOrderItemText", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsReleased", "IsPartiallyConfirmed", "IsConfirmed", "IsLocked", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformProductionOrderItemDatumColumnsWithDefault    = []string{}
	dataPlatformProductionOrderItemDatumPrimaryKeyColumns     = []string{"ProductionOrder", "ProductionOrderItem"}
	dataPlatformProductionOrderItemDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformProductionOrderItemDatumSlice is an alias for a slice of pointers to DataPlatformProductionOrderItemDatum.
	// This should almost always be used instead of []DataPlatformProductionOrderItemDatum.
	DataPlatformProductionOrderItemDatumSlice []*DataPlatformProductionOrderItemDatum

	dataPlatformProductionOrderItemDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformProductionOrderItemDatumType                 = reflect.TypeOf(&DataPlatformProductionOrderItemDatum{})
	dataPlatformProductionOrderItemDatumMapping              = queries.MakeStructMapping(dataPlatformProductionOrderItemDatumType)
	dataPlatformProductionOrderItemDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, dataPlatformProductionOrderItemDatumPrimaryKeyColumns)
	dataPlatformProductionOrderItemDatumInsertCacheMut       sync.RWMutex
	dataPlatformProductionOrderItemDatumInsertCache          = make(map[string]insertCache)
	dataPlatformProductionOrderItemDatumUpdateCacheMut       sync.RWMutex
	dataPlatformProductionOrderItemDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformProductionOrderItemDatumUpsertCacheMut       sync.RWMutex
	dataPlatformProductionOrderItemDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformProductionOrderItemDatum record from the query.
func (q dataPlatformProductionOrderItemDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformProductionOrderItemDatum, error) {
	o := &DataPlatformProductionOrderItemDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_production_order_item_data")
	}

	return o, nil
}

// All returns all DataPlatformProductionOrderItemDatum records from the query.
func (q dataPlatformProductionOrderItemDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformProductionOrderItemDatumSlice, error) {
	var o []*DataPlatformProductionOrderItemDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformProductionOrderItemDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformProductionOrderItemDatum records in the query.
func (q dataPlatformProductionOrderItemDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_production_order_item_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformProductionOrderItemDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_production_order_item_data exists")
	}

	return count > 0, nil
}

// BillOfMaterialDataPlatformBillOfMaterialHeaderDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) BillOfMaterialDataPlatformBillOfMaterialHeaderDatum(mods ...qm.QueryMod) dataPlatformBillOfMaterialHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillOfMaterial` = ?", o.BillOfMaterial),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBillOfMaterialHeaderData(queryMods...)
}

// DeliverFromPartyDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) DeliverFromPartyDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// DeliverToPartyDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) DeliverToPartyDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// Operation pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) Operation(mods ...qm.QueryMod) dataPlatformOperationsHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Operations` = ?", o.Operations),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOperationsHeaderData(queryMods...)
}

// OrderIDDataPlatformOrdersItemDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) OrderIDDataPlatformOrdersItemDatum(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OrderID` = ?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOrdersItemData(queryMods...)
}

// ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ProductBaseUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ProductDeliveryUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// ProductDataPlatformBatchMasterRecordBatchDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) ProductDataPlatformBatchMasterRecordBatchDatum(mods ...qm.QueryMod) dataPlatformBatchMasterRecordBatchDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.Product),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBatchMasterRecordBatchData(queryMods...)
}

// ProductionPlantDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) ProductionPlantDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Plant` = ?", o.ProductionPlant),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ProductProductionUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryRelationDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) BuyerDataPlatformSCRDeliveryRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryRelationData(queryMods...)
}

// BuyerDataPlatformSCRGeneralDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) BuyerDataPlatformSCRGeneralDatum(mods ...qm.QueryMod) dataPlatformSCRGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRGeneralData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderHeaderDatum pointed to by the foreign key.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformProductionOrderHeaderDatum(mods ...qm.QueryMod) dataPlatformProductionOrderHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionOrder` = ?", o.ProductionOrder),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderHeaderData(queryMods...)
}

// ProductionOrderDataPlatformDeliveryDocumentHeaderData retrieves all the data_platform_delivery_document_header_datum's DataPlatformDeliveryDocumentHeaderData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformDeliveryDocumentHeaderData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_header_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformDeliveryDocumentHeaderData(queryMods...)
}

// ProductionOrderDataPlatformDeliveryDocumentItemData retrieves all the data_platform_delivery_document_item_datum's DataPlatformDeliveryDocumentItemData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformDeliveryDocumentItemData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_item_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformDeliveryDocumentItemData(queryMods...)
}

// ProductionOrderDataPlatformOrdersHeaderData retrieves all the data_platform_orders_header_datum's DataPlatformOrdersHeaderData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformOrdersHeaderData(mods ...qm.QueryMod) dataPlatformOrdersHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_header_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformOrdersHeaderData(queryMods...)
}

// ProductionOrderDataPlatformOrdersItemData retrieves all the data_platform_orders_item_datum's DataPlatformOrdersItemData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformOrdersItemData(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformOrdersItemData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemComponentData retrieves all the data_platform_production_order_item_component_datum's DataPlatformProductionOrderItemComponentData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformProductionOrderItemComponentData(mods ...qm.QueryMod) dataPlatformProductionOrderItemComponentDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_production_order_item_component_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformProductionOrderItemComponentData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemOperationData retrieves all the data_platform_production_order_item_operation_datum's DataPlatformProductionOrderItemOperationData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformProductionOrderItemOperationData(mods ...qm.QueryMod) dataPlatformProductionOrderItemOperationDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_production_order_item_operation_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformProductionOrderItemOperationData(queryMods...)
}

// ProductionOrderDataPlatformPurchaseRequisitionHeaderData retrieves all the data_platform_purchase_requisition_header_datum's DataPlatformPurchaseRequisitionHeaderData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformPurchaseRequisitionHeaderData(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_purchase_requisition_header_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformPurchaseRequisitionHeaderData(queryMods...)
}

// ProductionOrderDataPlatformPurchaseRequisitionItemData retrieves all the data_platform_purchase_requisition_item_datum's DataPlatformPurchaseRequisitionItemData with an executor via ProductionOrder column.
func (o *DataPlatformProductionOrderItemDatum) ProductionOrderDataPlatformPurchaseRequisitionItemData(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_purchase_requisition_item_data`.`ProductionOrder`=?", o.ProductionOrder),
	)

	return DataPlatformPurchaseRequisitionItemData(queryMods...)
}

// LoadBillOfMaterialDataPlatformBillOfMaterialHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadBillOfMaterialDataPlatformBillOfMaterialHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.BillOfMaterial)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.BillOfMaterial {
					continue Outer
				}
			}

			args = append(args, obj.BillOfMaterial)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_bill_of_material_header_data`),
		qm.WhereIn(`data_platform_bill_of_material_header_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBillOfMaterialHeaderDatum")
	}

	var resultSlice []*DataPlatformBillOfMaterialHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBillOfMaterialHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_bill_of_material_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_bill_of_material_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BillOfMaterial == foreign.BillOfMaterial {
				local.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.DeliverFromParty)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliverFromParty {
					continue Outer
				}
			}

			args = append(args, obj.DeliverFromParty)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliverFromParty == foreign.BusinessPartner {
				local.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.DeliverToParty)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliverToParty {
					continue Outer
				}
			}

			args = append(args, obj.DeliverToParty)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliverToParty == foreign.BusinessPartner {
				local.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadOperation allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadOperation(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.Operations)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Operations {
					continue Outer
				}
			}

			args = append(args, obj.Operations)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_operations_header_data`),
		qm.WhereIn(`data_platform_operations_header_data.Operations in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOperationsHeaderDatum")
	}

	var resultSlice []*DataPlatformOperationsHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOperationsHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_operations_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_operations_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Operation = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Operations == foreign.Operations {
				local.R.Operation = foreign
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadOrderIDDataPlatformOrdersItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		if !queries.IsNil(object.OrderID) {
			args = append(args, object.OrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OrderID) {
				args = append(args, obj.OrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOrdersItemDatum")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOrdersItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrderIDDataPlatformOrdersItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformOrdersItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductBaseUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductBaseUnit {
					continue Outer
				}
			}

			args = append(args, obj.ProductBaseUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductBaseUnit == foreign.QuantityUnit {
				local.R.ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductDeliveryUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductDeliveryUnit {
					continue Outer
				}
			}

			args = append(args, obj.ProductDeliveryUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductDeliveryUnit == foreign.QuantityUnit {
				local.R.ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductDataPlatformBatchMasterRecordBatchDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.Product)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_batch_master_record_batch_data`),
		qm.WhereIn(`data_platform_batch_master_record_batch_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBatchMasterRecordBatchDatum")
	}

	var resultSlice []*DataPlatformBatchMasterRecordBatchDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBatchMasterRecordBatchDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_batch_master_record_batch_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_batch_master_record_batch_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductDataPlatformBatchMasterRecordBatchDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Product == foreign.Product {
				local.R.ProductDataPlatformBatchMasterRecordBatchDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionPlantDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionPlantDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionPlant)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductionPlant {
					continue Outer
				}
			}

			args = append(args, obj.ProductionPlant)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.Plant in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionPlantDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductionPlant == foreign.Plant {
				local.R.ProductionPlantDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductProductionUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductProductionUnit {
					continue Outer
				}
			}

			args = append(args, obj.ProductProductionUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductProductionUnit == foreign.QuantityUnit {
				local.R.ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadBuyerDataPlatformSCRGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_general_data`),
		qm.WhereIn(`data_platform_scr_general_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRGeneralDatum")
	}

	var resultSlice []*DataPlatformSCRGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformProductionOrderHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductionOrder {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_header_data`),
		qm.WhereIn(`data_platform_production_order_header_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderHeaderDatum")
	}

	var resultSlice []*DataPlatformProductionOrderHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionOrderDataPlatformProductionOrderHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductionOrder == foreign.ProductionOrder {
				local.R.ProductionOrderDataPlatformProductionOrderHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformDeliveryDocumentHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformDeliveryDocumentHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_header_data`),
		qm.WhereIn(`data_platform_delivery_document_header_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_header_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_header_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData = append(local.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformDeliveryDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformDeliveryDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_item_data`),
		qm.WhereIn(`data_platform_delivery_document_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_item_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_item_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformDeliveryDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformDeliveryDocumentItemData = append(local.R.ProductionOrderDataPlatformDeliveryDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformOrdersHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformOrdersHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_header_data`),
		qm.WhereIn(`data_platform_orders_header_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_header_data")
	}

	var resultSlice []*DataPlatformOrdersHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_header_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformOrdersHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformOrdersHeaderData = append(local.R.ProductionOrderDataPlatformOrdersHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformOrdersItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformOrdersItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_data")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformOrdersItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformOrdersItemData = append(local.R.ProductionOrderDataPlatformOrdersItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemComponentData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformProductionOrderItemComponentData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductionOrder {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_component_data`),
		qm.WhereIn(`data_platform_production_order_item_component_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_production_order_item_component_data")
	}

	var resultSlice []*DataPlatformProductionOrderItemComponentDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_production_order_item_component_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_production_order_item_component_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_component_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformProductionOrderItemComponentData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ProductionOrder == foreign.ProductionOrder {
				local.R.ProductionOrderDataPlatformProductionOrderItemComponentData = append(local.R.ProductionOrderDataPlatformProductionOrderItemComponentData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemOperationData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformProductionOrderItemOperationData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if a == obj.ProductionOrder {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_operation_data`),
		qm.WhereIn(`data_platform_production_order_item_operation_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_production_order_item_operation_data")
	}

	var resultSlice []*DataPlatformProductionOrderItemOperationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_production_order_item_operation_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_production_order_item_operation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_operation_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformProductionOrderItemOperationData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ProductionOrder == foreign.ProductionOrder {
				local.R.ProductionOrderDataPlatformProductionOrderItemOperationData = append(local.R.ProductionOrderDataPlatformProductionOrderItemOperationData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformPurchaseRequisitionHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_purchase_requisition_header_data`),
		qm.WhereIn(`data_platform_purchase_requisition_header_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_purchase_requisition_header_data")
	}

	var resultSlice []*DataPlatformPurchaseRequisitionHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_purchase_requisition_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_purchase_requisition_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_purchase_requisition_header_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData = append(local.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformPurchaseRequisitionItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformProductionOrderItemDatumL) LoadProductionOrderDataPlatformPurchaseRequisitionItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductionOrderItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductionOrderItemDatum
	var object *DataPlatformProductionOrderItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductionOrderItemDatum.(*DataPlatformProductionOrderItemDatum)
		if !ok {
			object = new(DataPlatformProductionOrderItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductionOrderItemDatum.(*[]*DataPlatformProductionOrderItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductionOrderItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductionOrderItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductionOrderItemDatumR{}
		}
		args = append(args, object.ProductionOrder)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductionOrderItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			args = append(args, obj.ProductionOrder)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_purchase_requisition_item_data`),
		qm.WhereIn(`data_platform_purchase_requisition_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_purchase_requisition_item_data")
	}

	var resultSlice []*DataPlatformPurchaseRequisitionItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_purchase_requisition_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_purchase_requisition_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_purchase_requisition_item_data")
	}

	if singular {
		object.R.ProductionOrderDataPlatformPurchaseRequisitionItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformPurchaseRequisitionItemData = append(local.R.ProductionOrderDataPlatformPurchaseRequisitionItemData, foreign)
				break
			}
		}
	}

	return nil
}

// SetBillOfMaterialDataPlatformBillOfMaterialHeaderDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetBillOfMaterialDataPlatformBillOfMaterialHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBillOfMaterialHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillOfMaterial, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BillOfMaterial = related.BillOfMaterial
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			BillOfMaterialDataPlatformBillOfMaterialHeaderDatum: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = related
	}

	return nil
}

// SetDeliverFromPartyDataPlatformPlantStorageLocationDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliverFromParty = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			DeliverFromPartyDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// SetDeliverToPartyDataPlatformPlantStorageLocationDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliverToParty = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			DeliverToPartyDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// SetOperation of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.Operation to related.
func (o *DataPlatformProductionOrderItemDatum) SetOperation(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOperationsHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Operations"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Operations, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Operations = related.Operations
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			Operation: related,
		}
	} else {
		o.R.Operation = related
	}

	return nil
}

// SetOrderIDDataPlatformOrdersItemDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOrdersItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OrderID, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OrderID, related.OrderID)
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			OrderIDDataPlatformOrdersItemDatum: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemDatum = related
	}

	return nil
}

// RemoveOrderIDDataPlatformOrdersItemDatum relationship.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum to nil.
func (o *DataPlatformProductionOrderItemDatum) RemoveOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformOrdersItemDatum) error {
	var err error

	queries.SetScanner(&o.OrderID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformOrdersItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductBaseUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductBaseUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ProductBaseUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductDeliveryUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductDeliveryUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ProductDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetProductDataPlatformBatchMasterRecordBatchDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.ProductDataPlatformBatchMasterRecordBatchDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Product = related.Product
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductDataPlatformBatchMasterRecordBatchDatum: related,
		}
	} else {
		o.R.ProductDataPlatformBatchMasterRecordBatchDatum = related
	}

	return nil
}

// SetProductionPlantDataPlatformPlantStorageLocationDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.ProductionPlantDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionPlantDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionPlant"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Plant, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductionPlant = related.Plant
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionPlantDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.ProductionPlantDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// SetProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductProductionUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductProductionUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ProductProductionUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryRelationDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryRelationDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			BuyerDataPlatformSCRDeliveryRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryRelationDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRGeneralDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRGeneralDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetBuyerDataPlatformSCRGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			BuyerDataPlatformSCRGeneralDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRGeneralDatum = related
	}

	return nil
}

// SetProductionOrderDataPlatformProductionOrderHeaderDatum of the dataPlatformProductionOrderItemDatum to the related item.
// Sets o.R.ProductionOrderDataPlatformProductionOrderHeaderDatum to related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformProductionOrderHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionOrder, o.ProductionOrder, o.ProductionOrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductionOrder = related.ProductionOrder
	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformProductionOrderHeaderDatum: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderHeaderDatum = related
	}

	return nil
}

// AddProductionOrderDataPlatformDeliveryDocumentHeaderData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.DeliveryDocument}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformDeliveryDocumentHeaderData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData = append(o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData, related...)
	}

	return nil
}

// SetProductionOrderDataPlatformDeliveryDocumentHeaderData removes all previously related items of the
// data_platform_production_order_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum's ProductionOrderDataPlatformDeliveryDocumentHeaderData accordingly.
// Replaces o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData with related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	query := "update `data_platform_delivery_document_header_data` set `ProductionOrder` = null where `ProductionOrder` = ?"
	values := []interface{}{o.ProductionOrder}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData = nil
	}

	return o.AddProductionOrderDataPlatformDeliveryDocumentHeaderData(ctx, exec, insert, related...)
}

// RemoveProductionOrderDataPlatformDeliveryDocumentHeaderData relationships from objects passed in.
// Removes related items from R.ProductionOrderDataPlatformDeliveryDocumentHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformProductionOrderItemDatum) RemoveProductionOrderDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductionOrder, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData[i] = o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData[ln-1]
			}
			o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData = o.R.ProductionOrderDataPlatformDeliveryDocumentHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddProductionOrderDataPlatformDeliveryDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformDeliveryDocumentItemData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformDeliveryDocumentItemData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformDeliveryDocumentItemData = append(o.R.ProductionOrderDataPlatformDeliveryDocumentItemData, related...)
	}

	return nil
}

// SetProductionOrderDataPlatformDeliveryDocumentItemData removes all previously related items of the
// data_platform_production_order_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum's ProductionOrderDataPlatformDeliveryDocumentItemData accordingly.
// Replaces o.R.ProductionOrderDataPlatformDeliveryDocumentItemData with related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	query := "update `data_platform_delivery_document_item_data` set `ProductionOrder` = null where `ProductionOrder` = ?"
	values := []interface{}{o.ProductionOrder}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformDeliveryDocumentItemData = nil
	}

	return o.AddProductionOrderDataPlatformDeliveryDocumentItemData(ctx, exec, insert, related...)
}

// RemoveProductionOrderDataPlatformDeliveryDocumentItemData relationships from objects passed in.
// Removes related items from R.ProductionOrderDataPlatformDeliveryDocumentItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformProductionOrderItemDatum) RemoveProductionOrderDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductionOrder, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductionOrderDataPlatformDeliveryDocumentItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductionOrderDataPlatformDeliveryDocumentItemData)
			if ln > 1 && i < ln-1 {
				o.R.ProductionOrderDataPlatformDeliveryDocumentItemData[i] = o.R.ProductionOrderDataPlatformDeliveryDocumentItemData[ln-1]
			}
			o.R.ProductionOrderDataPlatformDeliveryDocumentItemData = o.R.ProductionOrderDataPlatformDeliveryDocumentItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddProductionOrderDataPlatformOrdersHeaderData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformOrdersHeaderData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformOrdersHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.OrderID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformOrdersHeaderData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformOrdersHeaderData = append(o.R.ProductionOrderDataPlatformOrdersHeaderData, related...)
	}

	return nil
}

// SetProductionOrderDataPlatformOrdersHeaderData removes all previously related items of the
// data_platform_production_order_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum's ProductionOrderDataPlatformOrdersHeaderData accordingly.
// Replaces o.R.ProductionOrderDataPlatformOrdersHeaderData with related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformOrdersHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersHeaderDatum) error {
	query := "update `data_platform_orders_header_data` set `ProductionOrder` = null where `ProductionOrder` = ?"
	values := []interface{}{o.ProductionOrder}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformOrdersHeaderData = nil
	}

	return o.AddProductionOrderDataPlatformOrdersHeaderData(ctx, exec, insert, related...)
}

// RemoveProductionOrderDataPlatformOrdersHeaderData relationships from objects passed in.
// Removes related items from R.ProductionOrderDataPlatformOrdersHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformProductionOrderItemDatum) RemoveProductionOrderDataPlatformOrdersHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformOrdersHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductionOrder, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductionOrderDataPlatformOrdersHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductionOrderDataPlatformOrdersHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.ProductionOrderDataPlatformOrdersHeaderData[i] = o.R.ProductionOrderDataPlatformOrdersHeaderData[ln-1]
			}
			o.R.ProductionOrderDataPlatformOrdersHeaderData = o.R.ProductionOrderDataPlatformOrdersHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddProductionOrderDataPlatformOrdersItemData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformOrdersItemData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.OrderID, rel.OrderItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformOrdersItemData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformOrdersItemData = append(o.R.ProductionOrderDataPlatformOrdersItemData, related...)
	}

	return nil
}

// SetProductionOrderDataPlatformOrdersItemData removes all previously related items of the
// data_platform_production_order_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum's ProductionOrderDataPlatformOrdersItemData accordingly.
// Replaces o.R.ProductionOrderDataPlatformOrdersItemData with related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDatum) error {
	query := "update `data_platform_orders_item_data` set `ProductionOrder` = null where `ProductionOrder` = ?"
	values := []interface{}{o.ProductionOrder}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformOrdersItemData = nil
	}

	return o.AddProductionOrderDataPlatformOrdersItemData(ctx, exec, insert, related...)
}

// RemoveProductionOrderDataPlatformOrdersItemData relationships from objects passed in.
// Removes related items from R.ProductionOrderDataPlatformOrdersItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformProductionOrderItemDatum) RemoveProductionOrderDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformOrdersItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductionOrder, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductionOrderDataPlatformOrdersItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductionOrderDataPlatformOrdersItemData)
			if ln > 1 && i < ln-1 {
				o.R.ProductionOrderDataPlatformOrdersItemData[i] = o.R.ProductionOrderDataPlatformOrdersItemData[ln-1]
			}
			o.R.ProductionOrderDataPlatformOrdersItemData = o.R.ProductionOrderDataPlatformOrdersItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddProductionOrderDataPlatformProductionOrderItemComponentData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformProductionOrderItemComponentData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformProductionOrderItemComponentData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderItemComponentDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProductionOrder = o.ProductionOrder
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_production_order_item_component_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemComponentDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.ProductionOrder, rel.ProductionOrderItem, rel.BillOfMaterial, rel.BillOfMaterialItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProductionOrder = o.ProductionOrder
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformProductionOrderItemComponentData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemComponentData = append(o.R.ProductionOrderDataPlatformProductionOrderItemComponentData, related...)
	}

	return nil
}

// AddProductionOrderDataPlatformProductionOrderItemOperationData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformProductionOrderItemOperationData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformProductionOrderItemOperationData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderItemOperationDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ProductionOrder = o.ProductionOrder
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_production_order_item_operation_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemOperationDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.ProductionOrder, rel.ProductionOrderItem, rel.Operations, rel.OperationsItem, rel.OperationID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ProductionOrder = o.ProductionOrder
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformProductionOrderItemOperationData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemOperationData = append(o.R.ProductionOrderDataPlatformProductionOrderItemOperationData, related...)
	}

	return nil
}

// AddProductionOrderDataPlatformPurchaseRequisitionHeaderData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_purchase_requisition_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.PurchaseRequisition}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformPurchaseRequisitionHeaderData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData = append(o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData, related...)
	}

	return nil
}

// SetProductionOrderDataPlatformPurchaseRequisitionHeaderData removes all previously related items of the
// data_platform_production_order_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum's ProductionOrderDataPlatformPurchaseRequisitionHeaderData accordingly.
// Replaces o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData with related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionHeaderDatum) error {
	query := "update `data_platform_purchase_requisition_header_data` set `ProductionOrder` = null where `ProductionOrder` = ?"
	values := []interface{}{o.ProductionOrder}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData = nil
	}

	return o.AddProductionOrderDataPlatformPurchaseRequisitionHeaderData(ctx, exec, insert, related...)
}

// RemoveProductionOrderDataPlatformPurchaseRequisitionHeaderData relationships from objects passed in.
// Removes related items from R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformProductionOrderItemDatum) RemoveProductionOrderDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPurchaseRequisitionHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductionOrder, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData[i] = o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData[ln-1]
			}
			o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData = o.R.ProductionOrderDataPlatformPurchaseRequisitionHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddProductionOrderDataPlatformPurchaseRequisitionItemData adds the given related objects to the existing relationships
// of the data_platform_production_order_item_datum, optionally inserting them as new records.
// Appends related to o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData.
func (o *DataPlatformProductionOrderItemDatum) AddProductionOrderDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.ProductionOrder, rel.PurchaseRequisition, rel.PurchaseRequisitionItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ProductionOrder, o.ProductionOrder)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformProductionOrderItemDatumR{
			ProductionOrderDataPlatformPurchaseRequisitionItemData: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData = append(o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData, related...)
	}

	return nil
}

// SetProductionOrderDataPlatformPurchaseRequisitionItemData removes all previously related items of the
// data_platform_production_order_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum's ProductionOrderDataPlatformPurchaseRequisitionItemData accordingly.
// Replaces o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData with related.
func (o *DataPlatformProductionOrderItemDatum) SetProductionOrderDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	query := "update `data_platform_purchase_requisition_item_data` set `ProductionOrder` = null where `ProductionOrder` = ?"
	values := []interface{}{o.ProductionOrder}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData = nil
	}

	return o.AddProductionOrderDataPlatformPurchaseRequisitionItemData(ctx, exec, insert, related...)
}

// RemoveProductionOrderDataPlatformPurchaseRequisitionItemData relationships from objects passed in.
// Removes related items from R.ProductionOrderDataPlatformPurchaseRequisitionItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformProductionOrderItemDatum) RemoveProductionOrderDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ProductionOrder, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData)
			if ln > 1 && i < ln-1 {
				o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData[i] = o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData[ln-1]
			}
			o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData = o.R.ProductionOrderDataPlatformPurchaseRequisitionItemData[:ln-1]
			break
		}
	}

	return nil
}

// DataPlatformProductionOrderItemData retrieves all the records using an executor.
func DataPlatformProductionOrderItemData(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	mods = append(mods, qm.From("`data_platform_production_order_item_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_production_order_item_data`.*"})
	}

	return dataPlatformProductionOrderItemDatumQuery{q}
}

// FindDataPlatformProductionOrderItemDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, productionOrder int, productionOrderItem int, selectCols ...string) (*DataPlatformProductionOrderItemDatum, error) {
	dataPlatformProductionOrderItemDatumObj := &DataPlatformProductionOrderItemDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_production_order_item_data` where `ProductionOrder`=? AND `ProductionOrderItem`=?", sel,
	)

	q := queries.Raw(query, productionOrder, productionOrderItem)

	err := q.Bind(ctx, exec, dataPlatformProductionOrderItemDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_production_order_item_data")
	}

	return dataPlatformProductionOrderItemDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformProductionOrderItemDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_production_order_item_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformProductionOrderItemDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformProductionOrderItemDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformProductionOrderItemDatumInsertCache[key]
	dataPlatformProductionOrderItemDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformProductionOrderItemDatumAllColumns,
			dataPlatformProductionOrderItemDatumColumnsWithDefault,
			dataPlatformProductionOrderItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_production_order_item_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_production_order_item_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_production_order_item_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_production_order_item_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ProductionOrder,
		o.ProductionOrderItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_production_order_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformProductionOrderItemDatumInsertCacheMut.Lock()
		dataPlatformProductionOrderItemDatumInsertCache[key] = cache
		dataPlatformProductionOrderItemDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformProductionOrderItemDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformProductionOrderItemDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformProductionOrderItemDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformProductionOrderItemDatumUpdateCache[key]
	dataPlatformProductionOrderItemDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformProductionOrderItemDatumAllColumns,
			dataPlatformProductionOrderItemDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_production_order_item_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, append(wl, dataPlatformProductionOrderItemDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_production_order_item_data row")
	}

	if !cached {
		dataPlatformProductionOrderItemDatumUpdateCacheMut.Lock()
		dataPlatformProductionOrderItemDatumUpdateCache[key] = cache
		dataPlatformProductionOrderItemDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformProductionOrderItemDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_production_order_item_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformProductionOrderItemDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductionOrderItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformProductionOrderItemDatum slice")
	}

	return nil
}

var mySQLDataPlatformProductionOrderItemDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformProductionOrderItemDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_production_order_item_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformProductionOrderItemDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformProductionOrderItemDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformProductionOrderItemDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformProductionOrderItemDatumUpsertCache[key]
	dataPlatformProductionOrderItemDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformProductionOrderItemDatumAllColumns,
			dataPlatformProductionOrderItemDatumColumnsWithDefault,
			dataPlatformProductionOrderItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformProductionOrderItemDatumAllColumns,
			dataPlatformProductionOrderItemDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_production_order_item_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_production_order_item_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_production_order_item_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_production_order_item_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformProductionOrderItemDatumType, dataPlatformProductionOrderItemDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_production_order_item_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_production_order_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformProductionOrderItemDatumUpsertCacheMut.Lock()
		dataPlatformProductionOrderItemDatumUpsertCache[key] = cache
		dataPlatformProductionOrderItemDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformProductionOrderItemDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformProductionOrderItemDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformProductionOrderItemDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformProductionOrderItemDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_production_order_item_data` WHERE `ProductionOrder`=? AND `ProductionOrderItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_production_order_item_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformProductionOrderItemDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformProductionOrderItemDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_production_order_item_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformProductionOrderItemDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductionOrderItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_production_order_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformProductionOrderItemDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformProductionOrderItemDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformProductionOrderItemDatum(ctx, exec, o.ProductionOrder, o.ProductionOrderItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformProductionOrderItemDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformProductionOrderItemDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductionOrderItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_production_order_item_data`.* FROM `data_platform_production_order_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformProductionOrderItemDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformProductionOrderItemDatumExists checks if the DataPlatformProductionOrderItemDatum row exists.
func DataPlatformProductionOrderItemDatumExists(ctx context.Context, exec boil.ContextExecutor, productionOrder int, productionOrderItem int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_production_order_item_data` where `ProductionOrder`=? AND `ProductionOrderItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, productionOrder, productionOrderItem)
	}
	row := exec.QueryRowContext(ctx, sql, productionOrder, productionOrderItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_production_order_item_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformProductionOrderItemDatum row exists.
func (o *DataPlatformProductionOrderItemDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformProductionOrderItemDatumExists(ctx, exec, o.ProductionOrder, o.ProductionOrderItem)
}
