// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformPaymentRequisitionHeaderDatum is an object representing the database table.
type DataPlatformPaymentRequisitionHeaderDatum struct {
	PayerPaymentRequisitionID       int         `boil:"PayerPaymentRequisitionID" json:"PayerPaymentRequisitionID" toml:"PayerPaymentRequisitionID" yaml:"PayerPaymentRequisitionID"`
	Payer                           int         `boil:"Payer" json:"Payer" toml:"Payer" yaml:"Payer"`
	PayerPaymentDate                string      `boil:"PayerPaymentDate" json:"PayerPaymentDate" toml:"PayerPaymentDate" yaml:"PayerPaymentDate"`
	PaymentReqnStatus               string      `boil:"PaymentReqnStatus" json:"PaymentReqnStatus" toml:"PaymentReqnStatus" yaml:"PaymentReqnStatus"`
	AcceptanceNoByFinInst           null.String `boil:"AcceptanceNoByFinInst" json:"AcceptanceNoByFinInst,omitempty" toml:"AcceptanceNoByFinInst" yaml:"AcceptanceNoByFinInst,omitempty"`
	PaytReqnAmtInTransCrcy          float32     `boil:"PaytReqnAmtInTransCrcy" json:"PaytReqnAmtInTransCrcy" toml:"PaytReqnAmtInTransCrcy" yaml:"PaytReqnAmtInTransCrcy"`
	Currency                        string      `boil:"Currency" json:"Currency" toml:"Currency" yaml:"Currency"`
	PaymentMethod                   string      `boil:"PaymentMethod" json:"PaymentMethod" toml:"PaymentMethod" yaml:"PaymentMethod"`
	PayerPostingDate                string      `boil:"PayerPostingDate" json:"PayerPostingDate" toml:"PayerPostingDate" yaml:"PayerPostingDate"`
	PayerHouseBank                  null.String `boil:"PayerHouseBank" json:"PayerHouseBank,omitempty" toml:"PayerHouseBank" yaml:"PayerHouseBank,omitempty"`
	PayerHouseBankAccount           null.String `boil:"PayerHouseBankAccount" json:"PayerHouseBankAccount,omitempty" toml:"PayerHouseBankAccount" yaml:"PayerHouseBankAccount,omitempty"`
	PayerFinInstCountry             string      `boil:"PayerFinInstCountry" json:"PayerFinInstCountry" toml:"PayerFinInstCountry" yaml:"PayerFinInstCountry"`
	PayerFinInstCode                string      `boil:"PayerFinInstCode" json:"PayerFinInstCode" toml:"PayerFinInstCode" yaml:"PayerFinInstCode"`
	PayerFinInstBranchCode          string      `boil:"PayerFinInstBranchCode" json:"PayerFinInstBranchCode" toml:"PayerFinInstBranchCode" yaml:"PayerFinInstBranchCode"`
	PayerFinInstFullCode            string      `boil:"PayerFinInstFullCode" json:"PayerFinInstFullCode" toml:"PayerFinInstFullCode" yaml:"PayerFinInstFullCode"`
	PayerFinInstSWIFTCode           null.String `boil:"PayerFinInstSWIFTCode" json:"PayerFinInstSWIFTCode,omitempty" toml:"PayerFinInstSWIFTCode" yaml:"PayerFinInstSWIFTCode,omitempty"`
	PayerInternalFinInstCustomerID  int         `boil:"PayerInternalFinInstCustomerID" json:"PayerInternalFinInstCustomerID" toml:"PayerInternalFinInstCustomerID" yaml:"PayerInternalFinInstCustomerID"`
	PayerInternalFinInstAccountID   int         `boil:"PayerInternalFinInstAccountID" json:"PayerInternalFinInstAccountID" toml:"PayerInternalFinInstAccountID" yaml:"PayerInternalFinInstAccountID"`
	PayerFinInstControlKey          string      `boil:"PayerFinInstControlKey" json:"PayerFinInstControlKey" toml:"PayerFinInstControlKey" yaml:"PayerFinInstControlKey"`
	PayerFinInstAccount             string      `boil:"PayerFinInstAccount" json:"PayerFinInstAccount" toml:"PayerFinInstAccount" yaml:"PayerFinInstAccount"`
	PayerFinInstAccountName         string      `boil:"PayerFinInstAccountName" json:"PayerFinInstAccountName" toml:"PayerFinInstAccountName" yaml:"PayerFinInstAccountName"`
	PayerFinInstName                string      `boil:"PayerFinInstName" json:"PayerFinInstName" toml:"PayerFinInstName" yaml:"PayerFinInstName"`
	PayerFinInstBranchName          string      `boil:"PayerFinInstBranchName" json:"PayerFinInstBranchName" toml:"PayerFinInstBranchName" yaml:"PayerFinInstBranchName"`
	PayerFinInstCustomerIDByFinInst string      `boil:"PayerFinInstCustomerIDByFinInst" json:"PayerFinInstCustomerIDByFinInst" toml:"PayerFinInstCustomerIDByFinInst" yaml:"PayerFinInstCustomerIDByFinInst"`
	PaymentRequisitionIsCanceled    null.Bool   `boil:"PaymentRequisitionIsCanceled" json:"PaymentRequisitionIsCanceled,omitempty" toml:"PaymentRequisitionIsCanceled" yaml:"PaymentRequisitionIsCanceled,omitempty"`
	CreationDateTime                null.String `boil:"CreationDateTime" json:"CreationDateTime,omitempty" toml:"CreationDateTime" yaml:"CreationDateTime,omitempty"`
	ChangedOnDateTime               null.String `boil:"ChangedOnDateTime" json:"ChangedOnDateTime,omitempty" toml:"ChangedOnDateTime" yaml:"ChangedOnDateTime,omitempty"`

	R *dataPlatformPaymentRequisitionHeaderDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformPaymentRequisitionHeaderDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformPaymentRequisitionHeaderDatumColumns = struct {
	PayerPaymentRequisitionID       string
	Payer                           string
	PayerPaymentDate                string
	PaymentReqnStatus               string
	AcceptanceNoByFinInst           string
	PaytReqnAmtInTransCrcy          string
	Currency                        string
	PaymentMethod                   string
	PayerPostingDate                string
	PayerHouseBank                  string
	PayerHouseBankAccount           string
	PayerFinInstCountry             string
	PayerFinInstCode                string
	PayerFinInstBranchCode          string
	PayerFinInstFullCode            string
	PayerFinInstSWIFTCode           string
	PayerInternalFinInstCustomerID  string
	PayerInternalFinInstAccountID   string
	PayerFinInstControlKey          string
	PayerFinInstAccount             string
	PayerFinInstAccountName         string
	PayerFinInstName                string
	PayerFinInstBranchName          string
	PayerFinInstCustomerIDByFinInst string
	PaymentRequisitionIsCanceled    string
	CreationDateTime                string
	ChangedOnDateTime               string
}{
	PayerPaymentRequisitionID:       "PayerPaymentRequisitionID",
	Payer:                           "Payer",
	PayerPaymentDate:                "PayerPaymentDate",
	PaymentReqnStatus:               "PaymentReqnStatus",
	AcceptanceNoByFinInst:           "AcceptanceNoByFinInst",
	PaytReqnAmtInTransCrcy:          "PaytReqnAmtInTransCrcy",
	Currency:                        "Currency",
	PaymentMethod:                   "PaymentMethod",
	PayerPostingDate:                "PayerPostingDate",
	PayerHouseBank:                  "PayerHouseBank",
	PayerHouseBankAccount:           "PayerHouseBankAccount",
	PayerFinInstCountry:             "PayerFinInstCountry",
	PayerFinInstCode:                "PayerFinInstCode",
	PayerFinInstBranchCode:          "PayerFinInstBranchCode",
	PayerFinInstFullCode:            "PayerFinInstFullCode",
	PayerFinInstSWIFTCode:           "PayerFinInstSWIFTCode",
	PayerInternalFinInstCustomerID:  "PayerInternalFinInstCustomerID",
	PayerInternalFinInstAccountID:   "PayerInternalFinInstAccountID",
	PayerFinInstControlKey:          "PayerFinInstControlKey",
	PayerFinInstAccount:             "PayerFinInstAccount",
	PayerFinInstAccountName:         "PayerFinInstAccountName",
	PayerFinInstName:                "PayerFinInstName",
	PayerFinInstBranchName:          "PayerFinInstBranchName",
	PayerFinInstCustomerIDByFinInst: "PayerFinInstCustomerIDByFinInst",
	PaymentRequisitionIsCanceled:    "PaymentRequisitionIsCanceled",
	CreationDateTime:                "CreationDateTime",
	ChangedOnDateTime:               "ChangedOnDateTime",
}

var DataPlatformPaymentRequisitionHeaderDatumTableColumns = struct {
	PayerPaymentRequisitionID       string
	Payer                           string
	PayerPaymentDate                string
	PaymentReqnStatus               string
	AcceptanceNoByFinInst           string
	PaytReqnAmtInTransCrcy          string
	Currency                        string
	PaymentMethod                   string
	PayerPostingDate                string
	PayerHouseBank                  string
	PayerHouseBankAccount           string
	PayerFinInstCountry             string
	PayerFinInstCode                string
	PayerFinInstBranchCode          string
	PayerFinInstFullCode            string
	PayerFinInstSWIFTCode           string
	PayerInternalFinInstCustomerID  string
	PayerInternalFinInstAccountID   string
	PayerFinInstControlKey          string
	PayerFinInstAccount             string
	PayerFinInstAccountName         string
	PayerFinInstName                string
	PayerFinInstBranchName          string
	PayerFinInstCustomerIDByFinInst string
	PaymentRequisitionIsCanceled    string
	CreationDateTime                string
	ChangedOnDateTime               string
}{
	PayerPaymentRequisitionID:       "data_platform_payment_requisition_header_data.PayerPaymentRequisitionID",
	Payer:                           "data_platform_payment_requisition_header_data.Payer",
	PayerPaymentDate:                "data_platform_payment_requisition_header_data.PayerPaymentDate",
	PaymentReqnStatus:               "data_platform_payment_requisition_header_data.PaymentReqnStatus",
	AcceptanceNoByFinInst:           "data_platform_payment_requisition_header_data.AcceptanceNoByFinInst",
	PaytReqnAmtInTransCrcy:          "data_platform_payment_requisition_header_data.PaytReqnAmtInTransCrcy",
	Currency:                        "data_platform_payment_requisition_header_data.Currency",
	PaymentMethod:                   "data_platform_payment_requisition_header_data.PaymentMethod",
	PayerPostingDate:                "data_platform_payment_requisition_header_data.PayerPostingDate",
	PayerHouseBank:                  "data_platform_payment_requisition_header_data.PayerHouseBank",
	PayerHouseBankAccount:           "data_platform_payment_requisition_header_data.PayerHouseBankAccount",
	PayerFinInstCountry:             "data_platform_payment_requisition_header_data.PayerFinInstCountry",
	PayerFinInstCode:                "data_platform_payment_requisition_header_data.PayerFinInstCode",
	PayerFinInstBranchCode:          "data_platform_payment_requisition_header_data.PayerFinInstBranchCode",
	PayerFinInstFullCode:            "data_platform_payment_requisition_header_data.PayerFinInstFullCode",
	PayerFinInstSWIFTCode:           "data_platform_payment_requisition_header_data.PayerFinInstSWIFTCode",
	PayerInternalFinInstCustomerID:  "data_platform_payment_requisition_header_data.PayerInternalFinInstCustomerID",
	PayerInternalFinInstAccountID:   "data_platform_payment_requisition_header_data.PayerInternalFinInstAccountID",
	PayerFinInstControlKey:          "data_platform_payment_requisition_header_data.PayerFinInstControlKey",
	PayerFinInstAccount:             "data_platform_payment_requisition_header_data.PayerFinInstAccount",
	PayerFinInstAccountName:         "data_platform_payment_requisition_header_data.PayerFinInstAccountName",
	PayerFinInstName:                "data_platform_payment_requisition_header_data.PayerFinInstName",
	PayerFinInstBranchName:          "data_platform_payment_requisition_header_data.PayerFinInstBranchName",
	PayerFinInstCustomerIDByFinInst: "data_platform_payment_requisition_header_data.PayerFinInstCustomerIDByFinInst",
	PaymentRequisitionIsCanceled:    "data_platform_payment_requisition_header_data.PaymentRequisitionIsCanceled",
	CreationDateTime:                "data_platform_payment_requisition_header_data.CreationDateTime",
	ChangedOnDateTime:               "data_platform_payment_requisition_header_data.ChangedOnDateTime",
}

// Generated where

var DataPlatformPaymentRequisitionHeaderDatumWhere = struct {
	PayerPaymentRequisitionID       whereHelperint
	Payer                           whereHelperint
	PayerPaymentDate                whereHelperstring
	PaymentReqnStatus               whereHelperstring
	AcceptanceNoByFinInst           whereHelpernull_String
	PaytReqnAmtInTransCrcy          whereHelperfloat32
	Currency                        whereHelperstring
	PaymentMethod                   whereHelperstring
	PayerPostingDate                whereHelperstring
	PayerHouseBank                  whereHelpernull_String
	PayerHouseBankAccount           whereHelpernull_String
	PayerFinInstCountry             whereHelperstring
	PayerFinInstCode                whereHelperstring
	PayerFinInstBranchCode          whereHelperstring
	PayerFinInstFullCode            whereHelperstring
	PayerFinInstSWIFTCode           whereHelpernull_String
	PayerInternalFinInstCustomerID  whereHelperint
	PayerInternalFinInstAccountID   whereHelperint
	PayerFinInstControlKey          whereHelperstring
	PayerFinInstAccount             whereHelperstring
	PayerFinInstAccountName         whereHelperstring
	PayerFinInstName                whereHelperstring
	PayerFinInstBranchName          whereHelperstring
	PayerFinInstCustomerIDByFinInst whereHelperstring
	PaymentRequisitionIsCanceled    whereHelpernull_Bool
	CreationDateTime                whereHelpernull_String
	ChangedOnDateTime               whereHelpernull_String
}{
	PayerPaymentRequisitionID:       whereHelperint{field: "`data_platform_payment_requisition_header_data`.`PayerPaymentRequisitionID`"},
	Payer:                           whereHelperint{field: "`data_platform_payment_requisition_header_data`.`Payer`"},
	PayerPaymentDate:                whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerPaymentDate`"},
	PaymentReqnStatus:               whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PaymentReqnStatus`"},
	AcceptanceNoByFinInst:           whereHelpernull_String{field: "`data_platform_payment_requisition_header_data`.`AcceptanceNoByFinInst`"},
	PaytReqnAmtInTransCrcy:          whereHelperfloat32{field: "`data_platform_payment_requisition_header_data`.`PaytReqnAmtInTransCrcy`"},
	Currency:                        whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`Currency`"},
	PaymentMethod:                   whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PaymentMethod`"},
	PayerPostingDate:                whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerPostingDate`"},
	PayerHouseBank:                  whereHelpernull_String{field: "`data_platform_payment_requisition_header_data`.`PayerHouseBank`"},
	PayerHouseBankAccount:           whereHelpernull_String{field: "`data_platform_payment_requisition_header_data`.`PayerHouseBankAccount`"},
	PayerFinInstCountry:             whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstCountry`"},
	PayerFinInstCode:                whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstCode`"},
	PayerFinInstBranchCode:          whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstBranchCode`"},
	PayerFinInstFullCode:            whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstFullCode`"},
	PayerFinInstSWIFTCode:           whereHelpernull_String{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstSWIFTCode`"},
	PayerInternalFinInstCustomerID:  whereHelperint{field: "`data_platform_payment_requisition_header_data`.`PayerInternalFinInstCustomerID`"},
	PayerInternalFinInstAccountID:   whereHelperint{field: "`data_platform_payment_requisition_header_data`.`PayerInternalFinInstAccountID`"},
	PayerFinInstControlKey:          whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstControlKey`"},
	PayerFinInstAccount:             whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstAccount`"},
	PayerFinInstAccountName:         whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstAccountName`"},
	PayerFinInstName:                whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstName`"},
	PayerFinInstBranchName:          whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstBranchName`"},
	PayerFinInstCustomerIDByFinInst: whereHelperstring{field: "`data_platform_payment_requisition_header_data`.`PayerFinInstCustomerIDByFinInst`"},
	PaymentRequisitionIsCanceled:    whereHelpernull_Bool{field: "`data_platform_payment_requisition_header_data`.`PaymentRequisitionIsCanceled`"},
	CreationDateTime:                whereHelpernull_String{field: "`data_platform_payment_requisition_header_data`.`CreationDateTime`"},
	ChangedOnDateTime:               whereHelpernull_String{field: "`data_platform_payment_requisition_header_data`.`ChangedOnDateTime`"},
}

// DataPlatformPaymentRequisitionHeaderDatumRels is where relationship names are stored.
var DataPlatformPaymentRequisitionHeaderDatumRels = struct {
}{}

// dataPlatformPaymentRequisitionHeaderDatumR is where relationships are stored.
type dataPlatformPaymentRequisitionHeaderDatumR struct {
}

// NewStruct creates a new relationship struct
func (*dataPlatformPaymentRequisitionHeaderDatumR) NewStruct() *dataPlatformPaymentRequisitionHeaderDatumR {
	return &dataPlatformPaymentRequisitionHeaderDatumR{}
}

// dataPlatformPaymentRequisitionHeaderDatumL is where Load methods for each relationship are stored.
type dataPlatformPaymentRequisitionHeaderDatumL struct{}

var (
	dataPlatformPaymentRequisitionHeaderDatumAllColumns            = []string{"PayerPaymentRequisitionID", "Payer", "PayerPaymentDate", "PaymentReqnStatus", "AcceptanceNoByFinInst", "PaytReqnAmtInTransCrcy", "Currency", "PaymentMethod", "PayerPostingDate", "PayerHouseBank", "PayerHouseBankAccount", "PayerFinInstCountry", "PayerFinInstCode", "PayerFinInstBranchCode", "PayerFinInstFullCode", "PayerFinInstSWIFTCode", "PayerInternalFinInstCustomerID", "PayerInternalFinInstAccountID", "PayerFinInstControlKey", "PayerFinInstAccount", "PayerFinInstAccountName", "PayerFinInstName", "PayerFinInstBranchName", "PayerFinInstCustomerIDByFinInst", "PaymentRequisitionIsCanceled", "CreationDateTime", "ChangedOnDateTime"}
	dataPlatformPaymentRequisitionHeaderDatumColumnsWithoutDefault = []string{"PayerPaymentRequisitionID", "Payer", "PayerPaymentDate", "PaymentReqnStatus", "AcceptanceNoByFinInst", "PaytReqnAmtInTransCrcy", "Currency", "PaymentMethod", "PayerPostingDate", "PayerHouseBank", "PayerHouseBankAccount", "PayerFinInstCountry", "PayerFinInstCode", "PayerFinInstBranchCode", "PayerFinInstFullCode", "PayerFinInstSWIFTCode", "PayerInternalFinInstCustomerID", "PayerInternalFinInstAccountID", "PayerFinInstControlKey", "PayerFinInstAccount", "PayerFinInstAccountName", "PayerFinInstName", "PayerFinInstBranchName", "PayerFinInstCustomerIDByFinInst", "PaymentRequisitionIsCanceled", "CreationDateTime", "ChangedOnDateTime"}
	dataPlatformPaymentRequisitionHeaderDatumColumnsWithDefault    = []string{}
	dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns     = []string{"PayerPaymentRequisitionID"}
	dataPlatformPaymentRequisitionHeaderDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformPaymentRequisitionHeaderDatumSlice is an alias for a slice of pointers to DataPlatformPaymentRequisitionHeaderDatum.
	// This should almost always be used instead of []DataPlatformPaymentRequisitionHeaderDatum.
	DataPlatformPaymentRequisitionHeaderDatumSlice []*DataPlatformPaymentRequisitionHeaderDatum

	dataPlatformPaymentRequisitionHeaderDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformPaymentRequisitionHeaderDatumType                 = reflect.TypeOf(&DataPlatformPaymentRequisitionHeaderDatum{})
	dataPlatformPaymentRequisitionHeaderDatumMapping              = queries.MakeStructMapping(dataPlatformPaymentRequisitionHeaderDatumType)
	dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns)
	dataPlatformPaymentRequisitionHeaderDatumInsertCacheMut       sync.RWMutex
	dataPlatformPaymentRequisitionHeaderDatumInsertCache          = make(map[string]insertCache)
	dataPlatformPaymentRequisitionHeaderDatumUpdateCacheMut       sync.RWMutex
	dataPlatformPaymentRequisitionHeaderDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformPaymentRequisitionHeaderDatumUpsertCacheMut       sync.RWMutex
	dataPlatformPaymentRequisitionHeaderDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformPaymentRequisitionHeaderDatum record from the query.
func (q dataPlatformPaymentRequisitionHeaderDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformPaymentRequisitionHeaderDatum, error) {
	o := &DataPlatformPaymentRequisitionHeaderDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_payment_requisition_header_data")
	}

	return o, nil
}

// All returns all DataPlatformPaymentRequisitionHeaderDatum records from the query.
func (q dataPlatformPaymentRequisitionHeaderDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformPaymentRequisitionHeaderDatumSlice, error) {
	var o []*DataPlatformPaymentRequisitionHeaderDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformPaymentRequisitionHeaderDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformPaymentRequisitionHeaderDatum records in the query.
func (q dataPlatformPaymentRequisitionHeaderDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_payment_requisition_header_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformPaymentRequisitionHeaderDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_payment_requisition_header_data exists")
	}

	return count > 0, nil
}

// DataPlatformPaymentRequisitionHeaderData retrieves all the records using an executor.
func DataPlatformPaymentRequisitionHeaderData(mods ...qm.QueryMod) dataPlatformPaymentRequisitionHeaderDatumQuery {
	mods = append(mods, qm.From("`data_platform_payment_requisition_header_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_payment_requisition_header_data`.*"})
	}

	return dataPlatformPaymentRequisitionHeaderDatumQuery{q}
}

// FindDataPlatformPaymentRequisitionHeaderDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformPaymentRequisitionHeaderDatum(ctx context.Context, exec boil.ContextExecutor, payerPaymentRequisitionID int, selectCols ...string) (*DataPlatformPaymentRequisitionHeaderDatum, error) {
	dataPlatformPaymentRequisitionHeaderDatumObj := &DataPlatformPaymentRequisitionHeaderDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_payment_requisition_header_data` where `PayerPaymentRequisitionID`=?", sel,
	)

	q := queries.Raw(query, payerPaymentRequisitionID)

	err := q.Bind(ctx, exec, dataPlatformPaymentRequisitionHeaderDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_payment_requisition_header_data")
	}

	return dataPlatformPaymentRequisitionHeaderDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformPaymentRequisitionHeaderDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_payment_requisition_header_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformPaymentRequisitionHeaderDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformPaymentRequisitionHeaderDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformPaymentRequisitionHeaderDatumInsertCache[key]
	dataPlatformPaymentRequisitionHeaderDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformPaymentRequisitionHeaderDatumAllColumns,
			dataPlatformPaymentRequisitionHeaderDatumColumnsWithDefault,
			dataPlatformPaymentRequisitionHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_payment_requisition_header_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_payment_requisition_header_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_payment_requisition_header_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_payment_requisition_header_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PayerPaymentRequisitionID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_payment_requisition_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformPaymentRequisitionHeaderDatumInsertCacheMut.Lock()
		dataPlatformPaymentRequisitionHeaderDatumInsertCache[key] = cache
		dataPlatformPaymentRequisitionHeaderDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformPaymentRequisitionHeaderDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformPaymentRequisitionHeaderDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformPaymentRequisitionHeaderDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformPaymentRequisitionHeaderDatumUpdateCache[key]
	dataPlatformPaymentRequisitionHeaderDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformPaymentRequisitionHeaderDatumAllColumns,
			dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_payment_requisition_header_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_payment_requisition_header_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, append(wl, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_payment_requisition_header_data row")
	}

	if !cached {
		dataPlatformPaymentRequisitionHeaderDatumUpdateCacheMut.Lock()
		dataPlatformPaymentRequisitionHeaderDatumUpdateCache[key] = cache
		dataPlatformPaymentRequisitionHeaderDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformPaymentRequisitionHeaderDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_payment_requisition_header_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformPaymentRequisitionHeaderDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_payment_requisition_header_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformPaymentRequisitionHeaderDatum slice")
	}

	return nil
}

var mySQLDataPlatformPaymentRequisitionHeaderDatumUniqueColumns = []string{
	"PayerPaymentRequisitionID",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformPaymentRequisitionHeaderDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_payment_requisition_header_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformPaymentRequisitionHeaderDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformPaymentRequisitionHeaderDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformPaymentRequisitionHeaderDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformPaymentRequisitionHeaderDatumUpsertCache[key]
	dataPlatformPaymentRequisitionHeaderDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformPaymentRequisitionHeaderDatumAllColumns,
			dataPlatformPaymentRequisitionHeaderDatumColumnsWithDefault,
			dataPlatformPaymentRequisitionHeaderDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformPaymentRequisitionHeaderDatumAllColumns,
			dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_payment_requisition_header_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_payment_requisition_header_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_payment_requisition_header_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_payment_requisition_header_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformPaymentRequisitionHeaderDatumType, dataPlatformPaymentRequisitionHeaderDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_payment_requisition_header_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_payment_requisition_header_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformPaymentRequisitionHeaderDatumUpsertCacheMut.Lock()
		dataPlatformPaymentRequisitionHeaderDatumUpsertCache[key] = cache
		dataPlatformPaymentRequisitionHeaderDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformPaymentRequisitionHeaderDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformPaymentRequisitionHeaderDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformPaymentRequisitionHeaderDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_payment_requisition_header_data` WHERE `PayerPaymentRequisitionID`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_payment_requisition_header_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformPaymentRequisitionHeaderDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformPaymentRequisitionHeaderDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_payment_requisition_header_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformPaymentRequisitionHeaderDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_payment_requisition_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformPaymentRequisitionHeaderDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformPaymentRequisitionHeaderDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformPaymentRequisitionHeaderDatum(ctx, exec, o.PayerPaymentRequisitionID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformPaymentRequisitionHeaderDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformPaymentRequisitionHeaderDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_payment_requisition_header_data`.* FROM `data_platform_payment_requisition_header_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPaymentRequisitionHeaderDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformPaymentRequisitionHeaderDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformPaymentRequisitionHeaderDatumExists checks if the DataPlatformPaymentRequisitionHeaderDatum row exists.
func DataPlatformPaymentRequisitionHeaderDatumExists(ctx context.Context, exec boil.ContextExecutor, payerPaymentRequisitionID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_payment_requisition_header_data` where `PayerPaymentRequisitionID`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, payerPaymentRequisitionID)
	}
	row := exec.QueryRowContext(ctx, sql, payerPaymentRequisitionID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_payment_requisition_header_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformPaymentRequisitionHeaderDatum row exists.
func (o *DataPlatformPaymentRequisitionHeaderDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformPaymentRequisitionHeaderDatumExists(ctx, exec, o.PayerPaymentRequisitionID)
}
