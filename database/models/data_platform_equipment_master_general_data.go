// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformEquipmentMasterGeneralDatum is an object representing the database table.
type DataPlatformEquipmentMasterGeneralDatum struct {
	Equipment                       int          `boil:"Equipment" json:"Equipment" toml:"Equipment" yaml:"Equipment"`
	BusinessPartner                 null.Int     `boil:"BusinessPartner" json:"BusinessPartner,omitempty" toml:"BusinessPartner" yaml:"BusinessPartner,omitempty"`
	ValidityStartDate               null.String  `boil:"ValidityStartDate" json:"ValidityStartDate,omitempty" toml:"ValidityStartDate" yaml:"ValidityStartDate,omitempty"`
	ValidityEndDate                 null.String  `boil:"ValidityEndDate" json:"ValidityEndDate,omitempty" toml:"ValidityEndDate" yaml:"ValidityEndDate,omitempty"`
	EquipmentName                   null.String  `boil:"EquipmentName" json:"EquipmentName,omitempty" toml:"EquipmentName" yaml:"EquipmentName,omitempty"`
	EquipmentType                   null.String  `boil:"EquipmentType" json:"EquipmentType,omitempty" toml:"EquipmentType" yaml:"EquipmentType,omitempty"`
	EquipmentCategory               null.String  `boil:"EquipmentCategory" json:"EquipmentCategory,omitempty" toml:"EquipmentCategory" yaml:"EquipmentCategory,omitempty"`
	TechnicalObjectType             null.String  `boil:"TechnicalObjectType" json:"TechnicalObjectType,omitempty" toml:"TechnicalObjectType" yaml:"TechnicalObjectType,omitempty"`
	GrossWeight                     null.Float32 `boil:"GrossWeight" json:"GrossWeight,omitempty" toml:"GrossWeight" yaml:"GrossWeight,omitempty"`
	NetWeight                       null.Float32 `boil:"NetWeight" json:"NetWeight,omitempty" toml:"NetWeight" yaml:"NetWeight,omitempty"`
	WeightUnit                      null.String  `boil:"WeightUnit" json:"WeightUnit,omitempty" toml:"WeightUnit" yaml:"WeightUnit,omitempty"`
	SizeOrDimensionText             null.String  `boil:"SizeOrDimensionText" json:"SizeOrDimensionText,omitempty" toml:"SizeOrDimensionText" yaml:"SizeOrDimensionText,omitempty"`
	InventoryNumber                 null.String  `boil:"InventoryNumber" json:"InventoryNumber,omitempty" toml:"InventoryNumber" yaml:"InventoryNumber,omitempty"`
	OperationStartDate              null.String  `boil:"OperationStartDate" json:"OperationStartDate,omitempty" toml:"OperationStartDate" yaml:"OperationStartDate,omitempty"`
	OperationStartTime              null.String  `boil:"OperationStartTime" json:"OperationStartTime,omitempty" toml:"OperationStartTime" yaml:"OperationStartTime,omitempty"`
	OperationEndDate                null.String  `boil:"OperationEndDate" json:"OperationEndDate,omitempty" toml:"OperationEndDate" yaml:"OperationEndDate,omitempty"`
	OperationEndTime                null.String  `boil:"OperationEndTime" json:"OperationEndTime,omitempty" toml:"OperationEndTime" yaml:"OperationEndTime,omitempty"`
	EquipmentStandardID             null.String  `boil:"EquipmentStandardID" json:"EquipmentStandardID,omitempty" toml:"EquipmentStandardID" yaml:"EquipmentStandardID,omitempty"`
	EquipmentIndustryStandardName   null.String  `boil:"EquipmentIndustryStandardName" json:"EquipmentIndustryStandardName,omitempty" toml:"EquipmentIndustryStandardName" yaml:"EquipmentIndustryStandardName,omitempty"`
	CountryOfOrigin                 null.String  `boil:"CountryOfOrigin" json:"CountryOfOrigin,omitempty" toml:"CountryOfOrigin" yaml:"CountryOfOrigin,omitempty"`
	CountryOfOriginLanguage         null.String  `boil:"CountryOfOriginLanguage" json:"CountryOfOriginLanguage,omitempty" toml:"CountryOfOriginLanguage" yaml:"CountryOfOriginLanguage,omitempty"`
	BarcodeType                     null.String  `boil:"BarcodeType" json:"BarcodeType,omitempty" toml:"BarcodeType" yaml:"BarcodeType,omitempty"`
	AcquisitionDate                 null.String  `boil:"AcquisitionDate" json:"AcquisitionDate,omitempty" toml:"AcquisitionDate" yaml:"AcquisitionDate,omitempty"`
	Manufacturer                    null.Int     `boil:"Manufacturer" json:"Manufacturer,omitempty" toml:"Manufacturer" yaml:"Manufacturer,omitempty"`
	ManufacturedCountry             null.String  `boil:"ManufacturedCountry" json:"ManufacturedCountry,omitempty" toml:"ManufacturedCountry" yaml:"ManufacturedCountry,omitempty"`
	ConstructionYear                null.Int     `boil:"ConstructionYear" json:"ConstructionYear,omitempty" toml:"ConstructionYear" yaml:"ConstructionYear,omitempty"`
	ConstructionMonth               null.Int     `boil:"ConstructionMonth" json:"ConstructionMonth,omitempty" toml:"ConstructionMonth" yaml:"ConstructionMonth,omitempty"`
	ManufacturerPartNmbr            null.String  `boil:"ManufacturerPartNmbr" json:"ManufacturerPartNmbr,omitempty" toml:"ManufacturerPartNmbr" yaml:"ManufacturerPartNmbr,omitempty"`
	ManufacturerSerialNumber        null.String  `boil:"ManufacturerSerialNumber" json:"ManufacturerSerialNumber,omitempty" toml:"ManufacturerSerialNumber" yaml:"ManufacturerSerialNumber,omitempty"`
	MaintenancePlantBusinessPartner int          `boil:"MaintenancePlantBusinessPartner" json:"MaintenancePlantBusinessPartner" toml:"MaintenancePlantBusinessPartner" yaml:"MaintenancePlantBusinessPartner"`
	MaintenancePlant                string       `boil:"MaintenancePlant" json:"MaintenancePlant" toml:"MaintenancePlant" yaml:"MaintenancePlant"`
	AssetLocation                   null.String  `boil:"AssetLocation" json:"AssetLocation,omitempty" toml:"AssetLocation" yaml:"AssetLocation,omitempty"`
	AssetRoom                       null.String  `boil:"AssetRoom" json:"AssetRoom,omitempty" toml:"AssetRoom" yaml:"AssetRoom,omitempty"`
	PlantSection                    null.String  `boil:"PlantSection" json:"PlantSection,omitempty" toml:"PlantSection" yaml:"PlantSection,omitempty"`
	WorkCenter                      null.String  `boil:"WorkCenter" json:"WorkCenter,omitempty" toml:"WorkCenter" yaml:"WorkCenter,omitempty"`
	Project                         null.String  `boil:"Project" json:"Project,omitempty" toml:"Project" yaml:"Project,omitempty"`
	MaintenancePlannerGroup         null.String  `boil:"MaintenancePlannerGroup" json:"MaintenancePlannerGroup,omitempty" toml:"MaintenancePlannerGroup" yaml:"MaintenancePlannerGroup,omitempty"`
	CatalogProfile                  null.String  `boil:"CatalogProfile" json:"CatalogProfile,omitempty" toml:"CatalogProfile" yaml:"CatalogProfile,omitempty"`
	FunctionalLocation              null.String  `boil:"FunctionalLocation" json:"FunctionalLocation,omitempty" toml:"FunctionalLocation" yaml:"FunctionalLocation,omitempty"`
	SuperordinateEquipment          null.String  `boil:"SuperordinateEquipment" json:"SuperordinateEquipment,omitempty" toml:"SuperordinateEquipment" yaml:"SuperordinateEquipment,omitempty"`
	EquipInstallationPositionNmbr   null.String  `boil:"EquipInstallationPositionNmbr" json:"EquipInstallationPositionNmbr,omitempty" toml:"EquipInstallationPositionNmbr" yaml:"EquipInstallationPositionNmbr,omitempty"`
	EquipmentIsAvailable            null.Bool    `boil:"EquipmentIsAvailable" json:"EquipmentIsAvailable,omitempty" toml:"EquipmentIsAvailable" yaml:"EquipmentIsAvailable,omitempty"`
	EquipmentIsInstalled            null.Bool    `boil:"EquipmentIsInstalled" json:"EquipmentIsInstalled,omitempty" toml:"EquipmentIsInstalled" yaml:"EquipmentIsInstalled,omitempty"`
	EquipIsAllocToSuperiorEquip     null.Bool    `boil:"EquipIsAllocToSuperiorEquip" json:"EquipIsAllocToSuperiorEquip,omitempty" toml:"EquipIsAllocToSuperiorEquip" yaml:"EquipIsAllocToSuperiorEquip,omitempty"`
	EquipHasSubOrdinateEquipment    null.String  `boil:"EquipHasSubOrdinateEquipment" json:"EquipHasSubOrdinateEquipment,omitempty" toml:"EquipHasSubOrdinateEquipment" yaml:"EquipHasSubOrdinateEquipment,omitempty"`
	MasterFixedAsset                null.String  `boil:"MasterFixedAsset" json:"MasterFixedAsset,omitempty" toml:"MasterFixedAsset" yaml:"MasterFixedAsset,omitempty"`
	FixedAsset                      null.String  `boil:"FixedAsset" json:"FixedAsset,omitempty" toml:"FixedAsset" yaml:"FixedAsset,omitempty"`
	CreationDate                    null.String  `boil:"CreationDate" json:"CreationDate,omitempty" toml:"CreationDate" yaml:"CreationDate,omitempty"`
	LastChangeDateTime              null.String  `boil:"LastChangeDateTime" json:"LastChangeDateTime,omitempty" toml:"LastChangeDateTime" yaml:"LastChangeDateTime,omitempty"`
	IsMarkedForDeletion             null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformEquipmentMasterGeneralDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformEquipmentMasterGeneralDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformEquipmentMasterGeneralDatumColumns = struct {
	Equipment                       string
	BusinessPartner                 string
	ValidityStartDate               string
	ValidityEndDate                 string
	EquipmentName                   string
	EquipmentType                   string
	EquipmentCategory               string
	TechnicalObjectType             string
	GrossWeight                     string
	NetWeight                       string
	WeightUnit                      string
	SizeOrDimensionText             string
	InventoryNumber                 string
	OperationStartDate              string
	OperationStartTime              string
	OperationEndDate                string
	OperationEndTime                string
	EquipmentStandardID             string
	EquipmentIndustryStandardName   string
	CountryOfOrigin                 string
	CountryOfOriginLanguage         string
	BarcodeType                     string
	AcquisitionDate                 string
	Manufacturer                    string
	ManufacturedCountry             string
	ConstructionYear                string
	ConstructionMonth               string
	ManufacturerPartNmbr            string
	ManufacturerSerialNumber        string
	MaintenancePlantBusinessPartner string
	MaintenancePlant                string
	AssetLocation                   string
	AssetRoom                       string
	PlantSection                    string
	WorkCenter                      string
	Project                         string
	MaintenancePlannerGroup         string
	CatalogProfile                  string
	FunctionalLocation              string
	SuperordinateEquipment          string
	EquipInstallationPositionNmbr   string
	EquipmentIsAvailable            string
	EquipmentIsInstalled            string
	EquipIsAllocToSuperiorEquip     string
	EquipHasSubOrdinateEquipment    string
	MasterFixedAsset                string
	FixedAsset                      string
	CreationDate                    string
	LastChangeDateTime              string
	IsMarkedForDeletion             string
}{
	Equipment:                       "Equipment",
	BusinessPartner:                 "BusinessPartner",
	ValidityStartDate:               "ValidityStartDate",
	ValidityEndDate:                 "ValidityEndDate",
	EquipmentName:                   "EquipmentName",
	EquipmentType:                   "EquipmentType",
	EquipmentCategory:               "EquipmentCategory",
	TechnicalObjectType:             "TechnicalObjectType",
	GrossWeight:                     "GrossWeight",
	NetWeight:                       "NetWeight",
	WeightUnit:                      "WeightUnit",
	SizeOrDimensionText:             "SizeOrDimensionText",
	InventoryNumber:                 "InventoryNumber",
	OperationStartDate:              "OperationStartDate",
	OperationStartTime:              "OperationStartTime",
	OperationEndDate:                "OperationEndDate",
	OperationEndTime:                "OperationEndTime",
	EquipmentStandardID:             "EquipmentStandardID",
	EquipmentIndustryStandardName:   "EquipmentIndustryStandardName",
	CountryOfOrigin:                 "CountryOfOrigin",
	CountryOfOriginLanguage:         "CountryOfOriginLanguage",
	BarcodeType:                     "BarcodeType",
	AcquisitionDate:                 "AcquisitionDate",
	Manufacturer:                    "Manufacturer",
	ManufacturedCountry:             "ManufacturedCountry",
	ConstructionYear:                "ConstructionYear",
	ConstructionMonth:               "ConstructionMonth",
	ManufacturerPartNmbr:            "ManufacturerPartNmbr",
	ManufacturerSerialNumber:        "ManufacturerSerialNumber",
	MaintenancePlantBusinessPartner: "MaintenancePlantBusinessPartner",
	MaintenancePlant:                "MaintenancePlant",
	AssetLocation:                   "AssetLocation",
	AssetRoom:                       "AssetRoom",
	PlantSection:                    "PlantSection",
	WorkCenter:                      "WorkCenter",
	Project:                         "Project",
	MaintenancePlannerGroup:         "MaintenancePlannerGroup",
	CatalogProfile:                  "CatalogProfile",
	FunctionalLocation:              "FunctionalLocation",
	SuperordinateEquipment:          "SuperordinateEquipment",
	EquipInstallationPositionNmbr:   "EquipInstallationPositionNmbr",
	EquipmentIsAvailable:            "EquipmentIsAvailable",
	EquipmentIsInstalled:            "EquipmentIsInstalled",
	EquipIsAllocToSuperiorEquip:     "EquipIsAllocToSuperiorEquip",
	EquipHasSubOrdinateEquipment:    "EquipHasSubOrdinateEquipment",
	MasterFixedAsset:                "MasterFixedAsset",
	FixedAsset:                      "FixedAsset",
	CreationDate:                    "CreationDate",
	LastChangeDateTime:              "LastChangeDateTime",
	IsMarkedForDeletion:             "IsMarkedForDeletion",
}

var DataPlatformEquipmentMasterGeneralDatumTableColumns = struct {
	Equipment                       string
	BusinessPartner                 string
	ValidityStartDate               string
	ValidityEndDate                 string
	EquipmentName                   string
	EquipmentType                   string
	EquipmentCategory               string
	TechnicalObjectType             string
	GrossWeight                     string
	NetWeight                       string
	WeightUnit                      string
	SizeOrDimensionText             string
	InventoryNumber                 string
	OperationStartDate              string
	OperationStartTime              string
	OperationEndDate                string
	OperationEndTime                string
	EquipmentStandardID             string
	EquipmentIndustryStandardName   string
	CountryOfOrigin                 string
	CountryOfOriginLanguage         string
	BarcodeType                     string
	AcquisitionDate                 string
	Manufacturer                    string
	ManufacturedCountry             string
	ConstructionYear                string
	ConstructionMonth               string
	ManufacturerPartNmbr            string
	ManufacturerSerialNumber        string
	MaintenancePlantBusinessPartner string
	MaintenancePlant                string
	AssetLocation                   string
	AssetRoom                       string
	PlantSection                    string
	WorkCenter                      string
	Project                         string
	MaintenancePlannerGroup         string
	CatalogProfile                  string
	FunctionalLocation              string
	SuperordinateEquipment          string
	EquipInstallationPositionNmbr   string
	EquipmentIsAvailable            string
	EquipmentIsInstalled            string
	EquipIsAllocToSuperiorEquip     string
	EquipHasSubOrdinateEquipment    string
	MasterFixedAsset                string
	FixedAsset                      string
	CreationDate                    string
	LastChangeDateTime              string
	IsMarkedForDeletion             string
}{
	Equipment:                       "data_platform_equipment_master_general_data.Equipment",
	BusinessPartner:                 "data_platform_equipment_master_general_data.BusinessPartner",
	ValidityStartDate:               "data_platform_equipment_master_general_data.ValidityStartDate",
	ValidityEndDate:                 "data_platform_equipment_master_general_data.ValidityEndDate",
	EquipmentName:                   "data_platform_equipment_master_general_data.EquipmentName",
	EquipmentType:                   "data_platform_equipment_master_general_data.EquipmentType",
	EquipmentCategory:               "data_platform_equipment_master_general_data.EquipmentCategory",
	TechnicalObjectType:             "data_platform_equipment_master_general_data.TechnicalObjectType",
	GrossWeight:                     "data_platform_equipment_master_general_data.GrossWeight",
	NetWeight:                       "data_platform_equipment_master_general_data.NetWeight",
	WeightUnit:                      "data_platform_equipment_master_general_data.WeightUnit",
	SizeOrDimensionText:             "data_platform_equipment_master_general_data.SizeOrDimensionText",
	InventoryNumber:                 "data_platform_equipment_master_general_data.InventoryNumber",
	OperationStartDate:              "data_platform_equipment_master_general_data.OperationStartDate",
	OperationStartTime:              "data_platform_equipment_master_general_data.OperationStartTime",
	OperationEndDate:                "data_platform_equipment_master_general_data.OperationEndDate",
	OperationEndTime:                "data_platform_equipment_master_general_data.OperationEndTime",
	EquipmentStandardID:             "data_platform_equipment_master_general_data.EquipmentStandardID",
	EquipmentIndustryStandardName:   "data_platform_equipment_master_general_data.EquipmentIndustryStandardName",
	CountryOfOrigin:                 "data_platform_equipment_master_general_data.CountryOfOrigin",
	CountryOfOriginLanguage:         "data_platform_equipment_master_general_data.CountryOfOriginLanguage",
	BarcodeType:                     "data_platform_equipment_master_general_data.BarcodeType",
	AcquisitionDate:                 "data_platform_equipment_master_general_data.AcquisitionDate",
	Manufacturer:                    "data_platform_equipment_master_general_data.Manufacturer",
	ManufacturedCountry:             "data_platform_equipment_master_general_data.ManufacturedCountry",
	ConstructionYear:                "data_platform_equipment_master_general_data.ConstructionYear",
	ConstructionMonth:               "data_platform_equipment_master_general_data.ConstructionMonth",
	ManufacturerPartNmbr:            "data_platform_equipment_master_general_data.ManufacturerPartNmbr",
	ManufacturerSerialNumber:        "data_platform_equipment_master_general_data.ManufacturerSerialNumber",
	MaintenancePlantBusinessPartner: "data_platform_equipment_master_general_data.MaintenancePlantBusinessPartner",
	MaintenancePlant:                "data_platform_equipment_master_general_data.MaintenancePlant",
	AssetLocation:                   "data_platform_equipment_master_general_data.AssetLocation",
	AssetRoom:                       "data_platform_equipment_master_general_data.AssetRoom",
	PlantSection:                    "data_platform_equipment_master_general_data.PlantSection",
	WorkCenter:                      "data_platform_equipment_master_general_data.WorkCenter",
	Project:                         "data_platform_equipment_master_general_data.Project",
	MaintenancePlannerGroup:         "data_platform_equipment_master_general_data.MaintenancePlannerGroup",
	CatalogProfile:                  "data_platform_equipment_master_general_data.CatalogProfile",
	FunctionalLocation:              "data_platform_equipment_master_general_data.FunctionalLocation",
	SuperordinateEquipment:          "data_platform_equipment_master_general_data.SuperordinateEquipment",
	EquipInstallationPositionNmbr:   "data_platform_equipment_master_general_data.EquipInstallationPositionNmbr",
	EquipmentIsAvailable:            "data_platform_equipment_master_general_data.EquipmentIsAvailable",
	EquipmentIsInstalled:            "data_platform_equipment_master_general_data.EquipmentIsInstalled",
	EquipIsAllocToSuperiorEquip:     "data_platform_equipment_master_general_data.EquipIsAllocToSuperiorEquip",
	EquipHasSubOrdinateEquipment:    "data_platform_equipment_master_general_data.EquipHasSubOrdinateEquipment",
	MasterFixedAsset:                "data_platform_equipment_master_general_data.MasterFixedAsset",
	FixedAsset:                      "data_platform_equipment_master_general_data.FixedAsset",
	CreationDate:                    "data_platform_equipment_master_general_data.CreationDate",
	LastChangeDateTime:              "data_platform_equipment_master_general_data.LastChangeDateTime",
	IsMarkedForDeletion:             "data_platform_equipment_master_general_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformEquipmentMasterGeneralDatumWhere = struct {
	Equipment                       whereHelperint
	BusinessPartner                 whereHelpernull_Int
	ValidityStartDate               whereHelpernull_String
	ValidityEndDate                 whereHelpernull_String
	EquipmentName                   whereHelpernull_String
	EquipmentType                   whereHelpernull_String
	EquipmentCategory               whereHelpernull_String
	TechnicalObjectType             whereHelpernull_String
	GrossWeight                     whereHelpernull_Float32
	NetWeight                       whereHelpernull_Float32
	WeightUnit                      whereHelpernull_String
	SizeOrDimensionText             whereHelpernull_String
	InventoryNumber                 whereHelpernull_String
	OperationStartDate              whereHelpernull_String
	OperationStartTime              whereHelpernull_String
	OperationEndDate                whereHelpernull_String
	OperationEndTime                whereHelpernull_String
	EquipmentStandardID             whereHelpernull_String
	EquipmentIndustryStandardName   whereHelpernull_String
	CountryOfOrigin                 whereHelpernull_String
	CountryOfOriginLanguage         whereHelpernull_String
	BarcodeType                     whereHelpernull_String
	AcquisitionDate                 whereHelpernull_String
	Manufacturer                    whereHelpernull_Int
	ManufacturedCountry             whereHelpernull_String
	ConstructionYear                whereHelpernull_Int
	ConstructionMonth               whereHelpernull_Int
	ManufacturerPartNmbr            whereHelpernull_String
	ManufacturerSerialNumber        whereHelpernull_String
	MaintenancePlantBusinessPartner whereHelperint
	MaintenancePlant                whereHelperstring
	AssetLocation                   whereHelpernull_String
	AssetRoom                       whereHelpernull_String
	PlantSection                    whereHelpernull_String
	WorkCenter                      whereHelpernull_String
	Project                         whereHelpernull_String
	MaintenancePlannerGroup         whereHelpernull_String
	CatalogProfile                  whereHelpernull_String
	FunctionalLocation              whereHelpernull_String
	SuperordinateEquipment          whereHelpernull_String
	EquipInstallationPositionNmbr   whereHelpernull_String
	EquipmentIsAvailable            whereHelpernull_Bool
	EquipmentIsInstalled            whereHelpernull_Bool
	EquipIsAllocToSuperiorEquip     whereHelpernull_Bool
	EquipHasSubOrdinateEquipment    whereHelpernull_String
	MasterFixedAsset                whereHelpernull_String
	FixedAsset                      whereHelpernull_String
	CreationDate                    whereHelpernull_String
	LastChangeDateTime              whereHelpernull_String
	IsMarkedForDeletion             whereHelpernull_Bool
}{
	Equipment:                       whereHelperint{field: "`data_platform_equipment_master_general_data`.`Equipment`"},
	BusinessPartner:                 whereHelpernull_Int{field: "`data_platform_equipment_master_general_data`.`BusinessPartner`"},
	ValidityStartDate:               whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`ValidityStartDate`"},
	ValidityEndDate:                 whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`ValidityEndDate`"},
	EquipmentName:                   whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipmentName`"},
	EquipmentType:                   whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipmentType`"},
	EquipmentCategory:               whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipmentCategory`"},
	TechnicalObjectType:             whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`TechnicalObjectType`"},
	GrossWeight:                     whereHelpernull_Float32{field: "`data_platform_equipment_master_general_data`.`GrossWeight`"},
	NetWeight:                       whereHelpernull_Float32{field: "`data_platform_equipment_master_general_data`.`NetWeight`"},
	WeightUnit:                      whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`WeightUnit`"},
	SizeOrDimensionText:             whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`SizeOrDimensionText`"},
	InventoryNumber:                 whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`InventoryNumber`"},
	OperationStartDate:              whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`OperationStartDate`"},
	OperationStartTime:              whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`OperationStartTime`"},
	OperationEndDate:                whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`OperationEndDate`"},
	OperationEndTime:                whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`OperationEndTime`"},
	EquipmentStandardID:             whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipmentStandardID`"},
	EquipmentIndustryStandardName:   whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipmentIndustryStandardName`"},
	CountryOfOrigin:                 whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`CountryOfOrigin`"},
	CountryOfOriginLanguage:         whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`CountryOfOriginLanguage`"},
	BarcodeType:                     whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`BarcodeType`"},
	AcquisitionDate:                 whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`AcquisitionDate`"},
	Manufacturer:                    whereHelpernull_Int{field: "`data_platform_equipment_master_general_data`.`Manufacturer`"},
	ManufacturedCountry:             whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`ManufacturedCountry`"},
	ConstructionYear:                whereHelpernull_Int{field: "`data_platform_equipment_master_general_data`.`ConstructionYear`"},
	ConstructionMonth:               whereHelpernull_Int{field: "`data_platform_equipment_master_general_data`.`ConstructionMonth`"},
	ManufacturerPartNmbr:            whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`ManufacturerPartNmbr`"},
	ManufacturerSerialNumber:        whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`ManufacturerSerialNumber`"},
	MaintenancePlantBusinessPartner: whereHelperint{field: "`data_platform_equipment_master_general_data`.`MaintenancePlantBusinessPartner`"},
	MaintenancePlant:                whereHelperstring{field: "`data_platform_equipment_master_general_data`.`MaintenancePlant`"},
	AssetLocation:                   whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`AssetLocation`"},
	AssetRoom:                       whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`AssetRoom`"},
	PlantSection:                    whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`PlantSection`"},
	WorkCenter:                      whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`WorkCenter`"},
	Project:                         whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`Project`"},
	MaintenancePlannerGroup:         whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`MaintenancePlannerGroup`"},
	CatalogProfile:                  whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`CatalogProfile`"},
	FunctionalLocation:              whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`FunctionalLocation`"},
	SuperordinateEquipment:          whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`SuperordinateEquipment`"},
	EquipInstallationPositionNmbr:   whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipInstallationPositionNmbr`"},
	EquipmentIsAvailable:            whereHelpernull_Bool{field: "`data_platform_equipment_master_general_data`.`EquipmentIsAvailable`"},
	EquipmentIsInstalled:            whereHelpernull_Bool{field: "`data_platform_equipment_master_general_data`.`EquipmentIsInstalled`"},
	EquipIsAllocToSuperiorEquip:     whereHelpernull_Bool{field: "`data_platform_equipment_master_general_data`.`EquipIsAllocToSuperiorEquip`"},
	EquipHasSubOrdinateEquipment:    whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`EquipHasSubOrdinateEquipment`"},
	MasterFixedAsset:                whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`MasterFixedAsset`"},
	FixedAsset:                      whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`FixedAsset`"},
	CreationDate:                    whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`CreationDate`"},
	LastChangeDateTime:              whereHelpernull_String{field: "`data_platform_equipment_master_general_data`.`LastChangeDateTime`"},
	IsMarkedForDeletion:             whereHelpernull_Bool{field: "`data_platform_equipment_master_general_data`.`IsMarkedForDeletion`"},
}

// DataPlatformEquipmentMasterGeneralDatumRels is where relationship names are stored.
var DataPlatformEquipmentMasterGeneralDatumRels = struct {
	EquipmentDataPlatformDeliveryDocumentItemData                string
	EquipmentDataPlatformEquipmentMasterAddressData              string
	EquipmentDataPlatformEquipmentMasterBusinessPartnerData      string
	EquipmentDataPlatformEquipmentMasterGeneralDocData           string
	EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData string
	EquipmentDataPlatformInvoiceDocumentItemData                 string
	EquipmentDataPlatformOrdersItemData                          string
}{
	EquipmentDataPlatformDeliveryDocumentItemData:                "EquipmentDataPlatformDeliveryDocumentItemData",
	EquipmentDataPlatformEquipmentMasterAddressData:              "EquipmentDataPlatformEquipmentMasterAddressData",
	EquipmentDataPlatformEquipmentMasterBusinessPartnerData:      "EquipmentDataPlatformEquipmentMasterBusinessPartnerData",
	EquipmentDataPlatformEquipmentMasterGeneralDocData:           "EquipmentDataPlatformEquipmentMasterGeneralDocData",
	EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData: "EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData",
	EquipmentDataPlatformInvoiceDocumentItemData:                 "EquipmentDataPlatformInvoiceDocumentItemData",
	EquipmentDataPlatformOrdersItemData:                          "EquipmentDataPlatformOrdersItemData",
}

// dataPlatformEquipmentMasterGeneralDatumR is where relationships are stored.
type dataPlatformEquipmentMasterGeneralDatumR struct {
	EquipmentDataPlatformDeliveryDocumentItemData                DataPlatformDeliveryDocumentItemDatumSlice                `boil:"EquipmentDataPlatformDeliveryDocumentItemData" json:"EquipmentDataPlatformDeliveryDocumentItemData" toml:"EquipmentDataPlatformDeliveryDocumentItemData" yaml:"EquipmentDataPlatformDeliveryDocumentItemData"`
	EquipmentDataPlatformEquipmentMasterAddressData              DataPlatformEquipmentMasterAddressDatumSlice              `boil:"EquipmentDataPlatformEquipmentMasterAddressData" json:"EquipmentDataPlatformEquipmentMasterAddressData" toml:"EquipmentDataPlatformEquipmentMasterAddressData" yaml:"EquipmentDataPlatformEquipmentMasterAddressData"`
	EquipmentDataPlatformEquipmentMasterBusinessPartnerData      DataPlatformEquipmentMasterBusinessPartnerDatumSlice      `boil:"EquipmentDataPlatformEquipmentMasterBusinessPartnerData" json:"EquipmentDataPlatformEquipmentMasterBusinessPartnerData" toml:"EquipmentDataPlatformEquipmentMasterBusinessPartnerData" yaml:"EquipmentDataPlatformEquipmentMasterBusinessPartnerData"`
	EquipmentDataPlatformEquipmentMasterGeneralDocData           DataPlatformEquipmentMasterGeneralDocDatumSlice           `boil:"EquipmentDataPlatformEquipmentMasterGeneralDocData" json:"EquipmentDataPlatformEquipmentMasterGeneralDocData" toml:"EquipmentDataPlatformEquipmentMasterGeneralDocData" yaml:"EquipmentDataPlatformEquipmentMasterGeneralDocData"`
	EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData DataPlatformEquipmentMasterOwnerBusinessPartnerDatumSlice `boil:"EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData" json:"EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData" toml:"EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData" yaml:"EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData"`
	EquipmentDataPlatformInvoiceDocumentItemData                 DataPlatformInvoiceDocumentItemDatumSlice                 `boil:"EquipmentDataPlatformInvoiceDocumentItemData" json:"EquipmentDataPlatformInvoiceDocumentItemData" toml:"EquipmentDataPlatformInvoiceDocumentItemData" yaml:"EquipmentDataPlatformInvoiceDocumentItemData"`
	EquipmentDataPlatformOrdersItemData                          DataPlatformOrdersItemDatumSlice                          `boil:"EquipmentDataPlatformOrdersItemData" json:"EquipmentDataPlatformOrdersItemData" toml:"EquipmentDataPlatformOrdersItemData" yaml:"EquipmentDataPlatformOrdersItemData"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformEquipmentMasterGeneralDatumR) NewStruct() *dataPlatformEquipmentMasterGeneralDatumR {
	return &dataPlatformEquipmentMasterGeneralDatumR{}
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformDeliveryDocumentItemData() DataPlatformDeliveryDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformDeliveryDocumentItemData
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformEquipmentMasterAddressData() DataPlatformEquipmentMasterAddressDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformEquipmentMasterAddressData
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformEquipmentMasterBusinessPartnerData() DataPlatformEquipmentMasterBusinessPartnerDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformEquipmentMasterBusinessPartnerData
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformEquipmentMasterGeneralDocData() DataPlatformEquipmentMasterGeneralDocDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformEquipmentMasterGeneralDocData
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData() DataPlatformEquipmentMasterOwnerBusinessPartnerDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformInvoiceDocumentItemData() DataPlatformInvoiceDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformInvoiceDocumentItemData
}

func (r *dataPlatformEquipmentMasterGeneralDatumR) GetEquipmentDataPlatformOrdersItemData() DataPlatformOrdersItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformOrdersItemData
}

// dataPlatformEquipmentMasterGeneralDatumL is where Load methods for each relationship are stored.
type dataPlatformEquipmentMasterGeneralDatumL struct{}

var (
	dataPlatformEquipmentMasterGeneralDatumAllColumns            = []string{"Equipment", "BusinessPartner", "ValidityStartDate", "ValidityEndDate", "EquipmentName", "EquipmentType", "EquipmentCategory", "TechnicalObjectType", "GrossWeight", "NetWeight", "WeightUnit", "SizeOrDimensionText", "InventoryNumber", "OperationStartDate", "OperationStartTime", "OperationEndDate", "OperationEndTime", "EquipmentStandardID", "EquipmentIndustryStandardName", "CountryOfOrigin", "CountryOfOriginLanguage", "BarcodeType", "AcquisitionDate", "Manufacturer", "ManufacturedCountry", "ConstructionYear", "ConstructionMonth", "ManufacturerPartNmbr", "ManufacturerSerialNumber", "MaintenancePlantBusinessPartner", "MaintenancePlant", "AssetLocation", "AssetRoom", "PlantSection", "WorkCenter", "Project", "MaintenancePlannerGroup", "CatalogProfile", "FunctionalLocation", "SuperordinateEquipment", "EquipInstallationPositionNmbr", "EquipmentIsAvailable", "EquipmentIsInstalled", "EquipIsAllocToSuperiorEquip", "EquipHasSubOrdinateEquipment", "MasterFixedAsset", "FixedAsset", "CreationDate", "LastChangeDateTime", "IsMarkedForDeletion"}
	dataPlatformEquipmentMasterGeneralDatumColumnsWithoutDefault = []string{"Equipment", "BusinessPartner", "ValidityStartDate", "ValidityEndDate", "EquipmentName", "EquipmentType", "EquipmentCategory", "TechnicalObjectType", "GrossWeight", "NetWeight", "WeightUnit", "SizeOrDimensionText", "InventoryNumber", "OperationStartDate", "OperationStartTime", "OperationEndDate", "OperationEndTime", "EquipmentStandardID", "EquipmentIndustryStandardName", "CountryOfOrigin", "CountryOfOriginLanguage", "BarcodeType", "AcquisitionDate", "Manufacturer", "ManufacturedCountry", "ConstructionYear", "ConstructionMonth", "ManufacturerPartNmbr", "ManufacturerSerialNumber", "MaintenancePlantBusinessPartner", "MaintenancePlant", "AssetLocation", "AssetRoom", "PlantSection", "WorkCenter", "Project", "MaintenancePlannerGroup", "CatalogProfile", "FunctionalLocation", "SuperordinateEquipment", "EquipInstallationPositionNmbr", "EquipmentIsAvailable", "EquipmentIsInstalled", "EquipIsAllocToSuperiorEquip", "EquipHasSubOrdinateEquipment", "MasterFixedAsset", "FixedAsset", "CreationDate", "LastChangeDateTime", "IsMarkedForDeletion"}
	dataPlatformEquipmentMasterGeneralDatumColumnsWithDefault    = []string{}
	dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns     = []string{"Equipment"}
	dataPlatformEquipmentMasterGeneralDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformEquipmentMasterGeneralDatumSlice is an alias for a slice of pointers to DataPlatformEquipmentMasterGeneralDatum.
	// This should almost always be used instead of []DataPlatformEquipmentMasterGeneralDatum.
	DataPlatformEquipmentMasterGeneralDatumSlice []*DataPlatformEquipmentMasterGeneralDatum

	dataPlatformEquipmentMasterGeneralDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformEquipmentMasterGeneralDatumType                 = reflect.TypeOf(&DataPlatformEquipmentMasterGeneralDatum{})
	dataPlatformEquipmentMasterGeneralDatumMapping              = queries.MakeStructMapping(dataPlatformEquipmentMasterGeneralDatumType)
	dataPlatformEquipmentMasterGeneralDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns)
	dataPlatformEquipmentMasterGeneralDatumInsertCacheMut       sync.RWMutex
	dataPlatformEquipmentMasterGeneralDatumInsertCache          = make(map[string]insertCache)
	dataPlatformEquipmentMasterGeneralDatumUpdateCacheMut       sync.RWMutex
	dataPlatformEquipmentMasterGeneralDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformEquipmentMasterGeneralDatumUpsertCacheMut       sync.RWMutex
	dataPlatformEquipmentMasterGeneralDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformEquipmentMasterGeneralDatum record from the query.
func (q dataPlatformEquipmentMasterGeneralDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformEquipmentMasterGeneralDatum, error) {
	o := &DataPlatformEquipmentMasterGeneralDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_equipment_master_general_data")
	}

	return o, nil
}

// All returns all DataPlatformEquipmentMasterGeneralDatum records from the query.
func (q dataPlatformEquipmentMasterGeneralDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformEquipmentMasterGeneralDatumSlice, error) {
	var o []*DataPlatformEquipmentMasterGeneralDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformEquipmentMasterGeneralDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformEquipmentMasterGeneralDatum records in the query.
func (q dataPlatformEquipmentMasterGeneralDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_equipment_master_general_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformEquipmentMasterGeneralDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_equipment_master_general_data exists")
	}

	return count > 0, nil
}

// EquipmentDataPlatformDeliveryDocumentItemData retrieves all the data_platform_delivery_document_item_datum's DataPlatformDeliveryDocumentItemData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformDeliveryDocumentItemData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_item_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformDeliveryDocumentItemData(queryMods...)
}

// EquipmentDataPlatformEquipmentMasterAddressData retrieves all the data_platform_equipment_master_address_datum's DataPlatformEquipmentMasterAddressData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformEquipmentMasterAddressData(mods ...qm.QueryMod) dataPlatformEquipmentMasterAddressDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_equipment_master_address_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformEquipmentMasterAddressData(queryMods...)
}

// EquipmentDataPlatformEquipmentMasterBusinessPartnerData retrieves all the data_platform_equipment_master_business_partner_datum's DataPlatformEquipmentMasterBusinessPartnerData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformEquipmentMasterBusinessPartnerData(mods ...qm.QueryMod) dataPlatformEquipmentMasterBusinessPartnerDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_equipment_master_business_partner_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformEquipmentMasterBusinessPartnerData(queryMods...)
}

// EquipmentDataPlatformEquipmentMasterGeneralDocData retrieves all the data_platform_equipment_master_general_doc_datum's DataPlatformEquipmentMasterGeneralDocData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformEquipmentMasterGeneralDocData(mods ...qm.QueryMod) dataPlatformEquipmentMasterGeneralDocDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_equipment_master_general_doc_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformEquipmentMasterGeneralDocData(queryMods...)
}

// EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData retrieves all the data_platform_equipment_master_owner_business_partner_datum's DataPlatformEquipmentMasterOwnerBusinessPartnerData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData(mods ...qm.QueryMod) dataPlatformEquipmentMasterOwnerBusinessPartnerDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_equipment_master_owner_business_partner_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformEquipmentMasterOwnerBusinessPartnerData(queryMods...)
}

// EquipmentDataPlatformInvoiceDocumentItemData retrieves all the data_platform_invoice_document_item_datum's DataPlatformInvoiceDocumentItemData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformInvoiceDocumentItemData(mods ...qm.QueryMod) dataPlatformInvoiceDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_invoice_document_item_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformInvoiceDocumentItemData(queryMods...)
}

// EquipmentDataPlatformOrdersItemData retrieves all the data_platform_orders_item_datum's DataPlatformOrdersItemData with an executor via Equipment column.
func (o *DataPlatformEquipmentMasterGeneralDatum) EquipmentDataPlatformOrdersItemData(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_data`.`Equipment`=?", o.Equipment),
	)

	return DataPlatformOrdersItemData(queryMods...)
}

// LoadEquipmentDataPlatformDeliveryDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformDeliveryDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Equipment) {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_item_data`),
		qm.WhereIn(`data_platform_delivery_document_item_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_item_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_item_data")
	}

	if singular {
		object.R.EquipmentDataPlatformDeliveryDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Equipment, foreign.Equipment) {
				local.R.EquipmentDataPlatformDeliveryDocumentItemData = append(local.R.EquipmentDataPlatformDeliveryDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformEquipmentMasterAddressData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformEquipmentMasterAddressData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Equipment {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_equipment_master_address_data`),
		qm.WhereIn(`data_platform_equipment_master_address_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_equipment_master_address_data")
	}

	var resultSlice []*DataPlatformEquipmentMasterAddressDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_equipment_master_address_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_equipment_master_address_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_equipment_master_address_data")
	}

	if singular {
		object.R.EquipmentDataPlatformEquipmentMasterAddressData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Equipment == foreign.Equipment {
				local.R.EquipmentDataPlatformEquipmentMasterAddressData = append(local.R.EquipmentDataPlatformEquipmentMasterAddressData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformEquipmentMasterBusinessPartnerData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformEquipmentMasterBusinessPartnerData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Equipment {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_equipment_master_business_partner_data`),
		qm.WhereIn(`data_platform_equipment_master_business_partner_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_equipment_master_business_partner_data")
	}

	var resultSlice []*DataPlatformEquipmentMasterBusinessPartnerDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_equipment_master_business_partner_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_equipment_master_business_partner_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_equipment_master_business_partner_data")
	}

	if singular {
		object.R.EquipmentDataPlatformEquipmentMasterBusinessPartnerData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Equipment == foreign.Equipment {
				local.R.EquipmentDataPlatformEquipmentMasterBusinessPartnerData = append(local.R.EquipmentDataPlatformEquipmentMasterBusinessPartnerData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformEquipmentMasterGeneralDocData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformEquipmentMasterGeneralDocData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Equipment {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_equipment_master_general_doc_data`),
		qm.WhereIn(`data_platform_equipment_master_general_doc_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_equipment_master_general_doc_data")
	}

	var resultSlice []*DataPlatformEquipmentMasterGeneralDocDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_equipment_master_general_doc_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_equipment_master_general_doc_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_equipment_master_general_doc_data")
	}

	if singular {
		object.R.EquipmentDataPlatformEquipmentMasterGeneralDocData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Equipment == foreign.Equipment {
				local.R.EquipmentDataPlatformEquipmentMasterGeneralDocData = append(local.R.EquipmentDataPlatformEquipmentMasterGeneralDocData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if a == obj.Equipment {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_equipment_master_owner_business_partner_data`),
		qm.WhereIn(`data_platform_equipment_master_owner_business_partner_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_equipment_master_owner_business_partner_data")
	}

	var resultSlice []*DataPlatformEquipmentMasterOwnerBusinessPartnerDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_equipment_master_owner_business_partner_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_equipment_master_owner_business_partner_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_equipment_master_owner_business_partner_data")
	}

	if singular {
		object.R.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Equipment == foreign.Equipment {
				local.R.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData = append(local.R.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformInvoiceDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformInvoiceDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Equipment) {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_invoice_document_item_data`),
		qm.WhereIn(`data_platform_invoice_document_item_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_invoice_document_item_data")
	}

	var resultSlice []*DataPlatformInvoiceDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_invoice_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_invoice_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_invoice_document_item_data")
	}

	if singular {
		object.R.EquipmentDataPlatformInvoiceDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Equipment, foreign.Equipment) {
				local.R.EquipmentDataPlatformInvoiceDocumentItemData = append(local.R.EquipmentDataPlatformInvoiceDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformOrdersItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformEquipmentMasterGeneralDatumL) LoadEquipmentDataPlatformOrdersItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformEquipmentMasterGeneralDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformEquipmentMasterGeneralDatum
	var object *DataPlatformEquipmentMasterGeneralDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformEquipmentMasterGeneralDatum.(*DataPlatformEquipmentMasterGeneralDatum)
		if !ok {
			object = new(DataPlatformEquipmentMasterGeneralDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformEquipmentMasterGeneralDatum.(*[]*DataPlatformEquipmentMasterGeneralDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformEquipmentMasterGeneralDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformEquipmentMasterGeneralDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformEquipmentMasterGeneralDatumR{}
		}
		args = append(args, object.Equipment)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformEquipmentMasterGeneralDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Equipment) {
					continue Outer
				}
			}

			args = append(args, obj.Equipment)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_data")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if singular {
		object.R.EquipmentDataPlatformOrdersItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Equipment, foreign.Equipment) {
				local.R.EquipmentDataPlatformOrdersItemData = append(local.R.EquipmentDataPlatformOrdersItemData, foreign)
				break
			}
		}
	}

	return nil
}

// AddEquipmentDataPlatformDeliveryDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformDeliveryDocumentItemData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Equipment, o.Equipment)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Equipment, o.Equipment)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformDeliveryDocumentItemData: related,
		}
	} else {
		o.R.EquipmentDataPlatformDeliveryDocumentItemData = append(o.R.EquipmentDataPlatformDeliveryDocumentItemData, related...)
	}

	return nil
}

// SetEquipmentDataPlatformDeliveryDocumentItemData removes all previously related items of the
// data_platform_equipment_master_general_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum's EquipmentDataPlatformDeliveryDocumentItemData accordingly.
// Replaces o.R.EquipmentDataPlatformDeliveryDocumentItemData with related.
func (o *DataPlatformEquipmentMasterGeneralDatum) SetEquipmentDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	query := "update `data_platform_delivery_document_item_data` set `Equipment` = null where `Equipment` = ?"
	values := []interface{}{o.Equipment}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.EquipmentDataPlatformDeliveryDocumentItemData = nil
	}

	return o.AddEquipmentDataPlatformDeliveryDocumentItemData(ctx, exec, insert, related...)
}

// RemoveEquipmentDataPlatformDeliveryDocumentItemData relationships from objects passed in.
// Removes related items from R.EquipmentDataPlatformDeliveryDocumentItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformEquipmentMasterGeneralDatum) RemoveEquipmentDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Equipment, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Equipment")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.EquipmentDataPlatformDeliveryDocumentItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.EquipmentDataPlatformDeliveryDocumentItemData)
			if ln > 1 && i < ln-1 {
				o.R.EquipmentDataPlatformDeliveryDocumentItemData[i] = o.R.EquipmentDataPlatformDeliveryDocumentItemData[ln-1]
			}
			o.R.EquipmentDataPlatformDeliveryDocumentItemData = o.R.EquipmentDataPlatformDeliveryDocumentItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddEquipmentDataPlatformEquipmentMasterAddressData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformEquipmentMasterAddressData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformEquipmentMasterAddressData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformEquipmentMasterAddressDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Equipment = o.Equipment
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_equipment_master_address_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformEquipmentMasterAddressDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.Equipment, rel.AddressID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Equipment = o.Equipment
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformEquipmentMasterAddressData: related,
		}
	} else {
		o.R.EquipmentDataPlatformEquipmentMasterAddressData = append(o.R.EquipmentDataPlatformEquipmentMasterAddressData, related...)
	}

	return nil
}

// AddEquipmentDataPlatformEquipmentMasterBusinessPartnerData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformEquipmentMasterBusinessPartnerData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformEquipmentMasterBusinessPartnerData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformEquipmentMasterBusinessPartnerDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Equipment = o.Equipment
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_equipment_master_business_partner_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformEquipmentMasterBusinessPartnerDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.Equipment, rel.EquipmentPartnerObjectNmbr}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Equipment = o.Equipment
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformEquipmentMasterBusinessPartnerData: related,
		}
	} else {
		o.R.EquipmentDataPlatformEquipmentMasterBusinessPartnerData = append(o.R.EquipmentDataPlatformEquipmentMasterBusinessPartnerData, related...)
	}

	return nil
}

// AddEquipmentDataPlatformEquipmentMasterGeneralDocData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformEquipmentMasterGeneralDocData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformEquipmentMasterGeneralDocData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformEquipmentMasterGeneralDocDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Equipment = o.Equipment
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_equipment_master_general_doc_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformEquipmentMasterGeneralDocDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.Equipment, rel.DocType, rel.DocVersionID, rel.DocID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Equipment = o.Equipment
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformEquipmentMasterGeneralDocData: related,
		}
	} else {
		o.R.EquipmentDataPlatformEquipmentMasterGeneralDocData = append(o.R.EquipmentDataPlatformEquipmentMasterGeneralDocData, related...)
	}

	return nil
}

// AddEquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformEquipmentMasterOwnerBusinessPartnerDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Equipment = o.Equipment
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_equipment_master_owner_business_partner_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformEquipmentMasterOwnerBusinessPartnerDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.Equipment, rel.OwnerBusinessPartner, rel.ValidityStartDate, rel.ValidityEndDate}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Equipment = o.Equipment
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData: related,
		}
	} else {
		o.R.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData = append(o.R.EquipmentDataPlatformEquipmentMasterOwnerBusinessPartnerData, related...)
	}

	return nil
}

// AddEquipmentDataPlatformInvoiceDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformInvoiceDocumentItemData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformInvoiceDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformInvoiceDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Equipment, o.Equipment)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_invoice_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformInvoiceDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.InvoiceDocument, rel.InvoiceDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Equipment, o.Equipment)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformInvoiceDocumentItemData: related,
		}
	} else {
		o.R.EquipmentDataPlatformInvoiceDocumentItemData = append(o.R.EquipmentDataPlatformInvoiceDocumentItemData, related...)
	}

	return nil
}

// SetEquipmentDataPlatformInvoiceDocumentItemData removes all previously related items of the
// data_platform_equipment_master_general_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum's EquipmentDataPlatformInvoiceDocumentItemData accordingly.
// Replaces o.R.EquipmentDataPlatformInvoiceDocumentItemData with related.
func (o *DataPlatformEquipmentMasterGeneralDatum) SetEquipmentDataPlatformInvoiceDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformInvoiceDocumentItemDatum) error {
	query := "update `data_platform_invoice_document_item_data` set `Equipment` = null where `Equipment` = ?"
	values := []interface{}{o.Equipment}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.EquipmentDataPlatformInvoiceDocumentItemData = nil
	}

	return o.AddEquipmentDataPlatformInvoiceDocumentItemData(ctx, exec, insert, related...)
}

// RemoveEquipmentDataPlatformInvoiceDocumentItemData relationships from objects passed in.
// Removes related items from R.EquipmentDataPlatformInvoiceDocumentItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformEquipmentMasterGeneralDatum) RemoveEquipmentDataPlatformInvoiceDocumentItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformInvoiceDocumentItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Equipment, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Equipment")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.EquipmentDataPlatformInvoiceDocumentItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.EquipmentDataPlatformInvoiceDocumentItemData)
			if ln > 1 && i < ln-1 {
				o.R.EquipmentDataPlatformInvoiceDocumentItemData[i] = o.R.EquipmentDataPlatformInvoiceDocumentItemData[ln-1]
			}
			o.R.EquipmentDataPlatformInvoiceDocumentItemData = o.R.EquipmentDataPlatformInvoiceDocumentItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddEquipmentDataPlatformOrdersItemData adds the given related objects to the existing relationships
// of the data_platform_equipment_master_general_datum, optionally inserting them as new records.
// Appends related to o.R.EquipmentDataPlatformOrdersItemData.
func (o *DataPlatformEquipmentMasterGeneralDatum) AddEquipmentDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Equipment, o.Equipment)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.Equipment, rel.OrderID, rel.OrderItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Equipment, o.Equipment)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformEquipmentMasterGeneralDatumR{
			EquipmentDataPlatformOrdersItemData: related,
		}
	} else {
		o.R.EquipmentDataPlatformOrdersItemData = append(o.R.EquipmentDataPlatformOrdersItemData, related...)
	}

	return nil
}

// SetEquipmentDataPlatformOrdersItemData removes all previously related items of the
// data_platform_equipment_master_general_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum's EquipmentDataPlatformOrdersItemData accordingly.
// Replaces o.R.EquipmentDataPlatformOrdersItemData with related.
func (o *DataPlatformEquipmentMasterGeneralDatum) SetEquipmentDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDatum) error {
	query := "update `data_platform_orders_item_data` set `Equipment` = null where `Equipment` = ?"
	values := []interface{}{o.Equipment}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.EquipmentDataPlatformOrdersItemData = nil
	}

	return o.AddEquipmentDataPlatformOrdersItemData(ctx, exec, insert, related...)
}

// RemoveEquipmentDataPlatformOrdersItemData relationships from objects passed in.
// Removes related items from R.EquipmentDataPlatformOrdersItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformEquipmentMasterGeneralDatum) RemoveEquipmentDataPlatformOrdersItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformOrdersItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Equipment, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("Equipment")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.EquipmentDataPlatformOrdersItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.EquipmentDataPlatformOrdersItemData)
			if ln > 1 && i < ln-1 {
				o.R.EquipmentDataPlatformOrdersItemData[i] = o.R.EquipmentDataPlatformOrdersItemData[ln-1]
			}
			o.R.EquipmentDataPlatformOrdersItemData = o.R.EquipmentDataPlatformOrdersItemData[:ln-1]
			break
		}
	}

	return nil
}

// DataPlatformEquipmentMasterGeneralData retrieves all the records using an executor.
func DataPlatformEquipmentMasterGeneralData(mods ...qm.QueryMod) dataPlatformEquipmentMasterGeneralDatumQuery {
	mods = append(mods, qm.From("`data_platform_equipment_master_general_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_equipment_master_general_data`.*"})
	}

	return dataPlatformEquipmentMasterGeneralDatumQuery{q}
}

// FindDataPlatformEquipmentMasterGeneralDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformEquipmentMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, equipment int, selectCols ...string) (*DataPlatformEquipmentMasterGeneralDatum, error) {
	dataPlatformEquipmentMasterGeneralDatumObj := &DataPlatformEquipmentMasterGeneralDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_equipment_master_general_data` where `Equipment`=?", sel,
	)

	q := queries.Raw(query, equipment)

	err := q.Bind(ctx, exec, dataPlatformEquipmentMasterGeneralDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_equipment_master_general_data")
	}

	return dataPlatformEquipmentMasterGeneralDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformEquipmentMasterGeneralDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_equipment_master_general_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformEquipmentMasterGeneralDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformEquipmentMasterGeneralDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformEquipmentMasterGeneralDatumInsertCache[key]
	dataPlatformEquipmentMasterGeneralDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformEquipmentMasterGeneralDatumAllColumns,
			dataPlatformEquipmentMasterGeneralDatumColumnsWithDefault,
			dataPlatformEquipmentMasterGeneralDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_equipment_master_general_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_equipment_master_general_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_equipment_master_general_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_equipment_master_general_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.Equipment,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_equipment_master_general_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformEquipmentMasterGeneralDatumInsertCacheMut.Lock()
		dataPlatformEquipmentMasterGeneralDatumInsertCache[key] = cache
		dataPlatformEquipmentMasterGeneralDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformEquipmentMasterGeneralDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformEquipmentMasterGeneralDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformEquipmentMasterGeneralDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformEquipmentMasterGeneralDatumUpdateCache[key]
	dataPlatformEquipmentMasterGeneralDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformEquipmentMasterGeneralDatumAllColumns,
			dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_equipment_master_general_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_equipment_master_general_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, append(wl, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_equipment_master_general_data row")
	}

	if !cached {
		dataPlatformEquipmentMasterGeneralDatumUpdateCacheMut.Lock()
		dataPlatformEquipmentMasterGeneralDatumUpdateCache[key] = cache
		dataPlatformEquipmentMasterGeneralDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformEquipmentMasterGeneralDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_equipment_master_general_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformEquipmentMasterGeneralDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformEquipmentMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_equipment_master_general_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformEquipmentMasterGeneralDatum slice")
	}

	return nil
}

var mySQLDataPlatformEquipmentMasterGeneralDatumUniqueColumns = []string{
	"Equipment",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformEquipmentMasterGeneralDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_equipment_master_general_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformEquipmentMasterGeneralDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformEquipmentMasterGeneralDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformEquipmentMasterGeneralDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformEquipmentMasterGeneralDatumUpsertCache[key]
	dataPlatformEquipmentMasterGeneralDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformEquipmentMasterGeneralDatumAllColumns,
			dataPlatformEquipmentMasterGeneralDatumColumnsWithDefault,
			dataPlatformEquipmentMasterGeneralDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformEquipmentMasterGeneralDatumAllColumns,
			dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_equipment_master_general_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_equipment_master_general_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_equipment_master_general_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_equipment_master_general_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformEquipmentMasterGeneralDatumType, dataPlatformEquipmentMasterGeneralDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_equipment_master_general_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_equipment_master_general_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformEquipmentMasterGeneralDatumUpsertCacheMut.Lock()
		dataPlatformEquipmentMasterGeneralDatumUpsertCache[key] = cache
		dataPlatformEquipmentMasterGeneralDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformEquipmentMasterGeneralDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformEquipmentMasterGeneralDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformEquipmentMasterGeneralDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformEquipmentMasterGeneralDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_equipment_master_general_data` WHERE `Equipment`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_equipment_master_general_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformEquipmentMasterGeneralDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformEquipmentMasterGeneralDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_equipment_master_general_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformEquipmentMasterGeneralDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformEquipmentMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_equipment_master_general_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformEquipmentMasterGeneralDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformEquipmentMasterGeneralDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformEquipmentMasterGeneralDatum(ctx, exec, o.Equipment)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformEquipmentMasterGeneralDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformEquipmentMasterGeneralDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformEquipmentMasterGeneralDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_equipment_master_general_data`.* FROM `data_platform_equipment_master_general_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformEquipmentMasterGeneralDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformEquipmentMasterGeneralDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformEquipmentMasterGeneralDatumExists checks if the DataPlatformEquipmentMasterGeneralDatum row exists.
func DataPlatformEquipmentMasterGeneralDatumExists(ctx context.Context, exec boil.ContextExecutor, equipment int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_equipment_master_general_data` where `Equipment`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, equipment)
	}
	row := exec.QueryRowContext(ctx, sql, equipment)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_equipment_master_general_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformEquipmentMasterGeneralDatum row exists.
func (o *DataPlatformEquipmentMasterGeneralDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformEquipmentMasterGeneralDatumExists(ctx, exec, o.Equipment)
}
