// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformOrdersItemDatum is an object representing the database table.
type DataPlatformOrdersItemDatum struct {
	OrderID                                       int          `boil:"OrderID" json:"OrderID" toml:"OrderID" yaml:"OrderID"`
	OrderItem                                     int          `boil:"OrderItem" json:"OrderItem" toml:"OrderItem" yaml:"OrderItem"`
	OrderItemCategory                             string       `boil:"OrderItemCategory" json:"OrderItemCategory" toml:"OrderItemCategory" yaml:"OrderItemCategory"`
	OrderStatus                                   string       `boil:"OrderStatus" json:"OrderStatus" toml:"OrderStatus" yaml:"OrderStatus"`
	SupplyChainRelationshipID                     int          `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID"`
	SupplyChainRelationshipDeliveryID             null.Int     `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID,omitempty" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID,omitempty"`
	SupplyChainRelationshipDeliveryPlantID        null.Int     `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID,omitempty" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID,omitempty"`
	SupplyChainRelationshipStockConfPlantID       null.Int     `boil:"SupplyChainRelationshipStockConfPlantID" json:"SupplyChainRelationshipStockConfPlantID,omitempty" toml:"SupplyChainRelationshipStockConfPlantID" yaml:"SupplyChainRelationshipStockConfPlantID,omitempty"`
	SupplyChainRelationshipProductionPlantID      null.Int     `boil:"SupplyChainRelationshipProductionPlantID" json:"SupplyChainRelationshipProductionPlantID,omitempty" toml:"SupplyChainRelationshipProductionPlantID" yaml:"SupplyChainRelationshipProductionPlantID,omitempty"`
	Buyer                                         int          `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Seller                                        int          `boil:"Seller" json:"Seller" toml:"Seller" yaml:"Seller"`
	DeliverToParty                                null.Int     `boil:"DeliverToParty" json:"DeliverToParty,omitempty" toml:"DeliverToParty" yaml:"DeliverToParty,omitempty"`
	DeliverFromParty                              null.Int     `boil:"DeliverFromParty" json:"DeliverFromParty,omitempty" toml:"DeliverFromParty" yaml:"DeliverFromParty,omitempty"`
	DeliverToPlant                                null.String  `boil:"DeliverToPlant" json:"DeliverToPlant,omitempty" toml:"DeliverToPlant" yaml:"DeliverToPlant,omitempty"`
	DeliverFromPlant                              null.String  `boil:"DeliverFromPlant" json:"DeliverFromPlant,omitempty" toml:"DeliverFromPlant" yaml:"DeliverFromPlant,omitempty"`
	OrderItemText                                 string       `boil:"OrderItemText" json:"OrderItemText" toml:"OrderItemText" yaml:"OrderItemText"`
	OrderItemTextByBuyer                          string       `boil:"OrderItemTextByBuyer" json:"OrderItemTextByBuyer" toml:"OrderItemTextByBuyer" yaml:"OrderItemTextByBuyer"`
	OrderItemTextBySeller                         string       `boil:"OrderItemTextBySeller" json:"OrderItemTextBySeller" toml:"OrderItemTextBySeller" yaml:"OrderItemTextBySeller"`
	Product                                       string       `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	SizeOrDimensionText                           null.String  `boil:"SizeOrDimensionText" json:"SizeOrDimensionText,omitempty" toml:"SizeOrDimensionText" yaml:"SizeOrDimensionText,omitempty"`
	ProductStandardID                             null.String  `boil:"ProductStandardID" json:"ProductStandardID,omitempty" toml:"ProductStandardID" yaml:"ProductStandardID,omitempty"`
	ProductGroup                                  null.String  `boil:"ProductGroup" json:"ProductGroup,omitempty" toml:"ProductGroup" yaml:"ProductGroup,omitempty"`
	ProductSpecification                          null.String  `boil:"ProductSpecification" json:"ProductSpecification,omitempty" toml:"ProductSpecification" yaml:"ProductSpecification,omitempty"`
	MarkingOfMaterial                             null.String  `boil:"MarkingOfMaterial" json:"MarkingOfMaterial,omitempty" toml:"MarkingOfMaterial" yaml:"MarkingOfMaterial,omitempty"`
	BaseUnit                                      string       `boil:"BaseUnit" json:"BaseUnit" toml:"BaseUnit" yaml:"BaseUnit"`
	DeliveryUnit                                  string       `boil:"DeliveryUnit" json:"DeliveryUnit" toml:"DeliveryUnit" yaml:"DeliveryUnit"`
	ProductionVersion                             null.Int     `boil:"ProductionVersion" json:"ProductionVersion,omitempty" toml:"ProductionVersion" yaml:"ProductionVersion,omitempty"`
	ProductionVersionItem                         null.Int     `boil:"ProductionVersionItem" json:"ProductionVersionItem,omitempty" toml:"ProductionVersionItem" yaml:"ProductionVersionItem,omitempty"`
	BillOfMaterial                                null.Int     `boil:"BillOfMaterial" json:"BillOfMaterial,omitempty" toml:"BillOfMaterial" yaml:"BillOfMaterial,omitempty"`
	BillOfMaterialItem                            null.Int     `boil:"BillOfMaterialItem" json:"BillOfMaterialItem,omitempty" toml:"BillOfMaterialItem" yaml:"BillOfMaterialItem,omitempty"`
	ProductionOrder                               null.Int     `boil:"ProductionOrder" json:"ProductionOrder,omitempty" toml:"ProductionOrder" yaml:"ProductionOrder,omitempty"`
	ProductionOrderItem                           null.Int     `boil:"ProductionOrderItem" json:"ProductionOrderItem,omitempty" toml:"ProductionOrderItem" yaml:"ProductionOrderItem,omitempty"`
	Operations                                    null.Int     `boil:"Operations" json:"Operations,omitempty" toml:"Operations" yaml:"Operations,omitempty"`
	OperationsItem                                null.Int     `boil:"OperationsItem" json:"OperationsItem,omitempty" toml:"OperationsItem" yaml:"OperationsItem,omitempty"`
	OperationID                                   null.Int     `boil:"OperationID" json:"OperationID,omitempty" toml:"OperationID" yaml:"OperationID,omitempty"`
	PricingDate                                   string       `boil:"PricingDate" json:"PricingDate" toml:"PricingDate" yaml:"PricingDate"`
	PriceDetnExchangeRate                         null.Float32 `boil:"PriceDetnExchangeRate" json:"PriceDetnExchangeRate,omitempty" toml:"PriceDetnExchangeRate" yaml:"PriceDetnExchangeRate,omitempty"`
	RequestedDeliveryDate                         string       `boil:"RequestedDeliveryDate" json:"RequestedDeliveryDate" toml:"RequestedDeliveryDate" yaml:"RequestedDeliveryDate"`
	RequestedDeliveryTime                         string       `boil:"RequestedDeliveryTime" json:"RequestedDeliveryTime" toml:"RequestedDeliveryTime" yaml:"RequestedDeliveryTime"`
	DeliverToPlantTimeZone                        null.String  `boil:"DeliverToPlantTimeZone" json:"DeliverToPlantTimeZone,omitempty" toml:"DeliverToPlantTimeZone" yaml:"DeliverToPlantTimeZone,omitempty"`
	DeliverToPlantStorageLocation                 null.String  `boil:"DeliverToPlantStorageLocation" json:"DeliverToPlantStorageLocation,omitempty" toml:"DeliverToPlantStorageLocation" yaml:"DeliverToPlantStorageLocation,omitempty"`
	ProductIsBatchManagedInDeliverToPlant         null.Bool    `boil:"ProductIsBatchManagedInDeliverToPlant" json:"ProductIsBatchManagedInDeliverToPlant,omitempty" toml:"ProductIsBatchManagedInDeliverToPlant" yaml:"ProductIsBatchManagedInDeliverToPlant,omitempty"`
	BatchMgmtPolicyInDeliverToPlant               null.String  `boil:"BatchMgmtPolicyInDeliverToPlant" json:"BatchMgmtPolicyInDeliverToPlant,omitempty" toml:"BatchMgmtPolicyInDeliverToPlant" yaml:"BatchMgmtPolicyInDeliverToPlant,omitempty"`
	DeliverToPlantBatch                           null.String  `boil:"DeliverToPlantBatch" json:"DeliverToPlantBatch,omitempty" toml:"DeliverToPlantBatch" yaml:"DeliverToPlantBatch,omitempty"`
	DeliverToPlantBatchValidityStartDate          null.String  `boil:"DeliverToPlantBatchValidityStartDate" json:"DeliverToPlantBatchValidityStartDate,omitempty" toml:"DeliverToPlantBatchValidityStartDate" yaml:"DeliverToPlantBatchValidityStartDate,omitempty"`
	DeliverToPlantBatchValidityStartTime          null.String  `boil:"DeliverToPlantBatchValidityStartTime" json:"DeliverToPlantBatchValidityStartTime,omitempty" toml:"DeliverToPlantBatchValidityStartTime" yaml:"DeliverToPlantBatchValidityStartTime,omitempty"`
	DeliverToPlantBatchValidityEndDate            null.String  `boil:"DeliverToPlantBatchValidityEndDate" json:"DeliverToPlantBatchValidityEndDate,omitempty" toml:"DeliverToPlantBatchValidityEndDate" yaml:"DeliverToPlantBatchValidityEndDate,omitempty"`
	DeliverToPlantBatchValidityEndTime            null.String  `boil:"DeliverToPlantBatchValidityEndTime" json:"DeliverToPlantBatchValidityEndTime,omitempty" toml:"DeliverToPlantBatchValidityEndTime" yaml:"DeliverToPlantBatchValidityEndTime,omitempty"`
	DeliverFromPlantTimeZone                      null.String  `boil:"DeliverFromPlantTimeZone" json:"DeliverFromPlantTimeZone,omitempty" toml:"DeliverFromPlantTimeZone" yaml:"DeliverFromPlantTimeZone,omitempty"`
	DeliverFromPlantStorageLocation               null.String  `boil:"DeliverFromPlantStorageLocation" json:"DeliverFromPlantStorageLocation,omitempty" toml:"DeliverFromPlantStorageLocation" yaml:"DeliverFromPlantStorageLocation,omitempty"`
	ProductIsBatchManagedInDeliverFromPlant       null.Bool    `boil:"ProductIsBatchManagedInDeliverFromPlant" json:"ProductIsBatchManagedInDeliverFromPlant,omitempty" toml:"ProductIsBatchManagedInDeliverFromPlant" yaml:"ProductIsBatchManagedInDeliverFromPlant,omitempty"`
	BatchMgmtPolicyInDeliverFromPlant             null.String  `boil:"BatchMgmtPolicyInDeliverFromPlant" json:"BatchMgmtPolicyInDeliverFromPlant,omitempty" toml:"BatchMgmtPolicyInDeliverFromPlant" yaml:"BatchMgmtPolicyInDeliverFromPlant,omitempty"`
	DeliverFromPlantBatch                         null.String  `boil:"DeliverFromPlantBatch" json:"DeliverFromPlantBatch,omitempty" toml:"DeliverFromPlantBatch" yaml:"DeliverFromPlantBatch,omitempty"`
	DeliverFromPlantBatchValidityStartDate        null.String  `boil:"DeliverFromPlantBatchValidityStartDate" json:"DeliverFromPlantBatchValidityStartDate,omitempty" toml:"DeliverFromPlantBatchValidityStartDate" yaml:"DeliverFromPlantBatchValidityStartDate,omitempty"`
	DeliverFromPlantBatchValidityStartTime        null.String  `boil:"DeliverFromPlantBatchValidityStartTime" json:"DeliverFromPlantBatchValidityStartTime,omitempty" toml:"DeliverFromPlantBatchValidityStartTime" yaml:"DeliverFromPlantBatchValidityStartTime,omitempty"`
	DeliverFromPlantBatchValidityEndDate          null.String  `boil:"DeliverFromPlantBatchValidityEndDate" json:"DeliverFromPlantBatchValidityEndDate,omitempty" toml:"DeliverFromPlantBatchValidityEndDate" yaml:"DeliverFromPlantBatchValidityEndDate,omitempty"`
	DeliverFromPlantBatchValidityEndTime          null.String  `boil:"DeliverFromPlantBatchValidityEndTime" json:"DeliverFromPlantBatchValidityEndTime,omitempty" toml:"DeliverFromPlantBatchValidityEndTime" yaml:"DeliverFromPlantBatchValidityEndTime,omitempty"`
	StockConfirmationBusinessPartner              null.Int     `boil:"StockConfirmationBusinessPartner" json:"StockConfirmationBusinessPartner,omitempty" toml:"StockConfirmationBusinessPartner" yaml:"StockConfirmationBusinessPartner,omitempty"`
	StockConfirmationPlant                        null.String  `boil:"StockConfirmationPlant" json:"StockConfirmationPlant,omitempty" toml:"StockConfirmationPlant" yaml:"StockConfirmationPlant,omitempty"`
	StockConfirmationPlantTimeZone                null.String  `boil:"StockConfirmationPlantTimeZone" json:"StockConfirmationPlantTimeZone,omitempty" toml:"StockConfirmationPlantTimeZone" yaml:"StockConfirmationPlantTimeZone,omitempty"`
	ProductIsBatchManagedInStockConfirmationPlant null.Bool    `boil:"ProductIsBatchManagedInStockConfirmationPlant" json:"ProductIsBatchManagedInStockConfirmationPlant,omitempty" toml:"ProductIsBatchManagedInStockConfirmationPlant" yaml:"ProductIsBatchManagedInStockConfirmationPlant,omitempty"`
	BatchMgmtPolicyInStockConfirmationPlant       null.String  `boil:"BatchMgmtPolicyInStockConfirmationPlant" json:"BatchMgmtPolicyInStockConfirmationPlant,omitempty" toml:"BatchMgmtPolicyInStockConfirmationPlant" yaml:"BatchMgmtPolicyInStockConfirmationPlant,omitempty"`
	StockConfirmationPlantBatch                   null.String  `boil:"StockConfirmationPlantBatch" json:"StockConfirmationPlantBatch,omitempty" toml:"StockConfirmationPlantBatch" yaml:"StockConfirmationPlantBatch,omitempty"`
	StockConfirmationPlantBatchValidityStartDate  null.String  `boil:"StockConfirmationPlantBatchValidityStartDate" json:"StockConfirmationPlantBatchValidityStartDate,omitempty" toml:"StockConfirmationPlantBatchValidityStartDate" yaml:"StockConfirmationPlantBatchValidityStartDate,omitempty"`
	StockConfirmationPlantBatchValidityStartTime  null.String  `boil:"StockConfirmationPlantBatchValidityStartTime" json:"StockConfirmationPlantBatchValidityStartTime,omitempty" toml:"StockConfirmationPlantBatchValidityStartTime" yaml:"StockConfirmationPlantBatchValidityStartTime,omitempty"`
	StockConfirmationPlantBatchValidityEndDate    null.String  `boil:"StockConfirmationPlantBatchValidityEndDate" json:"StockConfirmationPlantBatchValidityEndDate,omitempty" toml:"StockConfirmationPlantBatchValidityEndDate" yaml:"StockConfirmationPlantBatchValidityEndDate,omitempty"`
	StockConfirmationPlantBatchValidityEndTime    null.String  `boil:"StockConfirmationPlantBatchValidityEndTime" json:"StockConfirmationPlantBatchValidityEndTime,omitempty" toml:"StockConfirmationPlantBatchValidityEndTime" yaml:"StockConfirmationPlantBatchValidityEndTime,omitempty"`
	ServicesRenderingDate                         null.String  `boil:"ServicesRenderingDate" json:"ServicesRenderingDate,omitempty" toml:"ServicesRenderingDate" yaml:"ServicesRenderingDate,omitempty"`
	OrderQuantityInBaseUnit                       float32      `boil:"OrderQuantityInBaseUnit" json:"OrderQuantityInBaseUnit" toml:"OrderQuantityInBaseUnit" yaml:"OrderQuantityInBaseUnit"`
	OrderQuantityInDeliveryUnit                   float32      `boil:"OrderQuantityInDeliveryUnit" json:"OrderQuantityInDeliveryUnit" toml:"OrderQuantityInDeliveryUnit" yaml:"OrderQuantityInDeliveryUnit"`
	QuantityPerPackage                            float32      `boil:"QuantityPerPackage" json:"QuantityPerPackage" toml:"QuantityPerPackage" yaml:"QuantityPerPackage"`
	StockConfirmationPolicy                       null.String  `boil:"StockConfirmationPolicy" json:"StockConfirmationPolicy,omitempty" toml:"StockConfirmationPolicy" yaml:"StockConfirmationPolicy,omitempty"`
	StockConfirmationStatus                       null.String  `boil:"StockConfirmationStatus" json:"StockConfirmationStatus,omitempty" toml:"StockConfirmationStatus" yaml:"StockConfirmationStatus,omitempty"`
	ConfirmedOrderQuantityInBaseUnit              null.Float32 `boil:"ConfirmedOrderQuantityInBaseUnit" json:"ConfirmedOrderQuantityInBaseUnit,omitempty" toml:"ConfirmedOrderQuantityInBaseUnit" yaml:"ConfirmedOrderQuantityInBaseUnit,omitempty"`
	ProductWeightUnit                             null.String  `boil:"ProductWeightUnit" json:"ProductWeightUnit,omitempty" toml:"ProductWeightUnit" yaml:"ProductWeightUnit,omitempty"`
	ProductNetWeight                              null.Float32 `boil:"ProductNetWeight" json:"ProductNetWeight,omitempty" toml:"ProductNetWeight" yaml:"ProductNetWeight,omitempty"`
	ItemNetWeight                                 null.Float32 `boil:"ItemNetWeight" json:"ItemNetWeight,omitempty" toml:"ItemNetWeight" yaml:"ItemNetWeight,omitempty"`
	ProductGrossWeight                            null.Float32 `boil:"ProductGrossWeight" json:"ProductGrossWeight,omitempty" toml:"ProductGrossWeight" yaml:"ProductGrossWeight,omitempty"`
	ItemGrossWeight                               null.Float32 `boil:"ItemGrossWeight" json:"ItemGrossWeight,omitempty" toml:"ItemGrossWeight" yaml:"ItemGrossWeight,omitempty"`
	InternalCapacityQuantity                      null.Float32 `boil:"InternalCapacityQuantity" json:"InternalCapacityQuantity,omitempty" toml:"InternalCapacityQuantity" yaml:"InternalCapacityQuantity,omitempty"`
	InternalCapacityQuantityUnit                  null.String  `boil:"InternalCapacityQuantityUnit" json:"InternalCapacityQuantityUnit,omitempty" toml:"InternalCapacityQuantityUnit" yaml:"InternalCapacityQuantityUnit,omitempty"`
	NetAmount                                     float32      `boil:"NetAmount" json:"NetAmount" toml:"NetAmount" yaml:"NetAmount"`
	TaxAmount                                     float32      `boil:"TaxAmount" json:"TaxAmount" toml:"TaxAmount" yaml:"TaxAmount"`
	GrossAmount                                   float32      `boil:"GrossAmount" json:"GrossAmount" toml:"GrossAmount" yaml:"GrossAmount"`
	InvoiceDocumentDate                           null.String  `boil:"InvoiceDocumentDate" json:"InvoiceDocumentDate,omitempty" toml:"InvoiceDocumentDate" yaml:"InvoiceDocumentDate,omitempty"`
	ProductionPlantBusinessPartner                null.Int     `boil:"ProductionPlantBusinessPartner" json:"ProductionPlantBusinessPartner,omitempty" toml:"ProductionPlantBusinessPartner" yaml:"ProductionPlantBusinessPartner,omitempty"`
	ProductionPlant                               null.String  `boil:"ProductionPlant" json:"ProductionPlant,omitempty" toml:"ProductionPlant" yaml:"ProductionPlant,omitempty"`
	ProductionPlantTimeZone                       null.String  `boil:"ProductionPlantTimeZone" json:"ProductionPlantTimeZone,omitempty" toml:"ProductionPlantTimeZone" yaml:"ProductionPlantTimeZone,omitempty"`
	ProductionPlantStorageLocation                null.String  `boil:"ProductionPlantStorageLocation" json:"ProductionPlantStorageLocation,omitempty" toml:"ProductionPlantStorageLocation" yaml:"ProductionPlantStorageLocation,omitempty"`
	ProductIsBatchManagedInProductionPlant        null.Bool    `boil:"ProductIsBatchManagedInProductionPlant" json:"ProductIsBatchManagedInProductionPlant,omitempty" toml:"ProductIsBatchManagedInProductionPlant" yaml:"ProductIsBatchManagedInProductionPlant,omitempty"`
	BatchMgmtPolicyInProductionPlant              null.String  `boil:"BatchMgmtPolicyInProductionPlant" json:"BatchMgmtPolicyInProductionPlant,omitempty" toml:"BatchMgmtPolicyInProductionPlant" yaml:"BatchMgmtPolicyInProductionPlant,omitempty"`
	ProductionPlantBatch                          null.String  `boil:"ProductionPlantBatch" json:"ProductionPlantBatch,omitempty" toml:"ProductionPlantBatch" yaml:"ProductionPlantBatch,omitempty"`
	ProductionPlantBatchValidityStartDate         null.String  `boil:"ProductionPlantBatchValidityStartDate" json:"ProductionPlantBatchValidityStartDate,omitempty" toml:"ProductionPlantBatchValidityStartDate" yaml:"ProductionPlantBatchValidityStartDate,omitempty"`
	ProductionPlantBatchValidityStartTime         null.String  `boil:"ProductionPlantBatchValidityStartTime" json:"ProductionPlantBatchValidityStartTime,omitempty" toml:"ProductionPlantBatchValidityStartTime" yaml:"ProductionPlantBatchValidityStartTime,omitempty"`
	ProductionPlantBatchValidityEndDate           null.String  `boil:"ProductionPlantBatchValidityEndDate" json:"ProductionPlantBatchValidityEndDate,omitempty" toml:"ProductionPlantBatchValidityEndDate" yaml:"ProductionPlantBatchValidityEndDate,omitempty"`
	ProductionPlantBatchValidityEndTime           null.String  `boil:"ProductionPlantBatchValidityEndTime" json:"ProductionPlantBatchValidityEndTime,omitempty" toml:"ProductionPlantBatchValidityEndTime" yaml:"ProductionPlantBatchValidityEndTime,omitempty"`
	InspectionPlantBusinessPartner                null.Int     `boil:"InspectionPlantBusinessPartner" json:"InspectionPlantBusinessPartner,omitempty" toml:"InspectionPlantBusinessPartner" yaml:"InspectionPlantBusinessPartner,omitempty"`
	InspectionPlant                               null.String  `boil:"InspectionPlant" json:"InspectionPlant,omitempty" toml:"InspectionPlant" yaml:"InspectionPlant,omitempty"`
	InspectionPlan                                null.Int     `boil:"InspectionPlan" json:"InspectionPlan,omitempty" toml:"InspectionPlan" yaml:"InspectionPlan,omitempty"`
	InspectionLot                                 null.Int     `boil:"InspectionLot" json:"InspectionLot,omitempty" toml:"InspectionLot" yaml:"InspectionLot,omitempty"`
	Incoterms                                     null.String  `boil:"Incoterms" json:"Incoterms,omitempty" toml:"Incoterms" yaml:"Incoterms,omitempty"`
	TransactionTaxClassification                  string       `boil:"TransactionTaxClassification" json:"TransactionTaxClassification" toml:"TransactionTaxClassification" yaml:"TransactionTaxClassification"`
	ProductTaxClassificationBillToCountry         string       `boil:"ProductTaxClassificationBillToCountry" json:"ProductTaxClassificationBillToCountry" toml:"ProductTaxClassificationBillToCountry" yaml:"ProductTaxClassificationBillToCountry"`
	ProductTaxClassificationBillFromCountry       string       `boil:"ProductTaxClassificationBillFromCountry" json:"ProductTaxClassificationBillFromCountry" toml:"ProductTaxClassificationBillFromCountry" yaml:"ProductTaxClassificationBillFromCountry"`
	DefinedTaxClassification                      string       `boil:"DefinedTaxClassification" json:"DefinedTaxClassification" toml:"DefinedTaxClassification" yaml:"DefinedTaxClassification"`
	AccountAssignmentGroup                        string       `boil:"AccountAssignmentGroup" json:"AccountAssignmentGroup" toml:"AccountAssignmentGroup" yaml:"AccountAssignmentGroup"`
	ProductAccountAssignmentGroup                 string       `boil:"ProductAccountAssignmentGroup" json:"ProductAccountAssignmentGroup" toml:"ProductAccountAssignmentGroup" yaml:"ProductAccountAssignmentGroup"`
	PaymentTerms                                  string       `boil:"PaymentTerms" json:"PaymentTerms" toml:"PaymentTerms" yaml:"PaymentTerms"`
	DueCalculationBaseDate                        null.String  `boil:"DueCalculationBaseDate" json:"DueCalculationBaseDate,omitempty" toml:"DueCalculationBaseDate" yaml:"DueCalculationBaseDate,omitempty"`
	PaymentDueDate                                null.String  `boil:"PaymentDueDate" json:"PaymentDueDate,omitempty" toml:"PaymentDueDate" yaml:"PaymentDueDate,omitempty"`
	NetPaymentDays                                null.Int     `boil:"NetPaymentDays" json:"NetPaymentDays,omitempty" toml:"NetPaymentDays" yaml:"NetPaymentDays,omitempty"`
	PaymentMethod                                 string       `boil:"PaymentMethod" json:"PaymentMethod" toml:"PaymentMethod" yaml:"PaymentMethod"`
	Contract                                      null.Int     `boil:"Contract" json:"Contract,omitempty" toml:"Contract" yaml:"Contract,omitempty"`
	ContractItem                                  null.Int     `boil:"ContractItem" json:"ContractItem,omitempty" toml:"ContractItem" yaml:"ContractItem,omitempty"`
	Project                                       null.Int     `boil:"Project" json:"Project,omitempty" toml:"Project" yaml:"Project,omitempty"`
	WBSElement                                    null.Int     `boil:"WBSElement" json:"WBSElement,omitempty" toml:"WBSElement" yaml:"WBSElement,omitempty"`
	AccountingExchangeRate                        null.Float32 `boil:"AccountingExchangeRate" json:"AccountingExchangeRate,omitempty" toml:"AccountingExchangeRate" yaml:"AccountingExchangeRate,omitempty"`
	ReferenceDocument                             null.Int     `boil:"ReferenceDocument" json:"ReferenceDocument,omitempty" toml:"ReferenceDocument" yaml:"ReferenceDocument,omitempty"`
	ReferenceDocumentItem                         null.Int     `boil:"ReferenceDocumentItem" json:"ReferenceDocumentItem,omitempty" toml:"ReferenceDocumentItem" yaml:"ReferenceDocumentItem,omitempty"`
	ItemCompleteDeliveryIsDefined                 null.Bool    `boil:"ItemCompleteDeliveryIsDefined" json:"ItemCompleteDeliveryIsDefined,omitempty" toml:"ItemCompleteDeliveryIsDefined" yaml:"ItemCompleteDeliveryIsDefined,omitempty"`
	ItemDeliveryStatus                            null.String  `boil:"ItemDeliveryStatus" json:"ItemDeliveryStatus,omitempty" toml:"ItemDeliveryStatus" yaml:"ItemDeliveryStatus,omitempty"`
	IssuingStatus                                 null.String  `boil:"IssuingStatus" json:"IssuingStatus,omitempty" toml:"IssuingStatus" yaml:"IssuingStatus,omitempty"`
	ReceivingStatus                               null.String  `boil:"ReceivingStatus" json:"ReceivingStatus,omitempty" toml:"ReceivingStatus" yaml:"ReceivingStatus,omitempty"`
	ItemBillingStatus                             null.String  `boil:"ItemBillingStatus" json:"ItemBillingStatus,omitempty" toml:"ItemBillingStatus" yaml:"ItemBillingStatus,omitempty"`
	TaxCode                                       null.String  `boil:"TaxCode" json:"TaxCode,omitempty" toml:"TaxCode" yaml:"TaxCode,omitempty"`
	TaxRate                                       null.Float32 `boil:"TaxRate" json:"TaxRate,omitempty" toml:"TaxRate" yaml:"TaxRate,omitempty"`
	CountryOfOrigin                               null.String  `boil:"CountryOfOrigin" json:"CountryOfOrigin,omitempty" toml:"CountryOfOrigin" yaml:"CountryOfOrigin,omitempty"`
	CountryOfOriginLanguage                       null.String  `boil:"CountryOfOriginLanguage" json:"CountryOfOriginLanguage,omitempty" toml:"CountryOfOriginLanguage" yaml:"CountryOfOriginLanguage,omitempty"`
	Equipment                                     null.Int     `boil:"Equipment" json:"Equipment,omitempty" toml:"Equipment" yaml:"Equipment,omitempty"`
	FreightAgreement                              null.Int     `boil:"FreightAgreement" json:"FreightAgreement,omitempty" toml:"FreightAgreement" yaml:"FreightAgreement,omitempty"`
	FreightAgreementItem                          null.Int     `boil:"FreightAgreementItem" json:"FreightAgreementItem,omitempty" toml:"FreightAgreementItem" yaml:"FreightAgreementItem,omitempty"`
	ItemBlockStatus                               null.Bool    `boil:"ItemBlockStatus" json:"ItemBlockStatus,omitempty" toml:"ItemBlockStatus" yaml:"ItemBlockStatus,omitempty"`
	ItemDeliveryBlockStatus                       null.Bool    `boil:"ItemDeliveryBlockStatus" json:"ItemDeliveryBlockStatus,omitempty" toml:"ItemDeliveryBlockStatus" yaml:"ItemDeliveryBlockStatus,omitempty"`
	ItemBillingBlockStatus                        null.Bool    `boil:"ItemBillingBlockStatus" json:"ItemBillingBlockStatus,omitempty" toml:"ItemBillingBlockStatus" yaml:"ItemBillingBlockStatus,omitempty"`
	ExternalReferenceDocument                     null.String  `boil:"ExternalReferenceDocument" json:"ExternalReferenceDocument,omitempty" toml:"ExternalReferenceDocument" yaml:"ExternalReferenceDocument,omitempty"`
	ExternalReferenceDocumentItem                 null.String  `boil:"ExternalReferenceDocumentItem" json:"ExternalReferenceDocumentItem,omitempty" toml:"ExternalReferenceDocumentItem" yaml:"ExternalReferenceDocumentItem,omitempty"`
	CreationDate                                  string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                                  string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                                string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                                string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsCancelled                                   null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                           null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformOrdersItemDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformOrdersItemDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformOrdersItemDatumColumns = struct {
	OrderID                                       string
	OrderItem                                     string
	OrderItemCategory                             string
	OrderStatus                                   string
	SupplyChainRelationshipID                     string
	SupplyChainRelationshipDeliveryID             string
	SupplyChainRelationshipDeliveryPlantID        string
	SupplyChainRelationshipStockConfPlantID       string
	SupplyChainRelationshipProductionPlantID      string
	Buyer                                         string
	Seller                                        string
	DeliverToParty                                string
	DeliverFromParty                              string
	DeliverToPlant                                string
	DeliverFromPlant                              string
	OrderItemText                                 string
	OrderItemTextByBuyer                          string
	OrderItemTextBySeller                         string
	Product                                       string
	SizeOrDimensionText                           string
	ProductStandardID                             string
	ProductGroup                                  string
	ProductSpecification                          string
	MarkingOfMaterial                             string
	BaseUnit                                      string
	DeliveryUnit                                  string
	ProductionVersion                             string
	ProductionVersionItem                         string
	BillOfMaterial                                string
	BillOfMaterialItem                            string
	ProductionOrder                               string
	ProductionOrderItem                           string
	Operations                                    string
	OperationsItem                                string
	OperationID                                   string
	PricingDate                                   string
	PriceDetnExchangeRate                         string
	RequestedDeliveryDate                         string
	RequestedDeliveryTime                         string
	DeliverToPlantTimeZone                        string
	DeliverToPlantStorageLocation                 string
	ProductIsBatchManagedInDeliverToPlant         string
	BatchMgmtPolicyInDeliverToPlant               string
	DeliverToPlantBatch                           string
	DeliverToPlantBatchValidityStartDate          string
	DeliverToPlantBatchValidityStartTime          string
	DeliverToPlantBatchValidityEndDate            string
	DeliverToPlantBatchValidityEndTime            string
	DeliverFromPlantTimeZone                      string
	DeliverFromPlantStorageLocation               string
	ProductIsBatchManagedInDeliverFromPlant       string
	BatchMgmtPolicyInDeliverFromPlant             string
	DeliverFromPlantBatch                         string
	DeliverFromPlantBatchValidityStartDate        string
	DeliverFromPlantBatchValidityStartTime        string
	DeliverFromPlantBatchValidityEndDate          string
	DeliverFromPlantBatchValidityEndTime          string
	StockConfirmationBusinessPartner              string
	StockConfirmationPlant                        string
	StockConfirmationPlantTimeZone                string
	ProductIsBatchManagedInStockConfirmationPlant string
	BatchMgmtPolicyInStockConfirmationPlant       string
	StockConfirmationPlantBatch                   string
	StockConfirmationPlantBatchValidityStartDate  string
	StockConfirmationPlantBatchValidityStartTime  string
	StockConfirmationPlantBatchValidityEndDate    string
	StockConfirmationPlantBatchValidityEndTime    string
	ServicesRenderingDate                         string
	OrderQuantityInBaseUnit                       string
	OrderQuantityInDeliveryUnit                   string
	QuantityPerPackage                            string
	StockConfirmationPolicy                       string
	StockConfirmationStatus                       string
	ConfirmedOrderQuantityInBaseUnit              string
	ProductWeightUnit                             string
	ProductNetWeight                              string
	ItemNetWeight                                 string
	ProductGrossWeight                            string
	ItemGrossWeight                               string
	InternalCapacityQuantity                      string
	InternalCapacityQuantityUnit                  string
	NetAmount                                     string
	TaxAmount                                     string
	GrossAmount                                   string
	InvoiceDocumentDate                           string
	ProductionPlantBusinessPartner                string
	ProductionPlant                               string
	ProductionPlantTimeZone                       string
	ProductionPlantStorageLocation                string
	ProductIsBatchManagedInProductionPlant        string
	BatchMgmtPolicyInProductionPlant              string
	ProductionPlantBatch                          string
	ProductionPlantBatchValidityStartDate         string
	ProductionPlantBatchValidityStartTime         string
	ProductionPlantBatchValidityEndDate           string
	ProductionPlantBatchValidityEndTime           string
	InspectionPlantBusinessPartner                string
	InspectionPlant                               string
	InspectionPlan                                string
	InspectionLot                                 string
	Incoterms                                     string
	TransactionTaxClassification                  string
	ProductTaxClassificationBillToCountry         string
	ProductTaxClassificationBillFromCountry       string
	DefinedTaxClassification                      string
	AccountAssignmentGroup                        string
	ProductAccountAssignmentGroup                 string
	PaymentTerms                                  string
	DueCalculationBaseDate                        string
	PaymentDueDate                                string
	NetPaymentDays                                string
	PaymentMethod                                 string
	Contract                                      string
	ContractItem                                  string
	Project                                       string
	WBSElement                                    string
	AccountingExchangeRate                        string
	ReferenceDocument                             string
	ReferenceDocumentItem                         string
	ItemCompleteDeliveryIsDefined                 string
	ItemDeliveryStatus                            string
	IssuingStatus                                 string
	ReceivingStatus                               string
	ItemBillingStatus                             string
	TaxCode                                       string
	TaxRate                                       string
	CountryOfOrigin                               string
	CountryOfOriginLanguage                       string
	Equipment                                     string
	FreightAgreement                              string
	FreightAgreementItem                          string
	ItemBlockStatus                               string
	ItemDeliveryBlockStatus                       string
	ItemBillingBlockStatus                        string
	ExternalReferenceDocument                     string
	ExternalReferenceDocumentItem                 string
	CreationDate                                  string
	CreationTime                                  string
	LastChangeDate                                string
	LastChangeTime                                string
	IsCancelled                                   string
	IsMarkedForDeletion                           string
}{
	OrderID:                                       "OrderID",
	OrderItem:                                     "OrderItem",
	OrderItemCategory:                             "OrderItemCategory",
	OrderStatus:                                   "OrderStatus",
	SupplyChainRelationshipID:                     "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:             "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:        "SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipStockConfPlantID:       "SupplyChainRelationshipStockConfPlantID",
	SupplyChainRelationshipProductionPlantID:      "SupplyChainRelationshipProductionPlantID",
	Buyer:                                         "Buyer",
	Seller:                                        "Seller",
	DeliverToParty:                                "DeliverToParty",
	DeliverFromParty:                              "DeliverFromParty",
	DeliverToPlant:                                "DeliverToPlant",
	DeliverFromPlant:                              "DeliverFromPlant",
	OrderItemText:                                 "OrderItemText",
	OrderItemTextByBuyer:                          "OrderItemTextByBuyer",
	OrderItemTextBySeller:                         "OrderItemTextBySeller",
	Product:                                       "Product",
	SizeOrDimensionText:                           "SizeOrDimensionText",
	ProductStandardID:                             "ProductStandardID",
	ProductGroup:                                  "ProductGroup",
	ProductSpecification:                          "ProductSpecification",
	MarkingOfMaterial:                             "MarkingOfMaterial",
	BaseUnit:                                      "BaseUnit",
	DeliveryUnit:                                  "DeliveryUnit",
	ProductionVersion:                             "ProductionVersion",
	ProductionVersionItem:                         "ProductionVersionItem",
	BillOfMaterial:                                "BillOfMaterial",
	BillOfMaterialItem:                            "BillOfMaterialItem",
	ProductionOrder:                               "ProductionOrder",
	ProductionOrderItem:                           "ProductionOrderItem",
	Operations:                                    "Operations",
	OperationsItem:                                "OperationsItem",
	OperationID:                                   "OperationID",
	PricingDate:                                   "PricingDate",
	PriceDetnExchangeRate:                         "PriceDetnExchangeRate",
	RequestedDeliveryDate:                         "RequestedDeliveryDate",
	RequestedDeliveryTime:                         "RequestedDeliveryTime",
	DeliverToPlantTimeZone:                        "DeliverToPlantTimeZone",
	DeliverToPlantStorageLocation:                 "DeliverToPlantStorageLocation",
	ProductIsBatchManagedInDeliverToPlant:         "ProductIsBatchManagedInDeliverToPlant",
	BatchMgmtPolicyInDeliverToPlant:               "BatchMgmtPolicyInDeliverToPlant",
	DeliverToPlantBatch:                           "DeliverToPlantBatch",
	DeliverToPlantBatchValidityStartDate:          "DeliverToPlantBatchValidityStartDate",
	DeliverToPlantBatchValidityStartTime:          "DeliverToPlantBatchValidityStartTime",
	DeliverToPlantBatchValidityEndDate:            "DeliverToPlantBatchValidityEndDate",
	DeliverToPlantBatchValidityEndTime:            "DeliverToPlantBatchValidityEndTime",
	DeliverFromPlantTimeZone:                      "DeliverFromPlantTimeZone",
	DeliverFromPlantStorageLocation:               "DeliverFromPlantStorageLocation",
	ProductIsBatchManagedInDeliverFromPlant:       "ProductIsBatchManagedInDeliverFromPlant",
	BatchMgmtPolicyInDeliverFromPlant:             "BatchMgmtPolicyInDeliverFromPlant",
	DeliverFromPlantBatch:                         "DeliverFromPlantBatch",
	DeliverFromPlantBatchValidityStartDate:        "DeliverFromPlantBatchValidityStartDate",
	DeliverFromPlantBatchValidityStartTime:        "DeliverFromPlantBatchValidityStartTime",
	DeliverFromPlantBatchValidityEndDate:          "DeliverFromPlantBatchValidityEndDate",
	DeliverFromPlantBatchValidityEndTime:          "DeliverFromPlantBatchValidityEndTime",
	StockConfirmationBusinessPartner:              "StockConfirmationBusinessPartner",
	StockConfirmationPlant:                        "StockConfirmationPlant",
	StockConfirmationPlantTimeZone:                "StockConfirmationPlantTimeZone",
	ProductIsBatchManagedInStockConfirmationPlant: "ProductIsBatchManagedInStockConfirmationPlant",
	BatchMgmtPolicyInStockConfirmationPlant:       "BatchMgmtPolicyInStockConfirmationPlant",
	StockConfirmationPlantBatch:                   "StockConfirmationPlantBatch",
	StockConfirmationPlantBatchValidityStartDate:  "StockConfirmationPlantBatchValidityStartDate",
	StockConfirmationPlantBatchValidityStartTime:  "StockConfirmationPlantBatchValidityStartTime",
	StockConfirmationPlantBatchValidityEndDate:    "StockConfirmationPlantBatchValidityEndDate",
	StockConfirmationPlantBatchValidityEndTime:    "StockConfirmationPlantBatchValidityEndTime",
	ServicesRenderingDate:                         "ServicesRenderingDate",
	OrderQuantityInBaseUnit:                       "OrderQuantityInBaseUnit",
	OrderQuantityInDeliveryUnit:                   "OrderQuantityInDeliveryUnit",
	QuantityPerPackage:                            "QuantityPerPackage",
	StockConfirmationPolicy:                       "StockConfirmationPolicy",
	StockConfirmationStatus:                       "StockConfirmationStatus",
	ConfirmedOrderQuantityInBaseUnit:              "ConfirmedOrderQuantityInBaseUnit",
	ProductWeightUnit:                             "ProductWeightUnit",
	ProductNetWeight:                              "ProductNetWeight",
	ItemNetWeight:                                 "ItemNetWeight",
	ProductGrossWeight:                            "ProductGrossWeight",
	ItemGrossWeight:                               "ItemGrossWeight",
	InternalCapacityQuantity:                      "InternalCapacityQuantity",
	InternalCapacityQuantityUnit:                  "InternalCapacityQuantityUnit",
	NetAmount:                                     "NetAmount",
	TaxAmount:                                     "TaxAmount",
	GrossAmount:                                   "GrossAmount",
	InvoiceDocumentDate:                           "InvoiceDocumentDate",
	ProductionPlantBusinessPartner:                "ProductionPlantBusinessPartner",
	ProductionPlant:                               "ProductionPlant",
	ProductionPlantTimeZone:                       "ProductionPlantTimeZone",
	ProductionPlantStorageLocation:                "ProductionPlantStorageLocation",
	ProductIsBatchManagedInProductionPlant:        "ProductIsBatchManagedInProductionPlant",
	BatchMgmtPolicyInProductionPlant:              "BatchMgmtPolicyInProductionPlant",
	ProductionPlantBatch:                          "ProductionPlantBatch",
	ProductionPlantBatchValidityStartDate:         "ProductionPlantBatchValidityStartDate",
	ProductionPlantBatchValidityStartTime:         "ProductionPlantBatchValidityStartTime",
	ProductionPlantBatchValidityEndDate:           "ProductionPlantBatchValidityEndDate",
	ProductionPlantBatchValidityEndTime:           "ProductionPlantBatchValidityEndTime",
	InspectionPlantBusinessPartner:                "InspectionPlantBusinessPartner",
	InspectionPlant:                               "InspectionPlant",
	InspectionPlan:                                "InspectionPlan",
	InspectionLot:                                 "InspectionLot",
	Incoterms:                                     "Incoterms",
	TransactionTaxClassification:                  "TransactionTaxClassification",
	ProductTaxClassificationBillToCountry:         "ProductTaxClassificationBillToCountry",
	ProductTaxClassificationBillFromCountry:       "ProductTaxClassificationBillFromCountry",
	DefinedTaxClassification:                      "DefinedTaxClassification",
	AccountAssignmentGroup:                        "AccountAssignmentGroup",
	ProductAccountAssignmentGroup:                 "ProductAccountAssignmentGroup",
	PaymentTerms:                                  "PaymentTerms",
	DueCalculationBaseDate:                        "DueCalculationBaseDate",
	PaymentDueDate:                                "PaymentDueDate",
	NetPaymentDays:                                "NetPaymentDays",
	PaymentMethod:                                 "PaymentMethod",
	Contract:                                      "Contract",
	ContractItem:                                  "ContractItem",
	Project:                                       "Project",
	WBSElement:                                    "WBSElement",
	AccountingExchangeRate:                        "AccountingExchangeRate",
	ReferenceDocument:                             "ReferenceDocument",
	ReferenceDocumentItem:                         "ReferenceDocumentItem",
	ItemCompleteDeliveryIsDefined:                 "ItemCompleteDeliveryIsDefined",
	ItemDeliveryStatus:                            "ItemDeliveryStatus",
	IssuingStatus:                                 "IssuingStatus",
	ReceivingStatus:                               "ReceivingStatus",
	ItemBillingStatus:                             "ItemBillingStatus",
	TaxCode:                                       "TaxCode",
	TaxRate:                                       "TaxRate",
	CountryOfOrigin:                               "CountryOfOrigin",
	CountryOfOriginLanguage:                       "CountryOfOriginLanguage",
	Equipment:                                     "Equipment",
	FreightAgreement:                              "FreightAgreement",
	FreightAgreementItem:                          "FreightAgreementItem",
	ItemBlockStatus:                               "ItemBlockStatus",
	ItemDeliveryBlockStatus:                       "ItemDeliveryBlockStatus",
	ItemBillingBlockStatus:                        "ItemBillingBlockStatus",
	ExternalReferenceDocument:                     "ExternalReferenceDocument",
	ExternalReferenceDocumentItem:                 "ExternalReferenceDocumentItem",
	CreationDate:                                  "CreationDate",
	CreationTime:                                  "CreationTime",
	LastChangeDate:                                "LastChangeDate",
	LastChangeTime:                                "LastChangeTime",
	IsCancelled:                                   "IsCancelled",
	IsMarkedForDeletion:                           "IsMarkedForDeletion",
}

var DataPlatformOrdersItemDatumTableColumns = struct {
	OrderID                                       string
	OrderItem                                     string
	OrderItemCategory                             string
	OrderStatus                                   string
	SupplyChainRelationshipID                     string
	SupplyChainRelationshipDeliveryID             string
	SupplyChainRelationshipDeliveryPlantID        string
	SupplyChainRelationshipStockConfPlantID       string
	SupplyChainRelationshipProductionPlantID      string
	Buyer                                         string
	Seller                                        string
	DeliverToParty                                string
	DeliverFromParty                              string
	DeliverToPlant                                string
	DeliverFromPlant                              string
	OrderItemText                                 string
	OrderItemTextByBuyer                          string
	OrderItemTextBySeller                         string
	Product                                       string
	SizeOrDimensionText                           string
	ProductStandardID                             string
	ProductGroup                                  string
	ProductSpecification                          string
	MarkingOfMaterial                             string
	BaseUnit                                      string
	DeliveryUnit                                  string
	ProductionVersion                             string
	ProductionVersionItem                         string
	BillOfMaterial                                string
	BillOfMaterialItem                            string
	ProductionOrder                               string
	ProductionOrderItem                           string
	Operations                                    string
	OperationsItem                                string
	OperationID                                   string
	PricingDate                                   string
	PriceDetnExchangeRate                         string
	RequestedDeliveryDate                         string
	RequestedDeliveryTime                         string
	DeliverToPlantTimeZone                        string
	DeliverToPlantStorageLocation                 string
	ProductIsBatchManagedInDeliverToPlant         string
	BatchMgmtPolicyInDeliverToPlant               string
	DeliverToPlantBatch                           string
	DeliverToPlantBatchValidityStartDate          string
	DeliverToPlantBatchValidityStartTime          string
	DeliverToPlantBatchValidityEndDate            string
	DeliverToPlantBatchValidityEndTime            string
	DeliverFromPlantTimeZone                      string
	DeliverFromPlantStorageLocation               string
	ProductIsBatchManagedInDeliverFromPlant       string
	BatchMgmtPolicyInDeliverFromPlant             string
	DeliverFromPlantBatch                         string
	DeliverFromPlantBatchValidityStartDate        string
	DeliverFromPlantBatchValidityStartTime        string
	DeliverFromPlantBatchValidityEndDate          string
	DeliverFromPlantBatchValidityEndTime          string
	StockConfirmationBusinessPartner              string
	StockConfirmationPlant                        string
	StockConfirmationPlantTimeZone                string
	ProductIsBatchManagedInStockConfirmationPlant string
	BatchMgmtPolicyInStockConfirmationPlant       string
	StockConfirmationPlantBatch                   string
	StockConfirmationPlantBatchValidityStartDate  string
	StockConfirmationPlantBatchValidityStartTime  string
	StockConfirmationPlantBatchValidityEndDate    string
	StockConfirmationPlantBatchValidityEndTime    string
	ServicesRenderingDate                         string
	OrderQuantityInBaseUnit                       string
	OrderQuantityInDeliveryUnit                   string
	QuantityPerPackage                            string
	StockConfirmationPolicy                       string
	StockConfirmationStatus                       string
	ConfirmedOrderQuantityInBaseUnit              string
	ProductWeightUnit                             string
	ProductNetWeight                              string
	ItemNetWeight                                 string
	ProductGrossWeight                            string
	ItemGrossWeight                               string
	InternalCapacityQuantity                      string
	InternalCapacityQuantityUnit                  string
	NetAmount                                     string
	TaxAmount                                     string
	GrossAmount                                   string
	InvoiceDocumentDate                           string
	ProductionPlantBusinessPartner                string
	ProductionPlant                               string
	ProductionPlantTimeZone                       string
	ProductionPlantStorageLocation                string
	ProductIsBatchManagedInProductionPlant        string
	BatchMgmtPolicyInProductionPlant              string
	ProductionPlantBatch                          string
	ProductionPlantBatchValidityStartDate         string
	ProductionPlantBatchValidityStartTime         string
	ProductionPlantBatchValidityEndDate           string
	ProductionPlantBatchValidityEndTime           string
	InspectionPlantBusinessPartner                string
	InspectionPlant                               string
	InspectionPlan                                string
	InspectionLot                                 string
	Incoterms                                     string
	TransactionTaxClassification                  string
	ProductTaxClassificationBillToCountry         string
	ProductTaxClassificationBillFromCountry       string
	DefinedTaxClassification                      string
	AccountAssignmentGroup                        string
	ProductAccountAssignmentGroup                 string
	PaymentTerms                                  string
	DueCalculationBaseDate                        string
	PaymentDueDate                                string
	NetPaymentDays                                string
	PaymentMethod                                 string
	Contract                                      string
	ContractItem                                  string
	Project                                       string
	WBSElement                                    string
	AccountingExchangeRate                        string
	ReferenceDocument                             string
	ReferenceDocumentItem                         string
	ItemCompleteDeliveryIsDefined                 string
	ItemDeliveryStatus                            string
	IssuingStatus                                 string
	ReceivingStatus                               string
	ItemBillingStatus                             string
	TaxCode                                       string
	TaxRate                                       string
	CountryOfOrigin                               string
	CountryOfOriginLanguage                       string
	Equipment                                     string
	FreightAgreement                              string
	FreightAgreementItem                          string
	ItemBlockStatus                               string
	ItemDeliveryBlockStatus                       string
	ItemBillingBlockStatus                        string
	ExternalReferenceDocument                     string
	ExternalReferenceDocumentItem                 string
	CreationDate                                  string
	CreationTime                                  string
	LastChangeDate                                string
	LastChangeTime                                string
	IsCancelled                                   string
	IsMarkedForDeletion                           string
}{
	OrderID:                                       "data_platform_orders_item_data.OrderID",
	OrderItem:                                     "data_platform_orders_item_data.OrderItem",
	OrderItemCategory:                             "data_platform_orders_item_data.OrderItemCategory",
	OrderStatus:                                   "data_platform_orders_item_data.OrderStatus",
	SupplyChainRelationshipID:                     "data_platform_orders_item_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:             "data_platform_orders_item_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:        "data_platform_orders_item_data.SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipStockConfPlantID:       "data_platform_orders_item_data.SupplyChainRelationshipStockConfPlantID",
	SupplyChainRelationshipProductionPlantID:      "data_platform_orders_item_data.SupplyChainRelationshipProductionPlantID",
	Buyer:                                         "data_platform_orders_item_data.Buyer",
	Seller:                                        "data_platform_orders_item_data.Seller",
	DeliverToParty:                                "data_platform_orders_item_data.DeliverToParty",
	DeliverFromParty:                              "data_platform_orders_item_data.DeliverFromParty",
	DeliverToPlant:                                "data_platform_orders_item_data.DeliverToPlant",
	DeliverFromPlant:                              "data_platform_orders_item_data.DeliverFromPlant",
	OrderItemText:                                 "data_platform_orders_item_data.OrderItemText",
	OrderItemTextByBuyer:                          "data_platform_orders_item_data.OrderItemTextByBuyer",
	OrderItemTextBySeller:                         "data_platform_orders_item_data.OrderItemTextBySeller",
	Product:                                       "data_platform_orders_item_data.Product",
	SizeOrDimensionText:                           "data_platform_orders_item_data.SizeOrDimensionText",
	ProductStandardID:                             "data_platform_orders_item_data.ProductStandardID",
	ProductGroup:                                  "data_platform_orders_item_data.ProductGroup",
	ProductSpecification:                          "data_platform_orders_item_data.ProductSpecification",
	MarkingOfMaterial:                             "data_platform_orders_item_data.MarkingOfMaterial",
	BaseUnit:                                      "data_platform_orders_item_data.BaseUnit",
	DeliveryUnit:                                  "data_platform_orders_item_data.DeliveryUnit",
	ProductionVersion:                             "data_platform_orders_item_data.ProductionVersion",
	ProductionVersionItem:                         "data_platform_orders_item_data.ProductionVersionItem",
	BillOfMaterial:                                "data_platform_orders_item_data.BillOfMaterial",
	BillOfMaterialItem:                            "data_platform_orders_item_data.BillOfMaterialItem",
	ProductionOrder:                               "data_platform_orders_item_data.ProductionOrder",
	ProductionOrderItem:                           "data_platform_orders_item_data.ProductionOrderItem",
	Operations:                                    "data_platform_orders_item_data.Operations",
	OperationsItem:                                "data_platform_orders_item_data.OperationsItem",
	OperationID:                                   "data_platform_orders_item_data.OperationID",
	PricingDate:                                   "data_platform_orders_item_data.PricingDate",
	PriceDetnExchangeRate:                         "data_platform_orders_item_data.PriceDetnExchangeRate",
	RequestedDeliveryDate:                         "data_platform_orders_item_data.RequestedDeliveryDate",
	RequestedDeliveryTime:                         "data_platform_orders_item_data.RequestedDeliveryTime",
	DeliverToPlantTimeZone:                        "data_platform_orders_item_data.DeliverToPlantTimeZone",
	DeliverToPlantStorageLocation:                 "data_platform_orders_item_data.DeliverToPlantStorageLocation",
	ProductIsBatchManagedInDeliverToPlant:         "data_platform_orders_item_data.ProductIsBatchManagedInDeliverToPlant",
	BatchMgmtPolicyInDeliverToPlant:               "data_platform_orders_item_data.BatchMgmtPolicyInDeliverToPlant",
	DeliverToPlantBatch:                           "data_platform_orders_item_data.DeliverToPlantBatch",
	DeliverToPlantBatchValidityStartDate:          "data_platform_orders_item_data.DeliverToPlantBatchValidityStartDate",
	DeliverToPlantBatchValidityStartTime:          "data_platform_orders_item_data.DeliverToPlantBatchValidityStartTime",
	DeliverToPlantBatchValidityEndDate:            "data_platform_orders_item_data.DeliverToPlantBatchValidityEndDate",
	DeliverToPlantBatchValidityEndTime:            "data_platform_orders_item_data.DeliverToPlantBatchValidityEndTime",
	DeliverFromPlantTimeZone:                      "data_platform_orders_item_data.DeliverFromPlantTimeZone",
	DeliverFromPlantStorageLocation:               "data_platform_orders_item_data.DeliverFromPlantStorageLocation",
	ProductIsBatchManagedInDeliverFromPlant:       "data_platform_orders_item_data.ProductIsBatchManagedInDeliverFromPlant",
	BatchMgmtPolicyInDeliverFromPlant:             "data_platform_orders_item_data.BatchMgmtPolicyInDeliverFromPlant",
	DeliverFromPlantBatch:                         "data_platform_orders_item_data.DeliverFromPlantBatch",
	DeliverFromPlantBatchValidityStartDate:        "data_platform_orders_item_data.DeliverFromPlantBatchValidityStartDate",
	DeliverFromPlantBatchValidityStartTime:        "data_platform_orders_item_data.DeliverFromPlantBatchValidityStartTime",
	DeliverFromPlantBatchValidityEndDate:          "data_platform_orders_item_data.DeliverFromPlantBatchValidityEndDate",
	DeliverFromPlantBatchValidityEndTime:          "data_platform_orders_item_data.DeliverFromPlantBatchValidityEndTime",
	StockConfirmationBusinessPartner:              "data_platform_orders_item_data.StockConfirmationBusinessPartner",
	StockConfirmationPlant:                        "data_platform_orders_item_data.StockConfirmationPlant",
	StockConfirmationPlantTimeZone:                "data_platform_orders_item_data.StockConfirmationPlantTimeZone",
	ProductIsBatchManagedInStockConfirmationPlant: "data_platform_orders_item_data.ProductIsBatchManagedInStockConfirmationPlant",
	BatchMgmtPolicyInStockConfirmationPlant:       "data_platform_orders_item_data.BatchMgmtPolicyInStockConfirmationPlant",
	StockConfirmationPlantBatch:                   "data_platform_orders_item_data.StockConfirmationPlantBatch",
	StockConfirmationPlantBatchValidityStartDate:  "data_platform_orders_item_data.StockConfirmationPlantBatchValidityStartDate",
	StockConfirmationPlantBatchValidityStartTime:  "data_platform_orders_item_data.StockConfirmationPlantBatchValidityStartTime",
	StockConfirmationPlantBatchValidityEndDate:    "data_platform_orders_item_data.StockConfirmationPlantBatchValidityEndDate",
	StockConfirmationPlantBatchValidityEndTime:    "data_platform_orders_item_data.StockConfirmationPlantBatchValidityEndTime",
	ServicesRenderingDate:                         "data_platform_orders_item_data.ServicesRenderingDate",
	OrderQuantityInBaseUnit:                       "data_platform_orders_item_data.OrderQuantityInBaseUnit",
	OrderQuantityInDeliveryUnit:                   "data_platform_orders_item_data.OrderQuantityInDeliveryUnit",
	QuantityPerPackage:                            "data_platform_orders_item_data.QuantityPerPackage",
	StockConfirmationPolicy:                       "data_platform_orders_item_data.StockConfirmationPolicy",
	StockConfirmationStatus:                       "data_platform_orders_item_data.StockConfirmationStatus",
	ConfirmedOrderQuantityInBaseUnit:              "data_platform_orders_item_data.ConfirmedOrderQuantityInBaseUnit",
	ProductWeightUnit:                             "data_platform_orders_item_data.ProductWeightUnit",
	ProductNetWeight:                              "data_platform_orders_item_data.ProductNetWeight",
	ItemNetWeight:                                 "data_platform_orders_item_data.ItemNetWeight",
	ProductGrossWeight:                            "data_platform_orders_item_data.ProductGrossWeight",
	ItemGrossWeight:                               "data_platform_orders_item_data.ItemGrossWeight",
	InternalCapacityQuantity:                      "data_platform_orders_item_data.InternalCapacityQuantity",
	InternalCapacityQuantityUnit:                  "data_platform_orders_item_data.InternalCapacityQuantityUnit",
	NetAmount:                                     "data_platform_orders_item_data.NetAmount",
	TaxAmount:                                     "data_platform_orders_item_data.TaxAmount",
	GrossAmount:                                   "data_platform_orders_item_data.GrossAmount",
	InvoiceDocumentDate:                           "data_platform_orders_item_data.InvoiceDocumentDate",
	ProductionPlantBusinessPartner:                "data_platform_orders_item_data.ProductionPlantBusinessPartner",
	ProductionPlant:                               "data_platform_orders_item_data.ProductionPlant",
	ProductionPlantTimeZone:                       "data_platform_orders_item_data.ProductionPlantTimeZone",
	ProductionPlantStorageLocation:                "data_platform_orders_item_data.ProductionPlantStorageLocation",
	ProductIsBatchManagedInProductionPlant:        "data_platform_orders_item_data.ProductIsBatchManagedInProductionPlant",
	BatchMgmtPolicyInProductionPlant:              "data_platform_orders_item_data.BatchMgmtPolicyInProductionPlant",
	ProductionPlantBatch:                          "data_platform_orders_item_data.ProductionPlantBatch",
	ProductionPlantBatchValidityStartDate:         "data_platform_orders_item_data.ProductionPlantBatchValidityStartDate",
	ProductionPlantBatchValidityStartTime:         "data_platform_orders_item_data.ProductionPlantBatchValidityStartTime",
	ProductionPlantBatchValidityEndDate:           "data_platform_orders_item_data.ProductionPlantBatchValidityEndDate",
	ProductionPlantBatchValidityEndTime:           "data_platform_orders_item_data.ProductionPlantBatchValidityEndTime",
	InspectionPlantBusinessPartner:                "data_platform_orders_item_data.InspectionPlantBusinessPartner",
	InspectionPlant:                               "data_platform_orders_item_data.InspectionPlant",
	InspectionPlan:                                "data_platform_orders_item_data.InspectionPlan",
	InspectionLot:                                 "data_platform_orders_item_data.InspectionLot",
	Incoterms:                                     "data_platform_orders_item_data.Incoterms",
	TransactionTaxClassification:                  "data_platform_orders_item_data.TransactionTaxClassification",
	ProductTaxClassificationBillToCountry:         "data_platform_orders_item_data.ProductTaxClassificationBillToCountry",
	ProductTaxClassificationBillFromCountry:       "data_platform_orders_item_data.ProductTaxClassificationBillFromCountry",
	DefinedTaxClassification:                      "data_platform_orders_item_data.DefinedTaxClassification",
	AccountAssignmentGroup:                        "data_platform_orders_item_data.AccountAssignmentGroup",
	ProductAccountAssignmentGroup:                 "data_platform_orders_item_data.ProductAccountAssignmentGroup",
	PaymentTerms:                                  "data_platform_orders_item_data.PaymentTerms",
	DueCalculationBaseDate:                        "data_platform_orders_item_data.DueCalculationBaseDate",
	PaymentDueDate:                                "data_platform_orders_item_data.PaymentDueDate",
	NetPaymentDays:                                "data_platform_orders_item_data.NetPaymentDays",
	PaymentMethod:                                 "data_platform_orders_item_data.PaymentMethod",
	Contract:                                      "data_platform_orders_item_data.Contract",
	ContractItem:                                  "data_platform_orders_item_data.ContractItem",
	Project:                                       "data_platform_orders_item_data.Project",
	WBSElement:                                    "data_platform_orders_item_data.WBSElement",
	AccountingExchangeRate:                        "data_platform_orders_item_data.AccountingExchangeRate",
	ReferenceDocument:                             "data_platform_orders_item_data.ReferenceDocument",
	ReferenceDocumentItem:                         "data_platform_orders_item_data.ReferenceDocumentItem",
	ItemCompleteDeliveryIsDefined:                 "data_platform_orders_item_data.ItemCompleteDeliveryIsDefined",
	ItemDeliveryStatus:                            "data_platform_orders_item_data.ItemDeliveryStatus",
	IssuingStatus:                                 "data_platform_orders_item_data.IssuingStatus",
	ReceivingStatus:                               "data_platform_orders_item_data.ReceivingStatus",
	ItemBillingStatus:                             "data_platform_orders_item_data.ItemBillingStatus",
	TaxCode:                                       "data_platform_orders_item_data.TaxCode",
	TaxRate:                                       "data_platform_orders_item_data.TaxRate",
	CountryOfOrigin:                               "data_platform_orders_item_data.CountryOfOrigin",
	CountryOfOriginLanguage:                       "data_platform_orders_item_data.CountryOfOriginLanguage",
	Equipment:                                     "data_platform_orders_item_data.Equipment",
	FreightAgreement:                              "data_platform_orders_item_data.FreightAgreement",
	FreightAgreementItem:                          "data_platform_orders_item_data.FreightAgreementItem",
	ItemBlockStatus:                               "data_platform_orders_item_data.ItemBlockStatus",
	ItemDeliveryBlockStatus:                       "data_platform_orders_item_data.ItemDeliveryBlockStatus",
	ItemBillingBlockStatus:                        "data_platform_orders_item_data.ItemBillingBlockStatus",
	ExternalReferenceDocument:                     "data_platform_orders_item_data.ExternalReferenceDocument",
	ExternalReferenceDocumentItem:                 "data_platform_orders_item_data.ExternalReferenceDocumentItem",
	CreationDate:                                  "data_platform_orders_item_data.CreationDate",
	CreationTime:                                  "data_platform_orders_item_data.CreationTime",
	LastChangeDate:                                "data_platform_orders_item_data.LastChangeDate",
	LastChangeTime:                                "data_platform_orders_item_data.LastChangeTime",
	IsCancelled:                                   "data_platform_orders_item_data.IsCancelled",
	IsMarkedForDeletion:                           "data_platform_orders_item_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformOrdersItemDatumWhere = struct {
	OrderID                                       whereHelperint
	OrderItem                                     whereHelperint
	OrderItemCategory                             whereHelperstring
	OrderStatus                                   whereHelperstring
	SupplyChainRelationshipID                     whereHelperint
	SupplyChainRelationshipDeliveryID             whereHelpernull_Int
	SupplyChainRelationshipDeliveryPlantID        whereHelpernull_Int
	SupplyChainRelationshipStockConfPlantID       whereHelpernull_Int
	SupplyChainRelationshipProductionPlantID      whereHelpernull_Int
	Buyer                                         whereHelperint
	Seller                                        whereHelperint
	DeliverToParty                                whereHelpernull_Int
	DeliverFromParty                              whereHelpernull_Int
	DeliverToPlant                                whereHelpernull_String
	DeliverFromPlant                              whereHelpernull_String
	OrderItemText                                 whereHelperstring
	OrderItemTextByBuyer                          whereHelperstring
	OrderItemTextBySeller                         whereHelperstring
	Product                                       whereHelperstring
	SizeOrDimensionText                           whereHelpernull_String
	ProductStandardID                             whereHelpernull_String
	ProductGroup                                  whereHelpernull_String
	ProductSpecification                          whereHelpernull_String
	MarkingOfMaterial                             whereHelpernull_String
	BaseUnit                                      whereHelperstring
	DeliveryUnit                                  whereHelperstring
	ProductionVersion                             whereHelpernull_Int
	ProductionVersionItem                         whereHelpernull_Int
	BillOfMaterial                                whereHelpernull_Int
	BillOfMaterialItem                            whereHelpernull_Int
	ProductionOrder                               whereHelpernull_Int
	ProductionOrderItem                           whereHelpernull_Int
	Operations                                    whereHelpernull_Int
	OperationsItem                                whereHelpernull_Int
	OperationID                                   whereHelpernull_Int
	PricingDate                                   whereHelperstring
	PriceDetnExchangeRate                         whereHelpernull_Float32
	RequestedDeliveryDate                         whereHelperstring
	RequestedDeliveryTime                         whereHelperstring
	DeliverToPlantTimeZone                        whereHelpernull_String
	DeliverToPlantStorageLocation                 whereHelpernull_String
	ProductIsBatchManagedInDeliverToPlant         whereHelpernull_Bool
	BatchMgmtPolicyInDeliverToPlant               whereHelpernull_String
	DeliverToPlantBatch                           whereHelpernull_String
	DeliverToPlantBatchValidityStartDate          whereHelpernull_String
	DeliverToPlantBatchValidityStartTime          whereHelpernull_String
	DeliverToPlantBatchValidityEndDate            whereHelpernull_String
	DeliverToPlantBatchValidityEndTime            whereHelpernull_String
	DeliverFromPlantTimeZone                      whereHelpernull_String
	DeliverFromPlantStorageLocation               whereHelpernull_String
	ProductIsBatchManagedInDeliverFromPlant       whereHelpernull_Bool
	BatchMgmtPolicyInDeliverFromPlant             whereHelpernull_String
	DeliverFromPlantBatch                         whereHelpernull_String
	DeliverFromPlantBatchValidityStartDate        whereHelpernull_String
	DeliverFromPlantBatchValidityStartTime        whereHelpernull_String
	DeliverFromPlantBatchValidityEndDate          whereHelpernull_String
	DeliverFromPlantBatchValidityEndTime          whereHelpernull_String
	StockConfirmationBusinessPartner              whereHelpernull_Int
	StockConfirmationPlant                        whereHelpernull_String
	StockConfirmationPlantTimeZone                whereHelpernull_String
	ProductIsBatchManagedInStockConfirmationPlant whereHelpernull_Bool
	BatchMgmtPolicyInStockConfirmationPlant       whereHelpernull_String
	StockConfirmationPlantBatch                   whereHelpernull_String
	StockConfirmationPlantBatchValidityStartDate  whereHelpernull_String
	StockConfirmationPlantBatchValidityStartTime  whereHelpernull_String
	StockConfirmationPlantBatchValidityEndDate    whereHelpernull_String
	StockConfirmationPlantBatchValidityEndTime    whereHelpernull_String
	ServicesRenderingDate                         whereHelpernull_String
	OrderQuantityInBaseUnit                       whereHelperfloat32
	OrderQuantityInDeliveryUnit                   whereHelperfloat32
	QuantityPerPackage                            whereHelperfloat32
	StockConfirmationPolicy                       whereHelpernull_String
	StockConfirmationStatus                       whereHelpernull_String
	ConfirmedOrderQuantityInBaseUnit              whereHelpernull_Float32
	ProductWeightUnit                             whereHelpernull_String
	ProductNetWeight                              whereHelpernull_Float32
	ItemNetWeight                                 whereHelpernull_Float32
	ProductGrossWeight                            whereHelpernull_Float32
	ItemGrossWeight                               whereHelpernull_Float32
	InternalCapacityQuantity                      whereHelpernull_Float32
	InternalCapacityQuantityUnit                  whereHelpernull_String
	NetAmount                                     whereHelperfloat32
	TaxAmount                                     whereHelperfloat32
	GrossAmount                                   whereHelperfloat32
	InvoiceDocumentDate                           whereHelpernull_String
	ProductionPlantBusinessPartner                whereHelpernull_Int
	ProductionPlant                               whereHelpernull_String
	ProductionPlantTimeZone                       whereHelpernull_String
	ProductionPlantStorageLocation                whereHelpernull_String
	ProductIsBatchManagedInProductionPlant        whereHelpernull_Bool
	BatchMgmtPolicyInProductionPlant              whereHelpernull_String
	ProductionPlantBatch                          whereHelpernull_String
	ProductionPlantBatchValidityStartDate         whereHelpernull_String
	ProductionPlantBatchValidityStartTime         whereHelpernull_String
	ProductionPlantBatchValidityEndDate           whereHelpernull_String
	ProductionPlantBatchValidityEndTime           whereHelpernull_String
	InspectionPlantBusinessPartner                whereHelpernull_Int
	InspectionPlant                               whereHelpernull_String
	InspectionPlan                                whereHelpernull_Int
	InspectionLot                                 whereHelpernull_Int
	Incoterms                                     whereHelpernull_String
	TransactionTaxClassification                  whereHelperstring
	ProductTaxClassificationBillToCountry         whereHelperstring
	ProductTaxClassificationBillFromCountry       whereHelperstring
	DefinedTaxClassification                      whereHelperstring
	AccountAssignmentGroup                        whereHelperstring
	ProductAccountAssignmentGroup                 whereHelperstring
	PaymentTerms                                  whereHelperstring
	DueCalculationBaseDate                        whereHelpernull_String
	PaymentDueDate                                whereHelpernull_String
	NetPaymentDays                                whereHelpernull_Int
	PaymentMethod                                 whereHelperstring
	Contract                                      whereHelpernull_Int
	ContractItem                                  whereHelpernull_Int
	Project                                       whereHelpernull_Int
	WBSElement                                    whereHelpernull_Int
	AccountingExchangeRate                        whereHelpernull_Float32
	ReferenceDocument                             whereHelpernull_Int
	ReferenceDocumentItem                         whereHelpernull_Int
	ItemCompleteDeliveryIsDefined                 whereHelpernull_Bool
	ItemDeliveryStatus                            whereHelpernull_String
	IssuingStatus                                 whereHelpernull_String
	ReceivingStatus                               whereHelpernull_String
	ItemBillingStatus                             whereHelpernull_String
	TaxCode                                       whereHelpernull_String
	TaxRate                                       whereHelpernull_Float32
	CountryOfOrigin                               whereHelpernull_String
	CountryOfOriginLanguage                       whereHelpernull_String
	Equipment                                     whereHelpernull_Int
	FreightAgreement                              whereHelpernull_Int
	FreightAgreementItem                          whereHelpernull_Int
	ItemBlockStatus                               whereHelpernull_Bool
	ItemDeliveryBlockStatus                       whereHelpernull_Bool
	ItemBillingBlockStatus                        whereHelpernull_Bool
	ExternalReferenceDocument                     whereHelpernull_String
	ExternalReferenceDocumentItem                 whereHelpernull_String
	CreationDate                                  whereHelperstring
	CreationTime                                  whereHelperstring
	LastChangeDate                                whereHelperstring
	LastChangeTime                                whereHelperstring
	IsCancelled                                   whereHelpernull_Bool
	IsMarkedForDeletion                           whereHelpernull_Bool
}{
	OrderID:                                       whereHelperint{field: "`data_platform_orders_item_data`.`OrderID`"},
	OrderItem:                                     whereHelperint{field: "`data_platform_orders_item_data`.`OrderItem`"},
	OrderItemCategory:                             whereHelperstring{field: "`data_platform_orders_item_data`.`OrderItemCategory`"},
	OrderStatus:                                   whereHelperstring{field: "`data_platform_orders_item_data`.`OrderStatus`"},
	SupplyChainRelationshipID:                     whereHelperint{field: "`data_platform_orders_item_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:             whereHelpernull_Int{field: "`data_platform_orders_item_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID:        whereHelpernull_Int{field: "`data_platform_orders_item_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	SupplyChainRelationshipStockConfPlantID:       whereHelpernull_Int{field: "`data_platform_orders_item_data`.`SupplyChainRelationshipStockConfPlantID`"},
	SupplyChainRelationshipProductionPlantID:      whereHelpernull_Int{field: "`data_platform_orders_item_data`.`SupplyChainRelationshipProductionPlantID`"},
	Buyer:                                         whereHelperint{field: "`data_platform_orders_item_data`.`Buyer`"},
	Seller:                                        whereHelperint{field: "`data_platform_orders_item_data`.`Seller`"},
	DeliverToParty:                                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`DeliverToParty`"},
	DeliverFromParty:                              whereHelpernull_Int{field: "`data_platform_orders_item_data`.`DeliverFromParty`"},
	DeliverToPlant:                                whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlant`"},
	DeliverFromPlant:                              whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlant`"},
	OrderItemText:                                 whereHelperstring{field: "`data_platform_orders_item_data`.`OrderItemText`"},
	OrderItemTextByBuyer:                          whereHelperstring{field: "`data_platform_orders_item_data`.`OrderItemTextByBuyer`"},
	OrderItemTextBySeller:                         whereHelperstring{field: "`data_platform_orders_item_data`.`OrderItemTextBySeller`"},
	Product:                                       whereHelperstring{field: "`data_platform_orders_item_data`.`Product`"},
	SizeOrDimensionText:                           whereHelpernull_String{field: "`data_platform_orders_item_data`.`SizeOrDimensionText`"},
	ProductStandardID:                             whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductStandardID`"},
	ProductGroup:                                  whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductGroup`"},
	ProductSpecification:                          whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductSpecification`"},
	MarkingOfMaterial:                             whereHelpernull_String{field: "`data_platform_orders_item_data`.`MarkingOfMaterial`"},
	BaseUnit:                                      whereHelperstring{field: "`data_platform_orders_item_data`.`BaseUnit`"},
	DeliveryUnit:                                  whereHelperstring{field: "`data_platform_orders_item_data`.`DeliveryUnit`"},
	ProductionVersion:                             whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ProductionVersion`"},
	ProductionVersionItem:                         whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ProductionVersionItem`"},
	BillOfMaterial:                                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`BillOfMaterial`"},
	BillOfMaterialItem:                            whereHelpernull_Int{field: "`data_platform_orders_item_data`.`BillOfMaterialItem`"},
	ProductionOrder:                               whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ProductionOrder`"},
	ProductionOrderItem:                           whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ProductionOrderItem`"},
	Operations:                                    whereHelpernull_Int{field: "`data_platform_orders_item_data`.`Operations`"},
	OperationsItem:                                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`OperationsItem`"},
	OperationID:                                   whereHelpernull_Int{field: "`data_platform_orders_item_data`.`OperationID`"},
	PricingDate:                                   whereHelperstring{field: "`data_platform_orders_item_data`.`PricingDate`"},
	PriceDetnExchangeRate:                         whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`PriceDetnExchangeRate`"},
	RequestedDeliveryDate:                         whereHelperstring{field: "`data_platform_orders_item_data`.`RequestedDeliveryDate`"},
	RequestedDeliveryTime:                         whereHelperstring{field: "`data_platform_orders_item_data`.`RequestedDeliveryTime`"},
	DeliverToPlantTimeZone:                        whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantTimeZone`"},
	DeliverToPlantStorageLocation:                 whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantStorageLocation`"},
	ProductIsBatchManagedInDeliverToPlant:         whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ProductIsBatchManagedInDeliverToPlant`"},
	BatchMgmtPolicyInDeliverToPlant:               whereHelpernull_String{field: "`data_platform_orders_item_data`.`BatchMgmtPolicyInDeliverToPlant`"},
	DeliverToPlantBatch:                           whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantBatch`"},
	DeliverToPlantBatchValidityStartDate:          whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantBatchValidityStartDate`"},
	DeliverToPlantBatchValidityStartTime:          whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantBatchValidityStartTime`"},
	DeliverToPlantBatchValidityEndDate:            whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantBatchValidityEndDate`"},
	DeliverToPlantBatchValidityEndTime:            whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverToPlantBatchValidityEndTime`"},
	DeliverFromPlantTimeZone:                      whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantTimeZone`"},
	DeliverFromPlantStorageLocation:               whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantStorageLocation`"},
	ProductIsBatchManagedInDeliverFromPlant:       whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ProductIsBatchManagedInDeliverFromPlant`"},
	BatchMgmtPolicyInDeliverFromPlant:             whereHelpernull_String{field: "`data_platform_orders_item_data`.`BatchMgmtPolicyInDeliverFromPlant`"},
	DeliverFromPlantBatch:                         whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantBatch`"},
	DeliverFromPlantBatchValidityStartDate:        whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantBatchValidityStartDate`"},
	DeliverFromPlantBatchValidityStartTime:        whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantBatchValidityStartTime`"},
	DeliverFromPlantBatchValidityEndDate:          whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantBatchValidityEndDate`"},
	DeliverFromPlantBatchValidityEndTime:          whereHelpernull_String{field: "`data_platform_orders_item_data`.`DeliverFromPlantBatchValidityEndTime`"},
	StockConfirmationBusinessPartner:              whereHelpernull_Int{field: "`data_platform_orders_item_data`.`StockConfirmationBusinessPartner`"},
	StockConfirmationPlant:                        whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlant`"},
	StockConfirmationPlantTimeZone:                whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlantTimeZone`"},
	ProductIsBatchManagedInStockConfirmationPlant: whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ProductIsBatchManagedInStockConfirmationPlant`"},
	BatchMgmtPolicyInStockConfirmationPlant:       whereHelpernull_String{field: "`data_platform_orders_item_data`.`BatchMgmtPolicyInStockConfirmationPlant`"},
	StockConfirmationPlantBatch:                   whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlantBatch`"},
	StockConfirmationPlantBatchValidityStartDate:  whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlantBatchValidityStartDate`"},
	StockConfirmationPlantBatchValidityStartTime:  whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlantBatchValidityStartTime`"},
	StockConfirmationPlantBatchValidityEndDate:    whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlantBatchValidityEndDate`"},
	StockConfirmationPlantBatchValidityEndTime:    whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPlantBatchValidityEndTime`"},
	ServicesRenderingDate:                         whereHelpernull_String{field: "`data_platform_orders_item_data`.`ServicesRenderingDate`"},
	OrderQuantityInBaseUnit:                       whereHelperfloat32{field: "`data_platform_orders_item_data`.`OrderQuantityInBaseUnit`"},
	OrderQuantityInDeliveryUnit:                   whereHelperfloat32{field: "`data_platform_orders_item_data`.`OrderQuantityInDeliveryUnit`"},
	QuantityPerPackage:                            whereHelperfloat32{field: "`data_platform_orders_item_data`.`QuantityPerPackage`"},
	StockConfirmationPolicy:                       whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationPolicy`"},
	StockConfirmationStatus:                       whereHelpernull_String{field: "`data_platform_orders_item_data`.`StockConfirmationStatus`"},
	ConfirmedOrderQuantityInBaseUnit:              whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`ConfirmedOrderQuantityInBaseUnit`"},
	ProductWeightUnit:                             whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductWeightUnit`"},
	ProductNetWeight:                              whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`ProductNetWeight`"},
	ItemNetWeight:                                 whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`ItemNetWeight`"},
	ProductGrossWeight:                            whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`ProductGrossWeight`"},
	ItemGrossWeight:                               whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`ItemGrossWeight`"},
	InternalCapacityQuantity:                      whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`InternalCapacityQuantity`"},
	InternalCapacityQuantityUnit:                  whereHelpernull_String{field: "`data_platform_orders_item_data`.`InternalCapacityQuantityUnit`"},
	NetAmount:                                     whereHelperfloat32{field: "`data_platform_orders_item_data`.`NetAmount`"},
	TaxAmount:                                     whereHelperfloat32{field: "`data_platform_orders_item_data`.`TaxAmount`"},
	GrossAmount:                                   whereHelperfloat32{field: "`data_platform_orders_item_data`.`GrossAmount`"},
	InvoiceDocumentDate:                           whereHelpernull_String{field: "`data_platform_orders_item_data`.`InvoiceDocumentDate`"},
	ProductionPlantBusinessPartner:                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ProductionPlantBusinessPartner`"},
	ProductionPlant:                               whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlant`"},
	ProductionPlantTimeZone:                       whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantTimeZone`"},
	ProductionPlantStorageLocation:                whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantStorageLocation`"},
	ProductIsBatchManagedInProductionPlant:        whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ProductIsBatchManagedInProductionPlant`"},
	BatchMgmtPolicyInProductionPlant:              whereHelpernull_String{field: "`data_platform_orders_item_data`.`BatchMgmtPolicyInProductionPlant`"},
	ProductionPlantBatch:                          whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantBatch`"},
	ProductionPlantBatchValidityStartDate:         whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantBatchValidityStartDate`"},
	ProductionPlantBatchValidityStartTime:         whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantBatchValidityStartTime`"},
	ProductionPlantBatchValidityEndDate:           whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantBatchValidityEndDate`"},
	ProductionPlantBatchValidityEndTime:           whereHelpernull_String{field: "`data_platform_orders_item_data`.`ProductionPlantBatchValidityEndTime`"},
	InspectionPlantBusinessPartner:                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`InspectionPlantBusinessPartner`"},
	InspectionPlant:                               whereHelpernull_String{field: "`data_platform_orders_item_data`.`InspectionPlant`"},
	InspectionPlan:                                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`InspectionPlan`"},
	InspectionLot:                                 whereHelpernull_Int{field: "`data_platform_orders_item_data`.`InspectionLot`"},
	Incoterms:                                     whereHelpernull_String{field: "`data_platform_orders_item_data`.`Incoterms`"},
	TransactionTaxClassification:                  whereHelperstring{field: "`data_platform_orders_item_data`.`TransactionTaxClassification`"},
	ProductTaxClassificationBillToCountry:         whereHelperstring{field: "`data_platform_orders_item_data`.`ProductTaxClassificationBillToCountry`"},
	ProductTaxClassificationBillFromCountry:       whereHelperstring{field: "`data_platform_orders_item_data`.`ProductTaxClassificationBillFromCountry`"},
	DefinedTaxClassification:                      whereHelperstring{field: "`data_platform_orders_item_data`.`DefinedTaxClassification`"},
	AccountAssignmentGroup:                        whereHelperstring{field: "`data_platform_orders_item_data`.`AccountAssignmentGroup`"},
	ProductAccountAssignmentGroup:                 whereHelperstring{field: "`data_platform_orders_item_data`.`ProductAccountAssignmentGroup`"},
	PaymentTerms:                                  whereHelperstring{field: "`data_platform_orders_item_data`.`PaymentTerms`"},
	DueCalculationBaseDate:                        whereHelpernull_String{field: "`data_platform_orders_item_data`.`DueCalculationBaseDate`"},
	PaymentDueDate:                                whereHelpernull_String{field: "`data_platform_orders_item_data`.`PaymentDueDate`"},
	NetPaymentDays:                                whereHelpernull_Int{field: "`data_platform_orders_item_data`.`NetPaymentDays`"},
	PaymentMethod:                                 whereHelperstring{field: "`data_platform_orders_item_data`.`PaymentMethod`"},
	Contract:                                      whereHelpernull_Int{field: "`data_platform_orders_item_data`.`Contract`"},
	ContractItem:                                  whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ContractItem`"},
	Project:                                       whereHelpernull_Int{field: "`data_platform_orders_item_data`.`Project`"},
	WBSElement:                                    whereHelpernull_Int{field: "`data_platform_orders_item_data`.`WBSElement`"},
	AccountingExchangeRate:                        whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`AccountingExchangeRate`"},
	ReferenceDocument:                             whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ReferenceDocument`"},
	ReferenceDocumentItem:                         whereHelpernull_Int{field: "`data_platform_orders_item_data`.`ReferenceDocumentItem`"},
	ItemCompleteDeliveryIsDefined:                 whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ItemCompleteDeliveryIsDefined`"},
	ItemDeliveryStatus:                            whereHelpernull_String{field: "`data_platform_orders_item_data`.`ItemDeliveryStatus`"},
	IssuingStatus:                                 whereHelpernull_String{field: "`data_platform_orders_item_data`.`IssuingStatus`"},
	ReceivingStatus:                               whereHelpernull_String{field: "`data_platform_orders_item_data`.`ReceivingStatus`"},
	ItemBillingStatus:                             whereHelpernull_String{field: "`data_platform_orders_item_data`.`ItemBillingStatus`"},
	TaxCode:                                       whereHelpernull_String{field: "`data_platform_orders_item_data`.`TaxCode`"},
	TaxRate:                                       whereHelpernull_Float32{field: "`data_platform_orders_item_data`.`TaxRate`"},
	CountryOfOrigin:                               whereHelpernull_String{field: "`data_platform_orders_item_data`.`CountryOfOrigin`"},
	CountryOfOriginLanguage:                       whereHelpernull_String{field: "`data_platform_orders_item_data`.`CountryOfOriginLanguage`"},
	Equipment:                                     whereHelpernull_Int{field: "`data_platform_orders_item_data`.`Equipment`"},
	FreightAgreement:                              whereHelpernull_Int{field: "`data_platform_orders_item_data`.`FreightAgreement`"},
	FreightAgreementItem:                          whereHelpernull_Int{field: "`data_platform_orders_item_data`.`FreightAgreementItem`"},
	ItemBlockStatus:                               whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ItemBlockStatus`"},
	ItemDeliveryBlockStatus:                       whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ItemDeliveryBlockStatus`"},
	ItemBillingBlockStatus:                        whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`ItemBillingBlockStatus`"},
	ExternalReferenceDocument:                     whereHelpernull_String{field: "`data_platform_orders_item_data`.`ExternalReferenceDocument`"},
	ExternalReferenceDocumentItem:                 whereHelpernull_String{field: "`data_platform_orders_item_data`.`ExternalReferenceDocumentItem`"},
	CreationDate:                                  whereHelperstring{field: "`data_platform_orders_item_data`.`CreationDate`"},
	CreationTime:                                  whereHelperstring{field: "`data_platform_orders_item_data`.`CreationTime`"},
	LastChangeDate:                                whereHelperstring{field: "`data_platform_orders_item_data`.`LastChangeDate`"},
	LastChangeTime:                                whereHelperstring{field: "`data_platform_orders_item_data`.`LastChangeTime`"},
	IsCancelled:                                   whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`IsCancelled`"},
	IsMarkedForDeletion:                           whereHelpernull_Bool{field: "`data_platform_orders_item_data`.`IsMarkedForDeletion`"},
}

// DataPlatformOrdersItemDatumRels is where relationship names are stored.
var DataPlatformOrdersItemDatumRels = struct {
	BaseUnitDataPlatformQuantityUnitQuantityUnitDatum                     string
	BillOfMaterialDataPlatformBillOfMaterialItemDatum                     string
	BillOfMaterialDataPlatformBillOfMaterialHeaderDatum                   string
	ContractDataPlatformContractItemDatum                                 string
	ContractDataPlatformContractHeaderDatum                               string
	CountryOfOriginLanguageDataPlatformLanguageLanguageDatum              string
	CountryOfOriginDataPlatformCountryCountryDatum                        string
	DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum               string
	DeliverFromPartyDataPlatformPlantStorageLocationDatum                 string
	DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum             string
	DeliverToPartyDataPlatformBatchMasterRecordBatchDatum                 string
	DeliverToPartyDataPlatformPlantStorageLocationDatum                   string
	DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum               string
	DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum                 string
	EquipmentDataPlatformEquipmentMasterGeneralDatum                      string
	Incoterm                                                              string
	InspectionLotDataPlatformInspectionLotHeaderDatum                     string
	InspectionPlantDataPlatformPlantGeneralDatum                          string
	InspectionPlanDataPlatformInspectionPlanHeaderDatum                   string
	InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum string
	PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum              string
	ProductGroupDataPlatformProductGroupProductGroupDatum                 string
	OperationIDDataPlatformProductionOrderItemOperationDatum              string
	ProductionOrderDataPlatformProductionOrderItemDatum                   string
	ProductDataPlatformBatchMasterRecordBatchDatum                        string
	ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum              string
	ProductionVersionDataPlatformProductionVersionItemDatum               string
	ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum            string
	ProjectDataPlatformProjectProjectDatum                                string
	BuyerDataPlatformSCRDeliveryRelationDatum                             string
	BuyerDataPlatformSCRDeliveryPlantRelationDatum                        string
	BuyerDataPlatformSCRGeneralDatum                                      string
	BuyerDataPlatformSCRProductionPlantRelationDatum                      string
	BuyerDataPlatformSCRStockConfPlantRelationDatum                       string
	StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum       string
	ProjectDataPlatformProjectWBSElementDatum                             string
	OrderIDDataPlatformOrdersHeaderDatum                                  string
	OrderIDDataPlatformDeliveryDocumentHeaderData                         string
	OrderIDDataPlatformDeliveryDocumentItemData                           string
	OrderIDDataPlatformInvoiceDocumentItemData                            string
	OrderIDDataPlatformOrdersItemDocData                                  string
	OrderIDDataPlatformOrdersItemFreightAgreementData                     string
	OrderIDDataPlatformOrdersItemPricingElementData                       string
	OrderIDDataPlatformOrdersItemScheduleLineData                         string
	OrderIDDataPlatformPlannedOrderHeaderData                             string
	OrderIDDataPlatformPlannedOrderItemData                               string
	OrderIDDataPlatformProductStockProductStockByOrderData                string
	OrderIDDataPlatformProductionOrderHeaderData                          string
	OrderIDDataPlatformProductionOrderItemData                            string
	PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData             string
	FollowingOrderIDDataPlatformPurchaseRequisitionItemData               string
	PrecedingOrderIDDataPlatformPurchaseRequisitionItemData               string
}{
	BaseUnitDataPlatformQuantityUnitQuantityUnitDatum:         "BaseUnitDataPlatformQuantityUnitQuantityUnitDatum",
	BillOfMaterialDataPlatformBillOfMaterialItemDatum:         "BillOfMaterialDataPlatformBillOfMaterialItemDatum",
	BillOfMaterialDataPlatformBillOfMaterialHeaderDatum:       "BillOfMaterialDataPlatformBillOfMaterialHeaderDatum",
	ContractDataPlatformContractItemDatum:                     "ContractDataPlatformContractItemDatum",
	ContractDataPlatformContractHeaderDatum:                   "ContractDataPlatformContractHeaderDatum",
	CountryOfOriginLanguageDataPlatformLanguageLanguageDatum:  "CountryOfOriginLanguageDataPlatformLanguageLanguageDatum",
	CountryOfOriginDataPlatformCountryCountryDatum:            "CountryOfOriginDataPlatformCountryCountryDatum",
	DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum:   "DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum",
	DeliverFromPartyDataPlatformPlantStorageLocationDatum:     "DeliverFromPartyDataPlatformPlantStorageLocationDatum",
	DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: "DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum",
	DeliverToPartyDataPlatformBatchMasterRecordBatchDatum:     "DeliverToPartyDataPlatformBatchMasterRecordBatchDatum",
	DeliverToPartyDataPlatformPlantStorageLocationDatum:       "DeliverToPartyDataPlatformPlantStorageLocationDatum",
	DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum:   "DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum",
	DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum:     "DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum",
	EquipmentDataPlatformEquipmentMasterGeneralDatum:          "EquipmentDataPlatformEquipmentMasterGeneralDatum",
	Incoterm: "Incoterm",
	InspectionLotDataPlatformInspectionLotHeaderDatum:                     "InspectionLotDataPlatformInspectionLotHeaderDatum",
	InspectionPlantDataPlatformPlantGeneralDatum:                          "InspectionPlantDataPlatformPlantGeneralDatum",
	InspectionPlanDataPlatformInspectionPlanHeaderDatum:                   "InspectionPlanDataPlatformInspectionPlanHeaderDatum",
	InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum: "InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum",
	PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum:              "PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum",
	ProductGroupDataPlatformProductGroupProductGroupDatum:                 "ProductGroupDataPlatformProductGroupProductGroupDatum",
	OperationIDDataPlatformProductionOrderItemOperationDatum:              "OperationIDDataPlatformProductionOrderItemOperationDatum",
	ProductionOrderDataPlatformProductionOrderItemDatum:                   "ProductionOrderDataPlatformProductionOrderItemDatum",
	ProductDataPlatformBatchMasterRecordBatchDatum:                        "ProductDataPlatformBatchMasterRecordBatchDatum",
	ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum:              "ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum",
	ProductionVersionDataPlatformProductionVersionItemDatum:               "ProductionVersionDataPlatformProductionVersionItemDatum",
	ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum:            "ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum",
	ProjectDataPlatformProjectProjectDatum:                                "ProjectDataPlatformProjectProjectDatum",
	BuyerDataPlatformSCRDeliveryRelationDatum:                             "BuyerDataPlatformSCRDeliveryRelationDatum",
	BuyerDataPlatformSCRDeliveryPlantRelationDatum:                        "BuyerDataPlatformSCRDeliveryPlantRelationDatum",
	BuyerDataPlatformSCRGeneralDatum:                                      "BuyerDataPlatformSCRGeneralDatum",
	BuyerDataPlatformSCRProductionPlantRelationDatum:                      "BuyerDataPlatformSCRProductionPlantRelationDatum",
	BuyerDataPlatformSCRStockConfPlantRelationDatum:                       "BuyerDataPlatformSCRStockConfPlantRelationDatum",
	StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum:       "StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum",
	ProjectDataPlatformProjectWBSElementDatum:                             "ProjectDataPlatformProjectWBSElementDatum",
	OrderIDDataPlatformOrdersHeaderDatum:                                  "OrderIDDataPlatformOrdersHeaderDatum",
	OrderIDDataPlatformDeliveryDocumentHeaderData:                         "OrderIDDataPlatformDeliveryDocumentHeaderData",
	OrderIDDataPlatformDeliveryDocumentItemData:                           "OrderIDDataPlatformDeliveryDocumentItemData",
	OrderIDDataPlatformInvoiceDocumentItemData:                            "OrderIDDataPlatformInvoiceDocumentItemData",
	OrderIDDataPlatformOrdersItemDocData:                                  "OrderIDDataPlatformOrdersItemDocData",
	OrderIDDataPlatformOrdersItemFreightAgreementData:                     "OrderIDDataPlatformOrdersItemFreightAgreementData",
	OrderIDDataPlatformOrdersItemPricingElementData:                       "OrderIDDataPlatformOrdersItemPricingElementData",
	OrderIDDataPlatformOrdersItemScheduleLineData:                         "OrderIDDataPlatformOrdersItemScheduleLineData",
	OrderIDDataPlatformPlannedOrderHeaderData:                             "OrderIDDataPlatformPlannedOrderHeaderData",
	OrderIDDataPlatformPlannedOrderItemData:                               "OrderIDDataPlatformPlannedOrderItemData",
	OrderIDDataPlatformProductStockProductStockByOrderData:                "OrderIDDataPlatformProductStockProductStockByOrderData",
	OrderIDDataPlatformProductionOrderHeaderData:                          "OrderIDDataPlatformProductionOrderHeaderData",
	OrderIDDataPlatformProductionOrderItemData:                            "OrderIDDataPlatformProductionOrderItemData",
	PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData:             "PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData",
	FollowingOrderIDDataPlatformPurchaseRequisitionItemData:               "FollowingOrderIDDataPlatformPurchaseRequisitionItemData",
	PrecedingOrderIDDataPlatformPurchaseRequisitionItemData:               "PrecedingOrderIDDataPlatformPurchaseRequisitionItemData",
}

// dataPlatformOrdersItemDatumR is where relationships are stored.
type dataPlatformOrdersItemDatumR struct {
	BaseUnitDataPlatformQuantityUnitQuantityUnitDatum                     *DataPlatformQuantityUnitQuantityUnitDatum            `boil:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	BillOfMaterialDataPlatformBillOfMaterialItemDatum                     *DataPlatformBillOfMaterialItemDatum                  `boil:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" json:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" toml:"BillOfMaterialDataPlatformBillOfMaterialItemDatum" yaml:"BillOfMaterialDataPlatformBillOfMaterialItemDatum"`
	BillOfMaterialDataPlatformBillOfMaterialHeaderDatum                   *DataPlatformBillOfMaterialHeaderDatum                `boil:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum" json:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum" toml:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum" yaml:"BillOfMaterialDataPlatformBillOfMaterialHeaderDatum"`
	ContractDataPlatformContractItemDatum                                 *DataPlatformContractItemDatum                        `boil:"ContractDataPlatformContractItemDatum" json:"ContractDataPlatformContractItemDatum" toml:"ContractDataPlatformContractItemDatum" yaml:"ContractDataPlatformContractItemDatum"`
	ContractDataPlatformContractHeaderDatum                               *DataPlatformContractHeaderDatum                      `boil:"ContractDataPlatformContractHeaderDatum" json:"ContractDataPlatformContractHeaderDatum" toml:"ContractDataPlatformContractHeaderDatum" yaml:"ContractDataPlatformContractHeaderDatum"`
	CountryOfOriginLanguageDataPlatformLanguageLanguageDatum              *DataPlatformLanguageLanguageDatum                    `boil:"CountryOfOriginLanguageDataPlatformLanguageLanguageDatum" json:"CountryOfOriginLanguageDataPlatformLanguageLanguageDatum" toml:"CountryOfOriginLanguageDataPlatformLanguageLanguageDatum" yaml:"CountryOfOriginLanguageDataPlatformLanguageLanguageDatum"`
	CountryOfOriginDataPlatformCountryCountryDatum                        *DataPlatformCountryCountryDatum                      `boil:"CountryOfOriginDataPlatformCountryCountryDatum" json:"CountryOfOriginDataPlatformCountryCountryDatum" toml:"CountryOfOriginDataPlatformCountryCountryDatum" yaml:"CountryOfOriginDataPlatformCountryCountryDatum"`
	DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum               *DataPlatformBatchMasterRecordBatchDatum              `boil:"DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum" json:"DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum" toml:"DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum" yaml:"DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum"`
	DeliverFromPartyDataPlatformPlantStorageLocationDatum                 *DataPlatformPlantStorageLocationDatum                `boil:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" json:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" toml:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" yaml:"DeliverFromPartyDataPlatformPlantStorageLocationDatum"`
	DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum             *DataPlatformTimeZoneTimeZoneDatum                    `boil:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" json:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" toml:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" yaml:"DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum"`
	DeliverToPartyDataPlatformBatchMasterRecordBatchDatum                 *DataPlatformBatchMasterRecordBatchDatum              `boil:"DeliverToPartyDataPlatformBatchMasterRecordBatchDatum" json:"DeliverToPartyDataPlatformBatchMasterRecordBatchDatum" toml:"DeliverToPartyDataPlatformBatchMasterRecordBatchDatum" yaml:"DeliverToPartyDataPlatformBatchMasterRecordBatchDatum"`
	DeliverToPartyDataPlatformPlantStorageLocationDatum                   *DataPlatformPlantStorageLocationDatum                `boil:"DeliverToPartyDataPlatformPlantStorageLocationDatum" json:"DeliverToPartyDataPlatformPlantStorageLocationDatum" toml:"DeliverToPartyDataPlatformPlantStorageLocationDatum" yaml:"DeliverToPartyDataPlatformPlantStorageLocationDatum"`
	DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum               *DataPlatformTimeZoneTimeZoneDatum                    `boil:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" json:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" toml:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" yaml:"DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum"`
	DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum                 *DataPlatformQuantityUnitQuantityUnitDatum            `boil:"DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	EquipmentDataPlatformEquipmentMasterGeneralDatum                      *DataPlatformEquipmentMasterGeneralDatum              `boil:"EquipmentDataPlatformEquipmentMasterGeneralDatum" json:"EquipmentDataPlatformEquipmentMasterGeneralDatum" toml:"EquipmentDataPlatformEquipmentMasterGeneralDatum" yaml:"EquipmentDataPlatformEquipmentMasterGeneralDatum"`
	Incoterm                                                              *DataPlatformIncotermsIncotermsDatum                  `boil:"Incoterm" json:"Incoterm" toml:"Incoterm" yaml:"Incoterm"`
	InspectionLotDataPlatformInspectionLotHeaderDatum                     *DataPlatformInspectionLotHeaderDatum                 `boil:"InspectionLotDataPlatformInspectionLotHeaderDatum" json:"InspectionLotDataPlatformInspectionLotHeaderDatum" toml:"InspectionLotDataPlatformInspectionLotHeaderDatum" yaml:"InspectionLotDataPlatformInspectionLotHeaderDatum"`
	InspectionPlantDataPlatformPlantGeneralDatum                          *DataPlatformPlantGeneralDatum                        `boil:"InspectionPlantDataPlatformPlantGeneralDatum" json:"InspectionPlantDataPlatformPlantGeneralDatum" toml:"InspectionPlantDataPlatformPlantGeneralDatum" yaml:"InspectionPlantDataPlatformPlantGeneralDatum"`
	InspectionPlanDataPlatformInspectionPlanHeaderDatum                   *DataPlatformInspectionPlanHeaderDatum                `boil:"InspectionPlanDataPlatformInspectionPlanHeaderDatum" json:"InspectionPlanDataPlatformInspectionPlanHeaderDatum" toml:"InspectionPlanDataPlatformInspectionPlanHeaderDatum" yaml:"InspectionPlanDataPlatformInspectionPlanHeaderDatum"`
	InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum            `boil:"InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum              *DataPlatformPaymentMethodPaymentMethodDatum          `boil:"PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum" json:"PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum" toml:"PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum" yaml:"PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum"`
	ProductGroupDataPlatformProductGroupProductGroupDatum                 *DataPlatformProductGroupProductGroupDatum            `boil:"ProductGroupDataPlatformProductGroupProductGroupDatum" json:"ProductGroupDataPlatformProductGroupProductGroupDatum" toml:"ProductGroupDataPlatformProductGroupProductGroupDatum" yaml:"ProductGroupDataPlatformProductGroupProductGroupDatum"`
	OperationIDDataPlatformProductionOrderItemOperationDatum              *DataPlatformProductionOrderItemOperationDatum        `boil:"OperationIDDataPlatformProductionOrderItemOperationDatum" json:"OperationIDDataPlatformProductionOrderItemOperationDatum" toml:"OperationIDDataPlatformProductionOrderItemOperationDatum" yaml:"OperationIDDataPlatformProductionOrderItemOperationDatum"`
	ProductionOrderDataPlatformProductionOrderItemDatum                   *DataPlatformProductionOrderItemDatum                 `boil:"ProductionOrderDataPlatformProductionOrderItemDatum" json:"ProductionOrderDataPlatformProductionOrderItemDatum" toml:"ProductionOrderDataPlatformProductionOrderItemDatum" yaml:"ProductionOrderDataPlatformProductionOrderItemDatum"`
	ProductDataPlatformBatchMasterRecordBatchDatum                        *DataPlatformBatchMasterRecordBatchDatum              `boil:"ProductDataPlatformBatchMasterRecordBatchDatum" json:"ProductDataPlatformBatchMasterRecordBatchDatum" toml:"ProductDataPlatformBatchMasterRecordBatchDatum" yaml:"ProductDataPlatformBatchMasterRecordBatchDatum"`
	ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum              *DataPlatformTimeZoneTimeZoneDatum                    `boil:"ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" json:"ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" toml:"ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" yaml:"ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum"`
	ProductionVersionDataPlatformProductionVersionItemDatum               *DataPlatformProductionVersionItemDatum               `boil:"ProductionVersionDataPlatformProductionVersionItemDatum" json:"ProductionVersionDataPlatformProductionVersionItemDatum" toml:"ProductionVersionDataPlatformProductionVersionItemDatum" yaml:"ProductionVersionDataPlatformProductionVersionItemDatum"`
	ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum            *DataPlatformQuantityUnitQuantityUnitDatum            `boil:"ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	ProjectDataPlatformProjectProjectDatum                                *DataPlatformProjectProjectDatum                      `boil:"ProjectDataPlatformProjectProjectDatum" json:"ProjectDataPlatformProjectProjectDatum" toml:"ProjectDataPlatformProjectProjectDatum" yaml:"ProjectDataPlatformProjectProjectDatum"`
	BuyerDataPlatformSCRDeliveryRelationDatum                             *DataPlatformSCRDeliveryRelationDatum                 `boil:"BuyerDataPlatformSCRDeliveryRelationDatum" json:"BuyerDataPlatformSCRDeliveryRelationDatum" toml:"BuyerDataPlatformSCRDeliveryRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryRelationDatum"`
	BuyerDataPlatformSCRDeliveryPlantRelationDatum                        *DataPlatformSCRDeliveryPlantRelationDatum            `boil:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" json:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" toml:"BuyerDataPlatformSCRDeliveryPlantRelationDatum" yaml:"BuyerDataPlatformSCRDeliveryPlantRelationDatum"`
	BuyerDataPlatformSCRGeneralDatum                                      *DataPlatformSCRGeneralDatum                          `boil:"BuyerDataPlatformSCRGeneralDatum" json:"BuyerDataPlatformSCRGeneralDatum" toml:"BuyerDataPlatformSCRGeneralDatum" yaml:"BuyerDataPlatformSCRGeneralDatum"`
	BuyerDataPlatformSCRProductionPlantRelationDatum                      *DataPlatformSCRProductionPlantRelationDatum          `boil:"BuyerDataPlatformSCRProductionPlantRelationDatum" json:"BuyerDataPlatformSCRProductionPlantRelationDatum" toml:"BuyerDataPlatformSCRProductionPlantRelationDatum" yaml:"BuyerDataPlatformSCRProductionPlantRelationDatum"`
	BuyerDataPlatformSCRStockConfPlantRelationDatum                       *DataPlatformSCRStockConfPlantRelationDatum           `boil:"BuyerDataPlatformSCRStockConfPlantRelationDatum" json:"BuyerDataPlatformSCRStockConfPlantRelationDatum" toml:"BuyerDataPlatformSCRStockConfPlantRelationDatum" yaml:"BuyerDataPlatformSCRStockConfPlantRelationDatum"`
	StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum       *DataPlatformTimeZoneTimeZoneDatum                    `boil:"StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" json:"StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" toml:"StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum" yaml:"StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum"`
	ProjectDataPlatformProjectWBSElementDatum                             *DataPlatformProjectWBSElementDatum                   `boil:"ProjectDataPlatformProjectWBSElementDatum" json:"ProjectDataPlatformProjectWBSElementDatum" toml:"ProjectDataPlatformProjectWBSElementDatum" yaml:"ProjectDataPlatformProjectWBSElementDatum"`
	OrderIDDataPlatformOrdersHeaderDatum                                  *DataPlatformOrdersHeaderDatum                        `boil:"OrderIDDataPlatformOrdersHeaderDatum" json:"OrderIDDataPlatformOrdersHeaderDatum" toml:"OrderIDDataPlatformOrdersHeaderDatum" yaml:"OrderIDDataPlatformOrdersHeaderDatum"`
	OrderIDDataPlatformDeliveryDocumentHeaderData                         DataPlatformDeliveryDocumentHeaderDatumSlice          `boil:"OrderIDDataPlatformDeliveryDocumentHeaderData" json:"OrderIDDataPlatformDeliveryDocumentHeaderData" toml:"OrderIDDataPlatformDeliveryDocumentHeaderData" yaml:"OrderIDDataPlatformDeliveryDocumentHeaderData"`
	OrderIDDataPlatformDeliveryDocumentItemData                           DataPlatformDeliveryDocumentItemDatumSlice            `boil:"OrderIDDataPlatformDeliveryDocumentItemData" json:"OrderIDDataPlatformDeliveryDocumentItemData" toml:"OrderIDDataPlatformDeliveryDocumentItemData" yaml:"OrderIDDataPlatformDeliveryDocumentItemData"`
	OrderIDDataPlatformInvoiceDocumentItemData                            DataPlatformInvoiceDocumentItemDatumSlice             `boil:"OrderIDDataPlatformInvoiceDocumentItemData" json:"OrderIDDataPlatformInvoiceDocumentItemData" toml:"OrderIDDataPlatformInvoiceDocumentItemData" yaml:"OrderIDDataPlatformInvoiceDocumentItemData"`
	OrderIDDataPlatformOrdersItemDocData                                  DataPlatformOrdersItemDocDatumSlice                   `boil:"OrderIDDataPlatformOrdersItemDocData" json:"OrderIDDataPlatformOrdersItemDocData" toml:"OrderIDDataPlatformOrdersItemDocData" yaml:"OrderIDDataPlatformOrdersItemDocData"`
	OrderIDDataPlatformOrdersItemFreightAgreementData                     DataPlatformOrdersItemFreightAgreementDatumSlice      `boil:"OrderIDDataPlatformOrdersItemFreightAgreementData" json:"OrderIDDataPlatformOrdersItemFreightAgreementData" toml:"OrderIDDataPlatformOrdersItemFreightAgreementData" yaml:"OrderIDDataPlatformOrdersItemFreightAgreementData"`
	OrderIDDataPlatformOrdersItemPricingElementData                       DataPlatformOrdersItemPricingElementDatumSlice        `boil:"OrderIDDataPlatformOrdersItemPricingElementData" json:"OrderIDDataPlatformOrdersItemPricingElementData" toml:"OrderIDDataPlatformOrdersItemPricingElementData" yaml:"OrderIDDataPlatformOrdersItemPricingElementData"`
	OrderIDDataPlatformOrdersItemScheduleLineData                         DataPlatformOrdersItemScheduleLineDatumSlice          `boil:"OrderIDDataPlatformOrdersItemScheduleLineData" json:"OrderIDDataPlatformOrdersItemScheduleLineData" toml:"OrderIDDataPlatformOrdersItemScheduleLineData" yaml:"OrderIDDataPlatformOrdersItemScheduleLineData"`
	OrderIDDataPlatformPlannedOrderHeaderData                             DataPlatformPlannedOrderHeaderDatumSlice              `boil:"OrderIDDataPlatformPlannedOrderHeaderData" json:"OrderIDDataPlatformPlannedOrderHeaderData" toml:"OrderIDDataPlatformPlannedOrderHeaderData" yaml:"OrderIDDataPlatformPlannedOrderHeaderData"`
	OrderIDDataPlatformPlannedOrderItemData                               DataPlatformPlannedOrderItemDatumSlice                `boil:"OrderIDDataPlatformPlannedOrderItemData" json:"OrderIDDataPlatformPlannedOrderItemData" toml:"OrderIDDataPlatformPlannedOrderItemData" yaml:"OrderIDDataPlatformPlannedOrderItemData"`
	OrderIDDataPlatformProductStockProductStockByOrderData                DataPlatformProductStockProductStockByOrderDatumSlice `boil:"OrderIDDataPlatformProductStockProductStockByOrderData" json:"OrderIDDataPlatformProductStockProductStockByOrderData" toml:"OrderIDDataPlatformProductStockProductStockByOrderData" yaml:"OrderIDDataPlatformProductStockProductStockByOrderData"`
	OrderIDDataPlatformProductionOrderHeaderData                          DataPlatformProductionOrderHeaderDatumSlice           `boil:"OrderIDDataPlatformProductionOrderHeaderData" json:"OrderIDDataPlatformProductionOrderHeaderData" toml:"OrderIDDataPlatformProductionOrderHeaderData" yaml:"OrderIDDataPlatformProductionOrderHeaderData"`
	OrderIDDataPlatformProductionOrderItemData                            DataPlatformProductionOrderItemDatumSlice             `boil:"OrderIDDataPlatformProductionOrderItemData" json:"OrderIDDataPlatformProductionOrderItemData" toml:"OrderIDDataPlatformProductionOrderItemData" yaml:"OrderIDDataPlatformProductionOrderItemData"`
	PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData             DataPlatformPurchaseRequisitionHeaderDatumSlice       `boil:"PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData" json:"PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData" toml:"PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData" yaml:"PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData"`
	FollowingOrderIDDataPlatformPurchaseRequisitionItemData               DataPlatformPurchaseRequisitionItemDatumSlice         `boil:"FollowingOrderIDDataPlatformPurchaseRequisitionItemData" json:"FollowingOrderIDDataPlatformPurchaseRequisitionItemData" toml:"FollowingOrderIDDataPlatformPurchaseRequisitionItemData" yaml:"FollowingOrderIDDataPlatformPurchaseRequisitionItemData"`
	PrecedingOrderIDDataPlatformPurchaseRequisitionItemData               DataPlatformPurchaseRequisitionItemDatumSlice         `boil:"PrecedingOrderIDDataPlatformPurchaseRequisitionItemData" json:"PrecedingOrderIDDataPlatformPurchaseRequisitionItemData" toml:"PrecedingOrderIDDataPlatformPurchaseRequisitionItemData" yaml:"PrecedingOrderIDDataPlatformPurchaseRequisitionItemData"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformOrdersItemDatumR) NewStruct() *dataPlatformOrdersItemDatumR {
	return &dataPlatformOrdersItemDatumR{}
}

func (r *dataPlatformOrdersItemDatumR) GetBaseUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBillOfMaterialDataPlatformBillOfMaterialItemDatum() *DataPlatformBillOfMaterialItemDatum {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformBillOfMaterialItemDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBillOfMaterialDataPlatformBillOfMaterialHeaderDatum() *DataPlatformBillOfMaterialHeaderDatum {
	if r == nil {
		return nil
	}
	return r.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum
}

func (r *dataPlatformOrdersItemDatumR) GetContractDataPlatformContractItemDatum() *DataPlatformContractItemDatum {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformContractItemDatum
}

func (r *dataPlatformOrdersItemDatumR) GetContractDataPlatformContractHeaderDatum() *DataPlatformContractHeaderDatum {
	if r == nil {
		return nil
	}
	return r.ContractDataPlatformContractHeaderDatum
}

func (r *dataPlatformOrdersItemDatumR) GetCountryOfOriginLanguageDataPlatformLanguageLanguageDatum() *DataPlatformLanguageLanguageDatum {
	if r == nil {
		return nil
	}
	return r.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum
}

func (r *dataPlatformOrdersItemDatumR) GetCountryOfOriginDataPlatformCountryCountryDatum() *DataPlatformCountryCountryDatum {
	if r == nil {
		return nil
	}
	return r.CountryOfOriginDataPlatformCountryCountryDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum() *DataPlatformBatchMasterRecordBatchDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliverFromPartyDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliverToPartyDataPlatformBatchMasterRecordBatchDatum() *DataPlatformBatchMasterRecordBatchDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliverToPartyDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformOrdersItemDatumR) GetDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformOrdersItemDatumR) GetEquipmentDataPlatformEquipmentMasterGeneralDatum() *DataPlatformEquipmentMasterGeneralDatum {
	if r == nil {
		return nil
	}
	return r.EquipmentDataPlatformEquipmentMasterGeneralDatum
}

func (r *dataPlatformOrdersItemDatumR) GetIncoterm() *DataPlatformIncotermsIncotermsDatum {
	if r == nil {
		return nil
	}
	return r.Incoterm
}

func (r *dataPlatformOrdersItemDatumR) GetInspectionLotDataPlatformInspectionLotHeaderDatum() *DataPlatformInspectionLotHeaderDatum {
	if r == nil {
		return nil
	}
	return r.InspectionLotDataPlatformInspectionLotHeaderDatum
}

func (r *dataPlatformOrdersItemDatumR) GetInspectionPlantDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.InspectionPlantDataPlatformPlantGeneralDatum
}

func (r *dataPlatformOrdersItemDatumR) GetInspectionPlanDataPlatformInspectionPlanHeaderDatum() *DataPlatformInspectionPlanHeaderDatum {
	if r == nil {
		return nil
	}
	return r.InspectionPlanDataPlatformInspectionPlanHeaderDatum
}

func (r *dataPlatformOrdersItemDatumR) GetInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformOrdersItemDatumR) GetPaymentMethodDataPlatformPaymentMethodPaymentMethodDatum() *DataPlatformPaymentMethodPaymentMethodDatum {
	if r == nil {
		return nil
	}
	return r.PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProductGroupDataPlatformProductGroupProductGroupDatum() *DataPlatformProductGroupProductGroupDatum {
	if r == nil {
		return nil
	}
	return r.ProductGroupDataPlatformProductGroupProductGroupDatum
}

func (r *dataPlatformOrdersItemDatumR) GetOperationIDDataPlatformProductionOrderItemOperationDatum() *DataPlatformProductionOrderItemOperationDatum {
	if r == nil {
		return nil
	}
	return r.OperationIDDataPlatformProductionOrderItemOperationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProductionOrderDataPlatformProductionOrderItemDatum() *DataPlatformProductionOrderItemDatum {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProductDataPlatformBatchMasterRecordBatchDatum() *DataPlatformBatchMasterRecordBatchDatum {
	if r == nil {
		return nil
	}
	return r.ProductDataPlatformBatchMasterRecordBatchDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProductionVersionDataPlatformProductionVersionItemDatum() *DataPlatformProductionVersionItemDatum {
	if r == nil {
		return nil
	}
	return r.ProductionVersionDataPlatformProductionVersionItemDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProjectDataPlatformProjectProjectDatum() *DataPlatformProjectProjectDatum {
	if r == nil {
		return nil
	}
	return r.ProjectDataPlatformProjectProjectDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBuyerDataPlatformSCRDeliveryRelationDatum() *DataPlatformSCRDeliveryRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryRelationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBuyerDataPlatformSCRDeliveryPlantRelationDatum() *DataPlatformSCRDeliveryPlantRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRDeliveryPlantRelationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBuyerDataPlatformSCRGeneralDatum() *DataPlatformSCRGeneralDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRGeneralDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBuyerDataPlatformSCRProductionPlantRelationDatum() *DataPlatformSCRProductionPlantRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRProductionPlantRelationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetBuyerDataPlatformSCRStockConfPlantRelationDatum() *DataPlatformSCRStockConfPlantRelationDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformSCRStockConfPlantRelationDatum
}

func (r *dataPlatformOrdersItemDatumR) GetStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum() *DataPlatformTimeZoneTimeZoneDatum {
	if r == nil {
		return nil
	}
	return r.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum
}

func (r *dataPlatformOrdersItemDatumR) GetProjectDataPlatformProjectWBSElementDatum() *DataPlatformProjectWBSElementDatum {
	if r == nil {
		return nil
	}
	return r.ProjectDataPlatformProjectWBSElementDatum
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformOrdersHeaderDatum() *DataPlatformOrdersHeaderDatum {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersHeaderDatum
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformDeliveryDocumentHeaderData() DataPlatformDeliveryDocumentHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformDeliveryDocumentHeaderData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformDeliveryDocumentItemData() DataPlatformDeliveryDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformDeliveryDocumentItemData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformInvoiceDocumentItemData() DataPlatformInvoiceDocumentItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformInvoiceDocumentItemData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformOrdersItemDocData() DataPlatformOrdersItemDocDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemDocData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformOrdersItemFreightAgreementData() DataPlatformOrdersItemFreightAgreementDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemFreightAgreementData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformOrdersItemPricingElementData() DataPlatformOrdersItemPricingElementDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemPricingElementData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformOrdersItemScheduleLineData() DataPlatformOrdersItemScheduleLineDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformOrdersItemScheduleLineData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformPlannedOrderHeaderData() DataPlatformPlannedOrderHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformPlannedOrderHeaderData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformPlannedOrderItemData() DataPlatformPlannedOrderItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformPlannedOrderItemData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformProductStockProductStockByOrderData() DataPlatformProductStockProductStockByOrderDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformProductStockProductStockByOrderData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformProductionOrderHeaderData() DataPlatformProductionOrderHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformProductionOrderHeaderData
}

func (r *dataPlatformOrdersItemDatumR) GetOrderIDDataPlatformProductionOrderItemData() DataPlatformProductionOrderItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.OrderIDDataPlatformProductionOrderItemData
}

func (r *dataPlatformOrdersItemDatumR) GetPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData() DataPlatformPurchaseRequisitionHeaderDatumSlice {
	if r == nil {
		return nil
	}
	return r.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData
}

func (r *dataPlatformOrdersItemDatumR) GetFollowingOrderIDDataPlatformPurchaseRequisitionItemData() DataPlatformPurchaseRequisitionItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.FollowingOrderIDDataPlatformPurchaseRequisitionItemData
}

func (r *dataPlatformOrdersItemDatumR) GetPrecedingOrderIDDataPlatformPurchaseRequisitionItemData() DataPlatformPurchaseRequisitionItemDatumSlice {
	if r == nil {
		return nil
	}
	return r.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData
}

// dataPlatformOrdersItemDatumL is where Load methods for each relationship are stored.
type dataPlatformOrdersItemDatumL struct{}

var (
	dataPlatformOrdersItemDatumAllColumns            = []string{"OrderID", "OrderItem", "OrderItemCategory", "OrderStatus", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipStockConfPlantID", "SupplyChainRelationshipProductionPlantID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "OrderItemText", "OrderItemTextByBuyer", "OrderItemTextBySeller", "Product", "SizeOrDimensionText", "ProductStandardID", "ProductGroup", "ProductSpecification", "MarkingOfMaterial", "BaseUnit", "DeliveryUnit", "ProductionVersion", "ProductionVersionItem", "BillOfMaterial", "BillOfMaterialItem", "ProductionOrder", "ProductionOrderItem", "Operations", "OperationsItem", "OperationID", "PricingDate", "PriceDetnExchangeRate", "RequestedDeliveryDate", "RequestedDeliveryTime", "DeliverToPlantTimeZone", "DeliverToPlantStorageLocation", "ProductIsBatchManagedInDeliverToPlant", "BatchMgmtPolicyInDeliverToPlant", "DeliverToPlantBatch", "DeliverToPlantBatchValidityStartDate", "DeliverToPlantBatchValidityStartTime", "DeliverToPlantBatchValidityEndDate", "DeliverToPlantBatchValidityEndTime", "DeliverFromPlantTimeZone", "DeliverFromPlantStorageLocation", "ProductIsBatchManagedInDeliverFromPlant", "BatchMgmtPolicyInDeliverFromPlant", "DeliverFromPlantBatch", "DeliverFromPlantBatchValidityStartDate", "DeliverFromPlantBatchValidityStartTime", "DeliverFromPlantBatchValidityEndDate", "DeliverFromPlantBatchValidityEndTime", "StockConfirmationBusinessPartner", "StockConfirmationPlant", "StockConfirmationPlantTimeZone", "ProductIsBatchManagedInStockConfirmationPlant", "BatchMgmtPolicyInStockConfirmationPlant", "StockConfirmationPlantBatch", "StockConfirmationPlantBatchValidityStartDate", "StockConfirmationPlantBatchValidityStartTime", "StockConfirmationPlantBatchValidityEndDate", "StockConfirmationPlantBatchValidityEndTime", "ServicesRenderingDate", "OrderQuantityInBaseUnit", "OrderQuantityInDeliveryUnit", "QuantityPerPackage", "StockConfirmationPolicy", "StockConfirmationStatus", "ConfirmedOrderQuantityInBaseUnit", "ProductWeightUnit", "ProductNetWeight", "ItemNetWeight", "ProductGrossWeight", "ItemGrossWeight", "InternalCapacityQuantity", "InternalCapacityQuantityUnit", "NetAmount", "TaxAmount", "GrossAmount", "InvoiceDocumentDate", "ProductionPlantBusinessPartner", "ProductionPlant", "ProductionPlantTimeZone", "ProductionPlantStorageLocation", "ProductIsBatchManagedInProductionPlant", "BatchMgmtPolicyInProductionPlant", "ProductionPlantBatch", "ProductionPlantBatchValidityStartDate", "ProductionPlantBatchValidityStartTime", "ProductionPlantBatchValidityEndDate", "ProductionPlantBatchValidityEndTime", "InspectionPlantBusinessPartner", "InspectionPlant", "InspectionPlan", "InspectionLot", "Incoterms", "TransactionTaxClassification", "ProductTaxClassificationBillToCountry", "ProductTaxClassificationBillFromCountry", "DefinedTaxClassification", "AccountAssignmentGroup", "ProductAccountAssignmentGroup", "PaymentTerms", "DueCalculationBaseDate", "PaymentDueDate", "NetPaymentDays", "PaymentMethod", "Contract", "ContractItem", "Project", "WBSElement", "AccountingExchangeRate", "ReferenceDocument", "ReferenceDocumentItem", "ItemCompleteDeliveryIsDefined", "ItemDeliveryStatus", "IssuingStatus", "ReceivingStatus", "ItemBillingStatus", "TaxCode", "TaxRate", "CountryOfOrigin", "CountryOfOriginLanguage", "Equipment", "FreightAgreement", "FreightAgreementItem", "ItemBlockStatus", "ItemDeliveryBlockStatus", "ItemBillingBlockStatus", "ExternalReferenceDocument", "ExternalReferenceDocumentItem", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformOrdersItemDatumColumnsWithoutDefault = []string{"OrderID", "OrderItem", "OrderItemCategory", "OrderStatus", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipStockConfPlantID", "SupplyChainRelationshipProductionPlantID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverFromPlant", "OrderItemText", "OrderItemTextByBuyer", "OrderItemTextBySeller", "Product", "SizeOrDimensionText", "ProductStandardID", "ProductGroup", "ProductSpecification", "MarkingOfMaterial", "BaseUnit", "DeliveryUnit", "ProductionVersion", "ProductionVersionItem", "BillOfMaterial", "BillOfMaterialItem", "ProductionOrder", "ProductionOrderItem", "Operations", "OperationsItem", "OperationID", "PricingDate", "PriceDetnExchangeRate", "RequestedDeliveryDate", "RequestedDeliveryTime", "DeliverToPlantTimeZone", "DeliverToPlantStorageLocation", "ProductIsBatchManagedInDeliverToPlant", "BatchMgmtPolicyInDeliverToPlant", "DeliverToPlantBatch", "DeliverToPlantBatchValidityStartDate", "DeliverToPlantBatchValidityStartTime", "DeliverToPlantBatchValidityEndDate", "DeliverToPlantBatchValidityEndTime", "DeliverFromPlantTimeZone", "DeliverFromPlantStorageLocation", "ProductIsBatchManagedInDeliverFromPlant", "BatchMgmtPolicyInDeliverFromPlant", "DeliverFromPlantBatch", "DeliverFromPlantBatchValidityStartDate", "DeliverFromPlantBatchValidityStartTime", "DeliverFromPlantBatchValidityEndDate", "DeliverFromPlantBatchValidityEndTime", "StockConfirmationBusinessPartner", "StockConfirmationPlant", "StockConfirmationPlantTimeZone", "ProductIsBatchManagedInStockConfirmationPlant", "BatchMgmtPolicyInStockConfirmationPlant", "StockConfirmationPlantBatch", "StockConfirmationPlantBatchValidityStartDate", "StockConfirmationPlantBatchValidityStartTime", "StockConfirmationPlantBatchValidityEndDate", "StockConfirmationPlantBatchValidityEndTime", "ServicesRenderingDate", "OrderQuantityInBaseUnit", "OrderQuantityInDeliveryUnit", "QuantityPerPackage", "StockConfirmationPolicy", "StockConfirmationStatus", "ConfirmedOrderQuantityInBaseUnit", "ProductWeightUnit", "ProductNetWeight", "ItemNetWeight", "ProductGrossWeight", "ItemGrossWeight", "InternalCapacityQuantity", "InternalCapacityQuantityUnit", "NetAmount", "TaxAmount", "GrossAmount", "InvoiceDocumentDate", "ProductionPlantBusinessPartner", "ProductionPlant", "ProductionPlantTimeZone", "ProductionPlantStorageLocation", "ProductIsBatchManagedInProductionPlant", "BatchMgmtPolicyInProductionPlant", "ProductionPlantBatch", "ProductionPlantBatchValidityStartDate", "ProductionPlantBatchValidityStartTime", "ProductionPlantBatchValidityEndDate", "ProductionPlantBatchValidityEndTime", "InspectionPlantBusinessPartner", "InspectionPlant", "InspectionPlan", "InspectionLot", "Incoterms", "TransactionTaxClassification", "ProductTaxClassificationBillToCountry", "ProductTaxClassificationBillFromCountry", "DefinedTaxClassification", "AccountAssignmentGroup", "ProductAccountAssignmentGroup", "PaymentTerms", "DueCalculationBaseDate", "PaymentDueDate", "NetPaymentDays", "PaymentMethod", "Contract", "ContractItem", "Project", "WBSElement", "AccountingExchangeRate", "ReferenceDocument", "ReferenceDocumentItem", "ItemCompleteDeliveryIsDefined", "ItemDeliveryStatus", "IssuingStatus", "ReceivingStatus", "ItemBillingStatus", "TaxCode", "TaxRate", "CountryOfOrigin", "CountryOfOriginLanguage", "Equipment", "FreightAgreement", "FreightAgreementItem", "ItemBlockStatus", "ItemDeliveryBlockStatus", "ItemBillingBlockStatus", "ExternalReferenceDocument", "ExternalReferenceDocumentItem", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsCancelled", "IsMarkedForDeletion"}
	dataPlatformOrdersItemDatumColumnsWithDefault    = []string{}
	dataPlatformOrdersItemDatumPrimaryKeyColumns     = []string{"OrderID", "OrderItem"}
	dataPlatformOrdersItemDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformOrdersItemDatumSlice is an alias for a slice of pointers to DataPlatformOrdersItemDatum.
	// This should almost always be used instead of []DataPlatformOrdersItemDatum.
	DataPlatformOrdersItemDatumSlice []*DataPlatformOrdersItemDatum

	dataPlatformOrdersItemDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformOrdersItemDatumType                 = reflect.TypeOf(&DataPlatformOrdersItemDatum{})
	dataPlatformOrdersItemDatumMapping              = queries.MakeStructMapping(dataPlatformOrdersItemDatumType)
	dataPlatformOrdersItemDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, dataPlatformOrdersItemDatumPrimaryKeyColumns)
	dataPlatformOrdersItemDatumInsertCacheMut       sync.RWMutex
	dataPlatformOrdersItemDatumInsertCache          = make(map[string]insertCache)
	dataPlatformOrdersItemDatumUpdateCacheMut       sync.RWMutex
	dataPlatformOrdersItemDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformOrdersItemDatumUpsertCacheMut       sync.RWMutex
	dataPlatformOrdersItemDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformOrdersItemDatum record from the query.
func (q dataPlatformOrdersItemDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformOrdersItemDatum, error) {
	o := &DataPlatformOrdersItemDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_orders_item_data")
	}

	return o, nil
}

// All returns all DataPlatformOrdersItemDatum records from the query.
func (q dataPlatformOrdersItemDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformOrdersItemDatumSlice, error) {
	var o []*DataPlatformOrdersItemDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformOrdersItemDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformOrdersItemDatum records in the query.
func (q dataPlatformOrdersItemDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_orders_item_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformOrdersItemDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_orders_item_data exists")
	}

	return count > 0, nil
}

// BaseUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BaseUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.BaseUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// BillOfMaterialDataPlatformBillOfMaterialItemDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BillOfMaterialDataPlatformBillOfMaterialItemDatum(mods ...qm.QueryMod) dataPlatformBillOfMaterialItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillOfMaterial` = ?", o.BillOfMaterial),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBillOfMaterialItemData(queryMods...)
}

// BillOfMaterialDataPlatformBillOfMaterialHeaderDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BillOfMaterialDataPlatformBillOfMaterialHeaderDatum(mods ...qm.QueryMod) dataPlatformBillOfMaterialHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BillOfMaterial` = ?", o.BillOfMaterial),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBillOfMaterialHeaderData(queryMods...)
}

// ContractDataPlatformContractItemDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ContractDataPlatformContractItemDatum(mods ...qm.QueryMod) dataPlatformContractItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Contract` = ?", o.Contract),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformContractItemData(queryMods...)
}

// ContractDataPlatformContractHeaderDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ContractDataPlatformContractHeaderDatum(mods ...qm.QueryMod) dataPlatformContractHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Contract` = ?", o.Contract),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformContractHeaderData(queryMods...)
}

// CountryOfOriginLanguageDataPlatformLanguageLanguageDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) CountryOfOriginLanguageDataPlatformLanguageLanguageDatum(mods ...qm.QueryMod) dataPlatformLanguageLanguageDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Language` = ?", o.CountryOfOriginLanguage),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformLanguageLanguageData(queryMods...)
}

// CountryOfOriginDataPlatformCountryCountryDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) CountryOfOriginDataPlatformCountryCountryDatum(mods ...qm.QueryMod) dataPlatformCountryCountryDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Country` = ?", o.CountryOfOrigin),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformCountryCountryData(queryMods...)
}

// DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum(mods ...qm.QueryMod) dataPlatformBatchMasterRecordBatchDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBatchMasterRecordBatchData(queryMods...)
}

// DeliverFromPartyDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliverFromPartyDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.DeliverFromPlantTimeZone),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// DeliverToPartyDataPlatformBatchMasterRecordBatchDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliverToPartyDataPlatformBatchMasterRecordBatchDatum(mods ...qm.QueryMod) dataPlatformBatchMasterRecordBatchDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBatchMasterRecordBatchData(queryMods...)
}

// DeliverToPartyDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliverToPartyDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.DeliverToPlantTimeZone),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.DeliveryUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// EquipmentDataPlatformEquipmentMasterGeneralDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) EquipmentDataPlatformEquipmentMasterGeneralDatum(mods ...qm.QueryMod) dataPlatformEquipmentMasterGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Equipment` = ?", o.Equipment),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformEquipmentMasterGeneralData(queryMods...)
}

// Incoterm pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) Incoterm(mods ...qm.QueryMod) dataPlatformIncotermsIncotermsDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Incoterms` = ?", o.Incoterms),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformIncotermsIncotermsData(queryMods...)
}

// InspectionLotDataPlatformInspectionLotHeaderDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) InspectionLotDataPlatformInspectionLotHeaderDatum(mods ...qm.QueryMod) dataPlatformInspectionLotHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`InspectionLot` = ?", o.InspectionLot),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformInspectionLotHeaderData(queryMods...)
}

// InspectionPlantDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) InspectionPlantDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Plant` = ?", o.InspectionPlant),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// InspectionPlanDataPlatformInspectionPlanHeaderDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) InspectionPlanDataPlatformInspectionPlanHeaderDatum(mods ...qm.QueryMod) dataPlatformInspectionPlanHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`InspectionPlan` = ?", o.InspectionPlan),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformInspectionPlanHeaderData(queryMods...)
}

// InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.InternalCapacityQuantityUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum(mods ...qm.QueryMod) dataPlatformPaymentMethodPaymentMethodDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`PaymentMethod` = ?", o.PaymentMethod),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPaymentMethodPaymentMethodData(queryMods...)
}

// ProductGroupDataPlatformProductGroupProductGroupDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProductGroupDataPlatformProductGroupProductGroupDatum(mods ...qm.QueryMod) dataPlatformProductGroupProductGroupDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductGroup` = ?", o.ProductGroup),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductGroupProductGroupData(queryMods...)
}

// OperationIDDataPlatformProductionOrderItemOperationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) OperationIDDataPlatformProductionOrderItemOperationDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemOperationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OperationID` = ?", o.OperationID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemOperationData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProductionOrderDataPlatformProductionOrderItemDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionOrder` = ?", o.ProductionOrder),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemData(queryMods...)
}

// ProductDataPlatformBatchMasterRecordBatchDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProductDataPlatformBatchMasterRecordBatchDatum(mods ...qm.QueryMod) dataPlatformBatchMasterRecordBatchDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.Product),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBatchMasterRecordBatchData(queryMods...)
}

// ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.ProductionPlantTimeZone),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// ProductionVersionDataPlatformProductionVersionItemDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProductionVersionDataPlatformProductionVersionItemDatum(mods ...qm.QueryMod) dataPlatformProductionVersionItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionVersion` = ?", o.ProductionVersion),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionVersionItemData(queryMods...)
}

// ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ProductWeightUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// ProjectDataPlatformProjectProjectDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProjectDataPlatformProjectProjectDatum(mods ...qm.QueryMod) dataPlatformProjectProjectDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Project` = ?", o.Project),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProjectProjectData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryRelationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BuyerDataPlatformSCRDeliveryRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryRelationData(queryMods...)
}

// BuyerDataPlatformSCRDeliveryPlantRelationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BuyerDataPlatformSCRDeliveryPlantRelationDatum(mods ...qm.QueryMod) dataPlatformSCRDeliveryPlantRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRDeliveryPlantRelationData(queryMods...)
}

// BuyerDataPlatformSCRGeneralDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BuyerDataPlatformSCRGeneralDatum(mods ...qm.QueryMod) dataPlatformSCRGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRGeneralData(queryMods...)
}

// BuyerDataPlatformSCRProductionPlantRelationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BuyerDataPlatformSCRProductionPlantRelationDatum(mods ...qm.QueryMod) dataPlatformSCRProductionPlantRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRProductionPlantRelationData(queryMods...)
}

// BuyerDataPlatformSCRStockConfPlantRelationDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) BuyerDataPlatformSCRStockConfPlantRelationDatum(mods ...qm.QueryMod) dataPlatformSCRStockConfPlantRelationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformSCRStockConfPlantRelationData(queryMods...)
}

// StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(mods ...qm.QueryMod) dataPlatformTimeZoneTimeZoneDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`TimeZone` = ?", o.StockConfirmationPlantTimeZone),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformTimeZoneTimeZoneData(queryMods...)
}

// ProjectDataPlatformProjectWBSElementDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) ProjectDataPlatformProjectWBSElementDatum(mods ...qm.QueryMod) dataPlatformProjectWBSElementDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Project` = ?", o.Project),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProjectWBSElementData(queryMods...)
}

// OrderIDDataPlatformOrdersHeaderDatum pointed to by the foreign key.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformOrdersHeaderDatum(mods ...qm.QueryMod) dataPlatformOrdersHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OrderID` = ?", o.OrderID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOrdersHeaderData(queryMods...)
}

// OrderIDDataPlatformDeliveryDocumentHeaderData retrieves all the data_platform_delivery_document_header_datum's DataPlatformDeliveryDocumentHeaderData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformDeliveryDocumentHeaderData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_header_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformDeliveryDocumentHeaderData(queryMods...)
}

// OrderIDDataPlatformDeliveryDocumentItemData retrieves all the data_platform_delivery_document_item_datum's DataPlatformDeliveryDocumentItemData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformDeliveryDocumentItemData(mods ...qm.QueryMod) dataPlatformDeliveryDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_delivery_document_item_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformDeliveryDocumentItemData(queryMods...)
}

// OrderIDDataPlatformInvoiceDocumentItemData retrieves all the data_platform_invoice_document_item_datum's DataPlatformInvoiceDocumentItemData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformInvoiceDocumentItemData(mods ...qm.QueryMod) dataPlatformInvoiceDocumentItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_invoice_document_item_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformInvoiceDocumentItemData(queryMods...)
}

// OrderIDDataPlatformOrdersItemDocData retrieves all the data_platform_orders_item_doc_datum's DataPlatformOrdersItemDocData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformOrdersItemDocData(mods ...qm.QueryMod) dataPlatformOrdersItemDocDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_doc_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformOrdersItemDocData(queryMods...)
}

// OrderIDDataPlatformOrdersItemFreightAgreementData retrieves all the data_platform_orders_item_freight_agreement_datum's DataPlatformOrdersItemFreightAgreementData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformOrdersItemFreightAgreementData(mods ...qm.QueryMod) dataPlatformOrdersItemFreightAgreementDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_freight_agreement_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformOrdersItemFreightAgreementData(queryMods...)
}

// OrderIDDataPlatformOrdersItemPricingElementData retrieves all the data_platform_orders_item_pricing_element_datum's DataPlatformOrdersItemPricingElementData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformOrdersItemPricingElementData(mods ...qm.QueryMod) dataPlatformOrdersItemPricingElementDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_pricing_element_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformOrdersItemPricingElementData(queryMods...)
}

// OrderIDDataPlatformOrdersItemScheduleLineData retrieves all the data_platform_orders_item_schedule_line_datum's DataPlatformOrdersItemScheduleLineData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformOrdersItemScheduleLineData(mods ...qm.QueryMod) dataPlatformOrdersItemScheduleLineDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_orders_item_schedule_line_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformOrdersItemScheduleLineData(queryMods...)
}

// OrderIDDataPlatformPlannedOrderHeaderData retrieves all the data_platform_planned_order_header_datum's DataPlatformPlannedOrderHeaderData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformPlannedOrderHeaderData(mods ...qm.QueryMod) dataPlatformPlannedOrderHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_planned_order_header_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformPlannedOrderHeaderData(queryMods...)
}

// OrderIDDataPlatformPlannedOrderItemData retrieves all the data_platform_planned_order_item_datum's DataPlatformPlannedOrderItemData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformPlannedOrderItemData(mods ...qm.QueryMod) dataPlatformPlannedOrderItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_planned_order_item_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformPlannedOrderItemData(queryMods...)
}

// OrderIDDataPlatformProductStockProductStockByOrderData retrieves all the data_platform_product_stock_product_stock_by_order_datum's DataPlatformProductStockProductStockByOrderData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformProductStockProductStockByOrderData(mods ...qm.QueryMod) dataPlatformProductStockProductStockByOrderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_product_stock_product_stock_by_order_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformProductStockProductStockByOrderData(queryMods...)
}

// OrderIDDataPlatformProductionOrderHeaderData retrieves all the data_platform_production_order_header_datum's DataPlatformProductionOrderHeaderData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformProductionOrderHeaderData(mods ...qm.QueryMod) dataPlatformProductionOrderHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_production_order_header_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformProductionOrderHeaderData(queryMods...)
}

// OrderIDDataPlatformProductionOrderItemData retrieves all the data_platform_production_order_item_datum's DataPlatformProductionOrderItemData with an executor via OrderID column.
func (o *DataPlatformOrdersItemDatum) OrderIDDataPlatformProductionOrderItemData(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_production_order_item_data`.`OrderID`=?", o.OrderID),
	)

	return DataPlatformProductionOrderItemData(queryMods...)
}

// PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData retrieves all the data_platform_purchase_requisition_header_datum's DataPlatformPurchaseRequisitionHeaderData with an executor via PrecedingOrderID column.
func (o *DataPlatformOrdersItemDatum) PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionHeaderDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_purchase_requisition_header_data`.`PrecedingOrderID`=?", o.OrderID),
	)

	return DataPlatformPurchaseRequisitionHeaderData(queryMods...)
}

// FollowingOrderIDDataPlatformPurchaseRequisitionItemData retrieves all the data_platform_purchase_requisition_item_datum's DataPlatformPurchaseRequisitionItemData with an executor via FollowingOrderID column.
func (o *DataPlatformOrdersItemDatum) FollowingOrderIDDataPlatformPurchaseRequisitionItemData(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_purchase_requisition_item_data`.`FollowingOrderID`=?", o.OrderID),
	)

	return DataPlatformPurchaseRequisitionItemData(queryMods...)
}

// PrecedingOrderIDDataPlatformPurchaseRequisitionItemData retrieves all the data_platform_purchase_requisition_item_datum's DataPlatformPurchaseRequisitionItemData with an executor via PrecedingOrderID column.
func (o *DataPlatformOrdersItemDatum) PrecedingOrderIDDataPlatformPurchaseRequisitionItemData(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionItemDatumQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`data_platform_purchase_requisition_item_data`.`PrecedingOrderID`=?", o.OrderID),
	)

	return DataPlatformPurchaseRequisitionItemData(queryMods...)
}

// LoadBaseUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.BaseUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.BaseUnit {
					continue Outer
				}
			}

			args = append(args, obj.BaseUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BaseUnit == foreign.QuantityUnit {
				local.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillOfMaterialDataPlatformBillOfMaterialItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.BillOfMaterial) {
			args = append(args, object.BillOfMaterial)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillOfMaterial) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillOfMaterial) {
				args = append(args, obj.BillOfMaterial)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_bill_of_material_item_data`),
		qm.WhereIn(`data_platform_bill_of_material_item_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBillOfMaterialItemDatum")
	}

	var resultSlice []*DataPlatformBillOfMaterialItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBillOfMaterialItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_bill_of_material_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_bill_of_material_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillOfMaterial, foreign.BillOfMaterial) {
				local.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBillOfMaterialDataPlatformBillOfMaterialHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBillOfMaterialDataPlatformBillOfMaterialHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.BillOfMaterial) {
			args = append(args, object.BillOfMaterial)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BillOfMaterial) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BillOfMaterial) {
				args = append(args, obj.BillOfMaterial)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_bill_of_material_header_data`),
		qm.WhereIn(`data_platform_bill_of_material_header_data.BillOfMaterial in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBillOfMaterialHeaderDatum")
	}

	var resultSlice []*DataPlatformBillOfMaterialHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBillOfMaterialHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_bill_of_material_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_bill_of_material_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BillOfMaterial, foreign.BillOfMaterial) {
				local.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformContractItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadContractDataPlatformContractItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.Contract) {
			args = append(args, object.Contract)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Contract) {
				args = append(args, obj.Contract)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_contract_item_data`),
		qm.WhereIn(`data_platform_contract_item_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformContractItemDatum")
	}

	var resultSlice []*DataPlatformContractItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformContractItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_contract_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_contract_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ContractDataPlatformContractItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformContractItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadContractDataPlatformContractHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadContractDataPlatformContractHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.Contract) {
			args = append(args, object.Contract)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Contract) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Contract) {
				args = append(args, obj.Contract)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_contract_header_data`),
		qm.WhereIn(`data_platform_contract_header_data.Contract in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformContractHeaderDatum")
	}

	var resultSlice []*DataPlatformContractHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformContractHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_contract_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_contract_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ContractDataPlatformContractHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Contract, foreign.Contract) {
				local.R.ContractDataPlatformContractHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadCountryOfOriginLanguageDataPlatformLanguageLanguageDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadCountryOfOriginLanguageDataPlatformLanguageLanguageDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.CountryOfOriginLanguage) {
			args = append(args, object.CountryOfOriginLanguage)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CountryOfOriginLanguage) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CountryOfOriginLanguage) {
				args = append(args, obj.CountryOfOriginLanguage)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_language_language_data`),
		qm.WhereIn(`data_platform_language_language_data.Language in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformLanguageLanguageDatum")
	}

	var resultSlice []*DataPlatformLanguageLanguageDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformLanguageLanguageDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_language_language_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_language_language_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CountryOfOriginLanguage, foreign.Language) {
				local.R.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadCountryOfOriginDataPlatformCountryCountryDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadCountryOfOriginDataPlatformCountryCountryDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.CountryOfOrigin) {
			args = append(args, object.CountryOfOrigin)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CountryOfOrigin) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CountryOfOrigin) {
				args = append(args, obj.CountryOfOrigin)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_country_country_data`),
		qm.WhereIn(`data_platform_country_country_data.Country in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformCountryCountryDatum")
	}

	var resultSlice []*DataPlatformCountryCountryDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformCountryCountryDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_country_country_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_country_country_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CountryOfOriginDataPlatformCountryCountryDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CountryOfOrigin, foreign.Country) {
				local.R.CountryOfOriginDataPlatformCountryCountryDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.DeliverFromParty) {
			args = append(args, object.DeliverFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromParty) {
				args = append(args, obj.DeliverFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_batch_master_record_batch_data`),
		qm.WhereIn(`data_platform_batch_master_record_batch_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBatchMasterRecordBatchDatum")
	}

	var resultSlice []*DataPlatformBatchMasterRecordBatchDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBatchMasterRecordBatchDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_batch_master_record_batch_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_batch_master_record_batch_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromParty, foreign.BusinessPartner) {
				local.R.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.DeliverFromParty) {
			args = append(args, object.DeliverFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromParty) {
				args = append(args, obj.DeliverFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromParty, foreign.BusinessPartner) {
				local.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.DeliverFromPlantTimeZone) {
			args = append(args, object.DeliverFromPlantTimeZone)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromPlantTimeZone) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromPlantTimeZone) {
				args = append(args, obj.DeliverFromPlantTimeZone)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromPlantTimeZone, foreign.TimeZone) {
				local.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformBatchMasterRecordBatchDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliverToPartyDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.DeliverToParty) {
			args = append(args, object.DeliverToParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverToParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverToParty) {
				args = append(args, obj.DeliverToParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_batch_master_record_batch_data`),
		qm.WhereIn(`data_platform_batch_master_record_batch_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBatchMasterRecordBatchDatum")
	}

	var resultSlice []*DataPlatformBatchMasterRecordBatchDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBatchMasterRecordBatchDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_batch_master_record_batch_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_batch_master_record_batch_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverToParty, foreign.BusinessPartner) {
				local.R.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.DeliverToParty) {
			args = append(args, object.DeliverToParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverToParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverToParty) {
				args = append(args, obj.DeliverToParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverToParty, foreign.BusinessPartner) {
				local.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.DeliverToPlantTimeZone) {
			args = append(args, object.DeliverToPlantTimeZone)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverToPlantTimeZone) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverToPlantTimeZone) {
				args = append(args, obj.DeliverToPlantTimeZone)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverToPlantTimeZone, foreign.TimeZone) {
				local.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.DeliveryUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliveryUnit {
					continue Outer
				}
			}

			args = append(args, obj.DeliveryUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliveryUnit == foreign.QuantityUnit {
				local.R.DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadEquipmentDataPlatformEquipmentMasterGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadEquipmentDataPlatformEquipmentMasterGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.Equipment) {
			args = append(args, object.Equipment)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Equipment) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Equipment) {
				args = append(args, obj.Equipment)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_equipment_master_general_data`),
		qm.WhereIn(`data_platform_equipment_master_general_data.Equipment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformEquipmentMasterGeneralDatum")
	}

	var resultSlice []*DataPlatformEquipmentMasterGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformEquipmentMasterGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_equipment_master_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_equipment_master_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.EquipmentDataPlatformEquipmentMasterGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Equipment, foreign.Equipment) {
				local.R.EquipmentDataPlatformEquipmentMasterGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadIncoterm allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadIncoterm(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.Incoterms) {
			args = append(args, object.Incoterms)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Incoterms) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Incoterms) {
				args = append(args, obj.Incoterms)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_incoterms_incoterms_data`),
		qm.WhereIn(`data_platform_incoterms_incoterms_data.Incoterms in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformIncotermsIncotermsDatum")
	}

	var resultSlice []*DataPlatformIncotermsIncotermsDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformIncotermsIncotermsDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_incoterms_incoterms_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_incoterms_incoterms_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Incoterm = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Incoterms, foreign.Incoterms) {
				local.R.Incoterm = foreign
				break
			}
		}
	}

	return nil
}

// LoadInspectionLotDataPlatformInspectionLotHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadInspectionLotDataPlatformInspectionLotHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.InspectionLot) {
			args = append(args, object.InspectionLot)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InspectionLot) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InspectionLot) {
				args = append(args, obj.InspectionLot)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_inspection_lot_header_data`),
		qm.WhereIn(`data_platform_inspection_lot_header_data.InspectionLot in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformInspectionLotHeaderDatum")
	}

	var resultSlice []*DataPlatformInspectionLotHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformInspectionLotHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_inspection_lot_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_inspection_lot_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InspectionLotDataPlatformInspectionLotHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InspectionLot, foreign.InspectionLot) {
				local.R.InspectionLotDataPlatformInspectionLotHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadInspectionPlantDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadInspectionPlantDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.InspectionPlant) {
			args = append(args, object.InspectionPlant)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InspectionPlant) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InspectionPlant) {
				args = append(args, obj.InspectionPlant)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.Plant in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InspectionPlantDataPlatformPlantGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InspectionPlant, foreign.Plant) {
				local.R.InspectionPlantDataPlatformPlantGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadInspectionPlanDataPlatformInspectionPlanHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadInspectionPlanDataPlatformInspectionPlanHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.InspectionPlan) {
			args = append(args, object.InspectionPlan)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InspectionPlan) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InspectionPlan) {
				args = append(args, obj.InspectionPlan)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_inspection_plan_header_data`),
		qm.WhereIn(`data_platform_inspection_plan_header_data.InspectionPlan in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformInspectionPlanHeaderDatum")
	}

	var resultSlice []*DataPlatformInspectionPlanHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformInspectionPlanHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_inspection_plan_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_inspection_plan_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InspectionPlanDataPlatformInspectionPlanHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InspectionPlan, foreign.InspectionPlan) {
				local.R.InspectionPlanDataPlatformInspectionPlanHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.InternalCapacityQuantityUnit) {
			args = append(args, object.InternalCapacityQuantityUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InternalCapacityQuantityUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InternalCapacityQuantityUnit) {
				args = append(args, obj.InternalCapacityQuantityUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InternalCapacityQuantityUnit, foreign.QuantityUnit) {
				local.R.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadPaymentMethodDataPlatformPaymentMethodPaymentMethodDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadPaymentMethodDataPlatformPaymentMethodPaymentMethodDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.PaymentMethod)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.PaymentMethod {
					continue Outer
				}
			}

			args = append(args, obj.PaymentMethod)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_payment_method_payment_method_data`),
		qm.WhereIn(`data_platform_payment_method_payment_method_data.PaymentMethod in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPaymentMethodPaymentMethodDatum")
	}

	var resultSlice []*DataPlatformPaymentMethodPaymentMethodDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPaymentMethodPaymentMethodDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_payment_method_payment_method_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_payment_method_payment_method_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PaymentMethod == foreign.PaymentMethod {
				local.R.PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductGroupDataPlatformProductGroupProductGroupDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProductGroupDataPlatformProductGroupProductGroupDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.ProductGroup) {
			args = append(args, object.ProductGroup)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductGroup) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductGroup) {
				args = append(args, obj.ProductGroup)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_product_group_product_group_data`),
		qm.WhereIn(`data_platform_product_group_product_group_data.ProductGroup in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductGroupProductGroupDatum")
	}

	var resultSlice []*DataPlatformProductGroupProductGroupDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductGroupProductGroupDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_product_group_product_group_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_product_group_product_group_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductGroupDataPlatformProductGroupProductGroupDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductGroup, foreign.ProductGroup) {
				local.R.ProductGroupDataPlatformProductGroupProductGroupDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadOperationIDDataPlatformProductionOrderItemOperationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadOperationIDDataPlatformProductionOrderItemOperationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.OperationID) {
			args = append(args, object.OperationID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OperationID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.OperationID) {
				args = append(args, obj.OperationID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_operation_data`),
		qm.WhereIn(`data_platform_production_order_item_operation_data.OperationID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemOperationDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemOperationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemOperationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_operation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_operation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OperationIDDataPlatformProductionOrderItemOperationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.OperationID, foreign.OperationID) {
				local.R.OperationIDDataPlatformProductionOrderItemOperationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.ProductionOrder) {
			args = append(args, object.ProductionOrder)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductionOrder) {
				args = append(args, obj.ProductionOrder)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_data`),
		qm.WhereIn(`data_platform_production_order_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductDataPlatformBatchMasterRecordBatchDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.Product)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_batch_master_record_batch_data`),
		qm.WhereIn(`data_platform_batch_master_record_batch_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBatchMasterRecordBatchDatum")
	}

	var resultSlice []*DataPlatformBatchMasterRecordBatchDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBatchMasterRecordBatchDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_batch_master_record_batch_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_batch_master_record_batch_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductDataPlatformBatchMasterRecordBatchDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Product == foreign.Product {
				local.R.ProductDataPlatformBatchMasterRecordBatchDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.ProductionPlantTimeZone) {
			args = append(args, object.ProductionPlantTimeZone)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionPlantTimeZone) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductionPlantTimeZone) {
				args = append(args, obj.ProductionPlantTimeZone)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductionPlantTimeZone, foreign.TimeZone) {
				local.R.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionVersionDataPlatformProductionVersionItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProductionVersionDataPlatformProductionVersionItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.ProductionVersion) {
			args = append(args, object.ProductionVersion)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionVersion) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductionVersion) {
				args = append(args, obj.ProductionVersion)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_version_item_data`),
		qm.WhereIn(`data_platform_production_version_item_data.ProductionVersion in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionVersionItemDatum")
	}

	var resultSlice []*DataPlatformProductionVersionItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionVersionItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_version_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_version_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionVersionDataPlatformProductionVersionItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductionVersion, foreign.ProductionVersion) {
				local.R.ProductionVersionDataPlatformProductionVersionItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.ProductWeightUnit) {
			args = append(args, object.ProductWeightUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductWeightUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductWeightUnit) {
				args = append(args, obj.ProductWeightUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductWeightUnit, foreign.QuantityUnit) {
				local.R.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProjectDataPlatformProjectProjectDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProjectDataPlatformProjectProjectDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.Project) {
			args = append(args, object.Project)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Project) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Project) {
				args = append(args, obj.Project)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_project_project_data`),
		qm.WhereIn(`data_platform_project_project_data.Project in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProjectProjectDatum")
	}

	var resultSlice []*DataPlatformProjectProjectDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProjectProjectDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_project_project_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_project_project_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProjectDataPlatformProjectProjectDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Project, foreign.Project) {
				local.R.ProjectDataPlatformProjectProjectDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRDeliveryPlantRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBuyerDataPlatformSCRDeliveryPlantRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_delivery_plant_relation_data`),
		qm.WhereIn(`data_platform_scr_delivery_plant_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRDeliveryPlantRelationDatum")
	}

	var resultSlice []*DataPlatformSCRDeliveryPlantRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRDeliveryPlantRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_delivery_plant_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_delivery_plant_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBuyerDataPlatformSCRGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_general_data`),
		qm.WhereIn(`data_platform_scr_general_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRGeneralDatum")
	}

	var resultSlice []*DataPlatformSCRGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRProductionPlantRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBuyerDataPlatformSCRProductionPlantRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_production_plant_relation_data`),
		qm.WhereIn(`data_platform_scr_production_plant_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRProductionPlantRelationDatum")
	}

	var resultSlice []*DataPlatformSCRProductionPlantRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRProductionPlantRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_production_plant_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_production_plant_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRProductionPlantRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRProductionPlantRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformSCRStockConfPlantRelationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadBuyerDataPlatformSCRStockConfPlantRelationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_scr_stock_conf_plant_relation_data`),
		qm.WhereIn(`data_platform_scr_stock_conf_plant_relation_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformSCRStockConfPlantRelationDatum")
	}

	var resultSlice []*DataPlatformSCRStockConfPlantRelationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformSCRStockConfPlantRelationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_scr_stock_conf_plant_relation_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_scr_stock_conf_plant_relation_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformSCRStockConfPlantRelationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformSCRStockConfPlantRelationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.StockConfirmationPlantTimeZone) {
			args = append(args, object.StockConfirmationPlantTimeZone)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.StockConfirmationPlantTimeZone) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.StockConfirmationPlantTimeZone) {
				args = append(args, obj.StockConfirmationPlantTimeZone)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_time_zone_time_zone_data`),
		qm.WhereIn(`data_platform_time_zone_time_zone_data.TimeZone in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformTimeZoneTimeZoneDatum")
	}

	var resultSlice []*DataPlatformTimeZoneTimeZoneDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformTimeZoneTimeZoneDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_time_zone_time_zone_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_time_zone_time_zone_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.StockConfirmationPlantTimeZone, foreign.TimeZone) {
				local.R.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProjectDataPlatformProjectWBSElementDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadProjectDataPlatformProjectWBSElementDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		if !queries.IsNil(object.Project) {
			args = append(args, object.Project)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Project) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Project) {
				args = append(args, obj.Project)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_project_wbs_element_data`),
		qm.WhereIn(`data_platform_project_wbs_element_data.Project in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProjectWBSElementDatum")
	}

	var resultSlice []*DataPlatformProjectWBSElementDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProjectWBSElementDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_project_wbs_element_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_project_wbs_element_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProjectDataPlatformProjectWBSElementDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Project, foreign.Project) {
				local.R.ProjectDataPlatformProjectWBSElementDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformOrdersHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.OrderID {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_header_data`),
		qm.WhereIn(`data_platform_orders_header_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOrdersHeaderDatum")
	}

	var resultSlice []*DataPlatformOrdersHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOrdersHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_orders_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.OrderIDDataPlatformOrdersHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OrderID == foreign.OrderID {
				local.R.OrderIDDataPlatformOrdersHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformDeliveryDocumentHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformDeliveryDocumentHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_header_data`),
		qm.WhereIn(`data_platform_delivery_document_header_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_header_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_header_data")
	}

	if singular {
		object.R.OrderIDDataPlatformDeliveryDocumentHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformDeliveryDocumentHeaderData = append(local.R.OrderIDDataPlatformDeliveryDocumentHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformDeliveryDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformDeliveryDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_delivery_document_item_data`),
		qm.WhereIn(`data_platform_delivery_document_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_delivery_document_item_data")
	}

	var resultSlice []*DataPlatformDeliveryDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_delivery_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_delivery_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_delivery_document_item_data")
	}

	if singular {
		object.R.OrderIDDataPlatformDeliveryDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformDeliveryDocumentItemData = append(local.R.OrderIDDataPlatformDeliveryDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformInvoiceDocumentItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformInvoiceDocumentItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_invoice_document_item_data`),
		qm.WhereIn(`data_platform_invoice_document_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_invoice_document_item_data")
	}

	var resultSlice []*DataPlatformInvoiceDocumentItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_invoice_document_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_invoice_document_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_invoice_document_item_data")
	}

	if singular {
		object.R.OrderIDDataPlatformInvoiceDocumentItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformInvoiceDocumentItemData = append(local.R.OrderIDDataPlatformInvoiceDocumentItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemDocData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformOrdersItemDocData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.OrderID {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_doc_data`),
		qm.WhereIn(`data_platform_orders_item_doc_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_doc_data")
	}

	var resultSlice []*DataPlatformOrdersItemDocDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_doc_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_doc_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_doc_data")
	}

	if singular {
		object.R.OrderIDDataPlatformOrdersItemDocData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.OrderID == foreign.OrderID {
				local.R.OrderIDDataPlatformOrdersItemDocData = append(local.R.OrderIDDataPlatformOrdersItemDocData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemFreightAgreementData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformOrdersItemFreightAgreementData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.OrderID {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_freight_agreement_data`),
		qm.WhereIn(`data_platform_orders_item_freight_agreement_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_freight_agreement_data")
	}

	var resultSlice []*DataPlatformOrdersItemFreightAgreementDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_freight_agreement_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_freight_agreement_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_freight_agreement_data")
	}

	if singular {
		object.R.OrderIDDataPlatformOrdersItemFreightAgreementData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.OrderID == foreign.OrderID {
				local.R.OrderIDDataPlatformOrdersItemFreightAgreementData = append(local.R.OrderIDDataPlatformOrdersItemFreightAgreementData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemPricingElementData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformOrdersItemPricingElementData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.OrderID {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_pricing_element_data`),
		qm.WhereIn(`data_platform_orders_item_pricing_element_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_pricing_element_data")
	}

	var resultSlice []*DataPlatformOrdersItemPricingElementDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_pricing_element_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_pricing_element_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_pricing_element_data")
	}

	if singular {
		object.R.OrderIDDataPlatformOrdersItemPricingElementData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.OrderID == foreign.OrderID {
				local.R.OrderIDDataPlatformOrdersItemPricingElementData = append(local.R.OrderIDDataPlatformOrdersItemPricingElementData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformOrdersItemScheduleLineData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformOrdersItemScheduleLineData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.OrderID {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_schedule_line_data`),
		qm.WhereIn(`data_platform_orders_item_schedule_line_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_orders_item_schedule_line_data")
	}

	var resultSlice []*DataPlatformOrdersItemScheduleLineDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_orders_item_schedule_line_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_orders_item_schedule_line_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_schedule_line_data")
	}

	if singular {
		object.R.OrderIDDataPlatformOrdersItemScheduleLineData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.OrderID == foreign.OrderID {
				local.R.OrderIDDataPlatformOrdersItemScheduleLineData = append(local.R.OrderIDDataPlatformOrdersItemScheduleLineData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformPlannedOrderHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformPlannedOrderHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_planned_order_header_data`),
		qm.WhereIn(`data_platform_planned_order_header_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_planned_order_header_data")
	}

	var resultSlice []*DataPlatformPlannedOrderHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_planned_order_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_planned_order_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_planned_order_header_data")
	}

	if singular {
		object.R.OrderIDDataPlatformPlannedOrderHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformPlannedOrderHeaderData = append(local.R.OrderIDDataPlatformPlannedOrderHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformPlannedOrderItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformPlannedOrderItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_planned_order_item_data`),
		qm.WhereIn(`data_platform_planned_order_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_planned_order_item_data")
	}

	var resultSlice []*DataPlatformPlannedOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_planned_order_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_planned_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_planned_order_item_data")
	}

	if singular {
		object.R.OrderIDDataPlatformPlannedOrderItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformPlannedOrderItemData = append(local.R.OrderIDDataPlatformPlannedOrderItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformProductStockProductStockByOrderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformProductStockProductStockByOrderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if a == obj.OrderID {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_product_stock_product_stock_by_order_data`),
		qm.WhereIn(`data_platform_product_stock_product_stock_by_order_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_product_stock_product_stock_by_order_data")
	}

	var resultSlice []*DataPlatformProductStockProductStockByOrderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_product_stock_product_stock_by_order_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_product_stock_product_stock_by_order_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_product_stock_product_stock_by_order_data")
	}

	if singular {
		object.R.OrderIDDataPlatformProductStockProductStockByOrderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.OrderID == foreign.OrderID {
				local.R.OrderIDDataPlatformProductStockProductStockByOrderData = append(local.R.OrderIDDataPlatformProductStockProductStockByOrderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformProductionOrderHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformProductionOrderHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_header_data`),
		qm.WhereIn(`data_platform_production_order_header_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_production_order_header_data")
	}

	var resultSlice []*DataPlatformProductionOrderHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_production_order_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_production_order_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_header_data")
	}

	if singular {
		object.R.OrderIDDataPlatformProductionOrderHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformProductionOrderHeaderData = append(local.R.OrderIDDataPlatformProductionOrderHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadOrderIDDataPlatformProductionOrderItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadOrderIDDataPlatformProductionOrderItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_data`),
		qm.WhereIn(`data_platform_production_order_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_production_order_item_data")
	}

	var resultSlice []*DataPlatformProductionOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_production_order_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_production_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_data")
	}

	if singular {
		object.R.OrderIDDataPlatformProductionOrderItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.OrderID) {
				local.R.OrderIDDataPlatformProductionOrderItemData = append(local.R.OrderIDDataPlatformProductionOrderItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_purchase_requisition_header_data`),
		qm.WhereIn(`data_platform_purchase_requisition_header_data.PrecedingOrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_purchase_requisition_header_data")
	}

	var resultSlice []*DataPlatformPurchaseRequisitionHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_purchase_requisition_header_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_purchase_requisition_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_purchase_requisition_header_data")
	}

	if singular {
		object.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.PrecedingOrderID) {
				local.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData = append(local.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadFollowingOrderIDDataPlatformPurchaseRequisitionItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadFollowingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_purchase_requisition_item_data`),
		qm.WhereIn(`data_platform_purchase_requisition_item_data.FollowingOrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_purchase_requisition_item_data")
	}

	var resultSlice []*DataPlatformPurchaseRequisitionItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_purchase_requisition_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_purchase_requisition_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_purchase_requisition_item_data")
	}

	if singular {
		object.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.FollowingOrderID) {
				local.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData = append(local.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData, foreign)
				break
			}
		}
	}

	return nil
}

// LoadPrecedingOrderIDDataPlatformPurchaseRequisitionItemData allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (dataPlatformOrdersItemDatumL) LoadPrecedingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformOrdersItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformOrdersItemDatum
	var object *DataPlatformOrdersItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformOrdersItemDatum.(*DataPlatformOrdersItemDatum)
		if !ok {
			object = new(DataPlatformOrdersItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformOrdersItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformOrdersItemDatum.(*[]*DataPlatformOrdersItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformOrdersItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformOrdersItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformOrdersItemDatumR{}
		}
		args = append(args, object.OrderID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformOrdersItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.OrderID) {
					continue Outer
				}
			}

			args = append(args, obj.OrderID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_purchase_requisition_item_data`),
		qm.WhereIn(`data_platform_purchase_requisition_item_data.PrecedingOrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load data_platform_purchase_requisition_item_data")
	}

	var resultSlice []*DataPlatformPurchaseRequisitionItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice data_platform_purchase_requisition_item_data")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on data_platform_purchase_requisition_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_purchase_requisition_item_data")
	}

	if singular {
		object.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData = resultSlice
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.OrderID, foreign.PrecedingOrderID) {
				local.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData = append(local.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData, foreign)
				break
			}
		}
	}

	return nil
}

// SetBaseUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BaseUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BaseUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BaseUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetBillOfMaterialDataPlatformBillOfMaterialItemDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBillOfMaterialItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillOfMaterial, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillOfMaterial, related.BillOfMaterial)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BillOfMaterialDataPlatformBillOfMaterialItemDatum: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = related
	}

	return nil
}

// RemoveBillOfMaterialDataPlatformBillOfMaterialItemDatum relationship.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveBillOfMaterialDataPlatformBillOfMaterialItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBillOfMaterialItemDatum) error {
	var err error

	queries.SetScanner(&o.BillOfMaterial, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillOfMaterial")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillOfMaterialDataPlatformBillOfMaterialItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBillOfMaterialDataPlatformBillOfMaterialHeaderDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBillOfMaterialDataPlatformBillOfMaterialHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBillOfMaterialHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BillOfMaterial"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BillOfMaterial, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BillOfMaterial, related.BillOfMaterial)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BillOfMaterialDataPlatformBillOfMaterialHeaderDatum: related,
		}
	} else {
		o.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = related
	}

	return nil
}

// RemoveBillOfMaterialDataPlatformBillOfMaterialHeaderDatum relationship.
// Sets o.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveBillOfMaterialDataPlatformBillOfMaterialHeaderDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBillOfMaterialHeaderDatum) error {
	var err error

	queries.SetScanner(&o.BillOfMaterial, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("BillOfMaterial")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BillOfMaterialDataPlatformBillOfMaterialHeaderDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetContractDataPlatformContractItemDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ContractDataPlatformContractItemDatum to related.
func (o *DataPlatformOrdersItemDatum) SetContractDataPlatformContractItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformContractItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Contract, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Contract, related.Contract)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ContractDataPlatformContractItemDatum: related,
		}
	} else {
		o.R.ContractDataPlatformContractItemDatum = related
	}

	return nil
}

// RemoveContractDataPlatformContractItemDatum relationship.
// Sets o.R.ContractDataPlatformContractItemDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveContractDataPlatformContractItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformContractItemDatum) error {
	var err error

	queries.SetScanner(&o.Contract, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ContractDataPlatformContractItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetContractDataPlatformContractHeaderDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ContractDataPlatformContractHeaderDatum to related.
func (o *DataPlatformOrdersItemDatum) SetContractDataPlatformContractHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformContractHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Contract"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Contract, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Contract, related.Contract)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ContractDataPlatformContractHeaderDatum: related,
		}
	} else {
		o.R.ContractDataPlatformContractHeaderDatum = related
	}

	return nil
}

// RemoveContractDataPlatformContractHeaderDatum relationship.
// Sets o.R.ContractDataPlatformContractHeaderDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveContractDataPlatformContractHeaderDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformContractHeaderDatum) error {
	var err error

	queries.SetScanner(&o.Contract, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Contract")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ContractDataPlatformContractHeaderDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetCountryOfOriginLanguageDataPlatformLanguageLanguageDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum to related.
func (o *DataPlatformOrdersItemDatum) SetCountryOfOriginLanguageDataPlatformLanguageLanguageDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformLanguageLanguageDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"CountryOfOriginLanguage"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Language, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CountryOfOriginLanguage, related.Language)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			CountryOfOriginLanguageDataPlatformLanguageLanguageDatum: related,
		}
	} else {
		o.R.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum = related
	}

	return nil
}

// RemoveCountryOfOriginLanguageDataPlatformLanguageLanguageDatum relationship.
// Sets o.R.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveCountryOfOriginLanguageDataPlatformLanguageLanguageDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformLanguageLanguageDatum) error {
	var err error

	queries.SetScanner(&o.CountryOfOriginLanguage, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("CountryOfOriginLanguage")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CountryOfOriginLanguageDataPlatformLanguageLanguageDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetCountryOfOriginDataPlatformCountryCountryDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.CountryOfOriginDataPlatformCountryCountryDatum to related.
func (o *DataPlatformOrdersItemDatum) SetCountryOfOriginDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformCountryCountryDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"CountryOfOrigin"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Country, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CountryOfOrigin, related.Country)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			CountryOfOriginDataPlatformCountryCountryDatum: related,
		}
	} else {
		o.R.CountryOfOriginDataPlatformCountryCountryDatum = related
	}

	return nil
}

// RemoveCountryOfOriginDataPlatformCountryCountryDatum relationship.
// Sets o.R.CountryOfOriginDataPlatformCountryCountryDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveCountryOfOriginDataPlatformCountryCountryDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformCountryCountryDatum) error {
	var err error

	queries.SetScanner(&o.CountryOfOrigin, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("CountryOfOrigin")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CountryOfOriginDataPlatformCountryCountryDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum = related
	}

	return nil
}

// RemoveDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum relationship.
// Sets o.R.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveDeliverFromPartyDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPartyDataPlatformBatchMasterRecordBatchDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverFromPartyDataPlatformPlantStorageLocationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliverFromPartyDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// RemoveDeliverFromPartyDataPlatformPlantStorageLocationDatum relationship.
// Sets o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantStorageLocationDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromPlantTimeZone"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromPlantTimeZone, related.TimeZone)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// RemoveDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum relationship.
// Sets o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveDeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromPlantTimeZone, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromPlantTimeZone")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverToPartyDataPlatformBatchMasterRecordBatchDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliverToPartyDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverToParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliverToPartyDataPlatformBatchMasterRecordBatchDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum = related
	}

	return nil
}

// RemoveDeliverToPartyDataPlatformBatchMasterRecordBatchDatum relationship.
// Sets o.R.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveDeliverToPartyDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error

	queries.SetScanner(&o.DeliverToParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverToParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverToPartyDataPlatformBatchMasterRecordBatchDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverToPartyDataPlatformPlantStorageLocationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverToParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliverToPartyDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// RemoveDeliverToPartyDataPlatformPlantStorageLocationDatum relationship.
// Sets o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantStorageLocationDatum) error {
	var err error

	queries.SetScanner(&o.DeliverToParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverToParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToPlantTimeZone"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverToPlantTimeZone, related.TimeZone)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// RemoveDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum relationship.
// Sets o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveDeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error

	queries.SetScanner(&o.DeliverToPlantTimeZone, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverToPlantTimeZone")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverToPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformOrdersItemDatum) SetDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliveryUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliveryUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.DeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetEquipmentDataPlatformEquipmentMasterGeneralDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum to related.
func (o *DataPlatformOrdersItemDatum) SetEquipmentDataPlatformEquipmentMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformEquipmentMasterGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Equipment"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Equipment, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Equipment, related.Equipment)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			EquipmentDataPlatformEquipmentMasterGeneralDatum: related,
		}
	} else {
		o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum = related
	}

	return nil
}

// RemoveEquipmentDataPlatformEquipmentMasterGeneralDatum relationship.
// Sets o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveEquipmentDataPlatformEquipmentMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformEquipmentMasterGeneralDatum) error {
	var err error

	queries.SetScanner(&o.Equipment, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Equipment")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.EquipmentDataPlatformEquipmentMasterGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetIncoterm of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.Incoterm to related.
func (o *DataPlatformOrdersItemDatum) SetIncoterm(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Incoterms"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Incoterms, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Incoterms, related.Incoterms)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			Incoterm: related,
		}
	} else {
		o.R.Incoterm = related
	}

	return nil
}

// RemoveIncoterm relationship.
// Sets o.R.Incoterm to nil.
func (o *DataPlatformOrdersItemDatum) RemoveIncoterm(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformIncotermsIncotermsDatum) error {
	var err error

	queries.SetScanner(&o.Incoterms, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Incoterms")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Incoterm = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetInspectionLotDataPlatformInspectionLotHeaderDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.InspectionLotDataPlatformInspectionLotHeaderDatum to related.
func (o *DataPlatformOrdersItemDatum) SetInspectionLotDataPlatformInspectionLotHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformInspectionLotHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"InspectionLot"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.InspectionLot, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InspectionLot, related.InspectionLot)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			InspectionLotDataPlatformInspectionLotHeaderDatum: related,
		}
	} else {
		o.R.InspectionLotDataPlatformInspectionLotHeaderDatum = related
	}

	return nil
}

// RemoveInspectionLotDataPlatformInspectionLotHeaderDatum relationship.
// Sets o.R.InspectionLotDataPlatformInspectionLotHeaderDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveInspectionLotDataPlatformInspectionLotHeaderDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformInspectionLotHeaderDatum) error {
	var err error

	queries.SetScanner(&o.InspectionLot, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("InspectionLot")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InspectionLotDataPlatformInspectionLotHeaderDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetInspectionPlantDataPlatformPlantGeneralDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.InspectionPlantDataPlatformPlantGeneralDatum to related.
func (o *DataPlatformOrdersItemDatum) SetInspectionPlantDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"InspectionPlant"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Plant, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InspectionPlant, related.Plant)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			InspectionPlantDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.InspectionPlantDataPlatformPlantGeneralDatum = related
	}

	return nil
}

// RemoveInspectionPlantDataPlatformPlantGeneralDatum relationship.
// Sets o.R.InspectionPlantDataPlatformPlantGeneralDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveInspectionPlantDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantGeneralDatum) error {
	var err error

	queries.SetScanner(&o.InspectionPlant, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("InspectionPlant")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InspectionPlantDataPlatformPlantGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetInspectionPlanDataPlatformInspectionPlanHeaderDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.InspectionPlanDataPlatformInspectionPlanHeaderDatum to related.
func (o *DataPlatformOrdersItemDatum) SetInspectionPlanDataPlatformInspectionPlanHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformInspectionPlanHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"InspectionPlan"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.InspectionPlan, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InspectionPlan, related.InspectionPlan)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			InspectionPlanDataPlatformInspectionPlanHeaderDatum: related,
		}
	} else {
		o.R.InspectionPlanDataPlatformInspectionPlanHeaderDatum = related
	}

	return nil
}

// RemoveInspectionPlanDataPlatformInspectionPlanHeaderDatum relationship.
// Sets o.R.InspectionPlanDataPlatformInspectionPlanHeaderDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveInspectionPlanDataPlatformInspectionPlanHeaderDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformInspectionPlanHeaderDatum) error {
	var err error

	queries.SetScanner(&o.InspectionPlan, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("InspectionPlan")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InspectionPlanDataPlatformInspectionPlanHeaderDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformOrdersItemDatum) SetInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"InternalCapacityQuantityUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InternalCapacityQuantityUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// RemoveInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveInternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.InternalCapacityQuantityUnit, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("InternalCapacityQuantityUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InternalCapacityQuantityUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetPaymentMethodDataPlatformPaymentMethodPaymentMethodDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum to related.
func (o *DataPlatformOrdersItemDatum) SetPaymentMethodDataPlatformPaymentMethodPaymentMethodDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPaymentMethodPaymentMethodDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"PaymentMethod"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.PaymentMethod, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PaymentMethod = related.PaymentMethod
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum: related,
		}
	} else {
		o.R.PaymentMethodDataPlatformPaymentMethodPaymentMethodDatum = related
	}

	return nil
}

// SetProductGroupDataPlatformProductGroupProductGroupDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProductGroupDataPlatformProductGroupProductGroupDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProductGroupDataPlatformProductGroupProductGroupDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductGroupProductGroupDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductGroup"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductGroup, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductGroup, related.ProductGroup)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProductGroupDataPlatformProductGroupProductGroupDatum: related,
		}
	} else {
		o.R.ProductGroupDataPlatformProductGroupProductGroupDatum = related
	}

	return nil
}

// RemoveProductGroupDataPlatformProductGroupProductGroupDatum relationship.
// Sets o.R.ProductGroupDataPlatformProductGroupProductGroupDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProductGroupDataPlatformProductGroupProductGroupDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductGroupProductGroupDatum) error {
	var err error

	queries.SetScanner(&o.ProductGroup, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductGroup")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductGroupDataPlatformProductGroupProductGroupDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetOperationIDDataPlatformProductionOrderItemOperationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.OperationIDDataPlatformProductionOrderItemOperationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetOperationIDDataPlatformProductionOrderItemOperationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemOperationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OperationID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OperationID, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.OperationID, related.OperationID)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OperationIDDataPlatformProductionOrderItemOperationDatum: related,
		}
	} else {
		o.R.OperationIDDataPlatformProductionOrderItemOperationDatum = related
	}

	return nil
}

// RemoveOperationIDDataPlatformProductionOrderItemOperationDatum relationship.
// Sets o.R.OperationIDDataPlatformProductionOrderItemOperationDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveOperationIDDataPlatformProductionOrderItemOperationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionOrderItemOperationDatum) error {
	var err error

	queries.SetScanner(&o.OperationID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("OperationID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.OperationIDDataPlatformProductionOrderItemOperationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductionOrderDataPlatformProductionOrderItemDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionOrder, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductionOrder, related.ProductionOrder)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProductionOrderDataPlatformProductionOrderItemDatum: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = related
	}

	return nil
}

// RemoveProductionOrderDataPlatformProductionOrderItemDatum relationship.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionOrderItemDatum) error {
	var err error

	queries.SetScanner(&o.ProductionOrder, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductDataPlatformBatchMasterRecordBatchDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProductDataPlatformBatchMasterRecordBatchDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Product = related.Product
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProductDataPlatformBatchMasterRecordBatchDatum: related,
		}
	} else {
		o.R.ProductDataPlatformBatchMasterRecordBatchDatum = related
	}

	return nil
}

// SetProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionPlantTimeZone"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductionPlantTimeZone, related.TimeZone)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// RemoveProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum relationship.
// Sets o.R.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error

	queries.SetScanner(&o.ProductionPlantTimeZone, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductionPlantTimeZone")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductionPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductionVersionDataPlatformProductionVersionItemDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProductionVersionDataPlatformProductionVersionItemDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProductionVersionDataPlatformProductionVersionItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionVersionItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionVersion"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionVersion, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductionVersion, related.ProductionVersion)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProductionVersionDataPlatformProductionVersionItemDatum: related,
		}
	} else {
		o.R.ProductionVersionDataPlatformProductionVersionItemDatum = related
	}

	return nil
}

// RemoveProductionVersionDataPlatformProductionVersionItemDatum relationship.
// Sets o.R.ProductionVersionDataPlatformProductionVersionItemDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProductionVersionDataPlatformProductionVersionItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionVersionItemDatum) error {
	var err error

	queries.SetScanner(&o.ProductionVersion, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductionVersion")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductionVersionDataPlatformProductionVersionItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductWeightUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductWeightUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// RemoveProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.ProductWeightUnit, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductWeightUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductWeightUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProjectDataPlatformProjectProjectDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProjectDataPlatformProjectProjectDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProjectDataPlatformProjectProjectDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProjectProjectDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Project"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Project, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Project, related.Project)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProjectDataPlatformProjectProjectDatum: related,
		}
	} else {
		o.R.ProjectDataPlatformProjectProjectDatum = related
	}

	return nil
}

// RemoveProjectDataPlatformProjectProjectDatum relationship.
// Sets o.R.ProjectDataPlatformProjectProjectDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProjectDataPlatformProjectProjectDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProjectProjectDatum) error {
	var err error

	queries.SetScanner(&o.Project, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Project")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProjectDataPlatformProjectProjectDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryRelationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryRelationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBuyerDataPlatformSCRDeliveryRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BuyerDataPlatformSCRDeliveryRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryRelationDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRDeliveryPlantRelationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBuyerDataPlatformSCRDeliveryPlantRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRDeliveryPlantRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BuyerDataPlatformSCRDeliveryPlantRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRDeliveryPlantRelationDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRGeneralDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRGeneralDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBuyerDataPlatformSCRGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BuyerDataPlatformSCRGeneralDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRGeneralDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRProductionPlantRelationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRProductionPlantRelationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBuyerDataPlatformSCRProductionPlantRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRProductionPlantRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BuyerDataPlatformSCRProductionPlantRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRProductionPlantRelationDatum = related
	}

	return nil
}

// SetBuyerDataPlatformSCRStockConfPlantRelationDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.BuyerDataPlatformSCRStockConfPlantRelationDatum to related.
func (o *DataPlatformOrdersItemDatum) SetBuyerDataPlatformSCRStockConfPlantRelationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformSCRStockConfPlantRelationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			BuyerDataPlatformSCRStockConfPlantRelationDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformSCRStockConfPlantRelationDatum = related
	}

	return nil
}

// SetStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to related.
func (o *DataPlatformOrdersItemDatum) SetStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"StockConfirmationPlantTimeZone"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.TimeZone, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.StockConfirmationPlantTimeZone, related.TimeZone)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum: related,
		}
	} else {
		o.R.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = related
	}

	return nil
}

// RemoveStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum relationship.
// Sets o.R.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveStockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformTimeZoneTimeZoneDatum) error {
	var err error

	queries.SetScanner(&o.StockConfirmationPlantTimeZone, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("StockConfirmationPlantTimeZone")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.StockConfirmationPlantTimeZoneDataPlatformTimeZoneTimeZoneDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProjectDataPlatformProjectWBSElementDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.ProjectDataPlatformProjectWBSElementDatum to related.
func (o *DataPlatformOrdersItemDatum) SetProjectDataPlatformProjectWBSElementDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProjectWBSElementDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Project"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Project, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Project, related.Project)
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			ProjectDataPlatformProjectWBSElementDatum: related,
		}
	} else {
		o.R.ProjectDataPlatformProjectWBSElementDatum = related
	}

	return nil
}

// RemoveProjectDataPlatformProjectWBSElementDatum relationship.
// Sets o.R.ProjectDataPlatformProjectWBSElementDatum to nil.
func (o *DataPlatformOrdersItemDatum) RemoveProjectDataPlatformProjectWBSElementDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProjectWBSElementDatum) error {
	var err error

	queries.SetScanner(&o.Project, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Project")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProjectDataPlatformProjectWBSElementDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetOrderIDDataPlatformOrdersHeaderDatum of the dataPlatformOrdersItemDatum to the related item.
// Sets o.R.OrderIDDataPlatformOrdersHeaderDatum to related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformOrdersHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOrdersHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OrderID, o.OrderID, o.OrderItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OrderID = related.OrderID
	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformOrdersHeaderDatum: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersHeaderDatum = related
	}

	return nil
}

// AddOrderIDDataPlatformDeliveryDocumentHeaderData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformDeliveryDocumentHeaderData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.DeliveryDocument}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformDeliveryDocumentHeaderData: related,
		}
	} else {
		o.R.OrderIDDataPlatformDeliveryDocumentHeaderData = append(o.R.OrderIDDataPlatformDeliveryDocumentHeaderData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformDeliveryDocumentHeaderData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformDeliveryDocumentHeaderData accordingly.
// Replaces o.R.OrderIDDataPlatformDeliveryDocumentHeaderData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	query := "update `data_platform_delivery_document_header_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformDeliveryDocumentHeaderData = nil
	}

	return o.AddOrderIDDataPlatformDeliveryDocumentHeaderData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformDeliveryDocumentHeaderData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformDeliveryDocumentHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformDeliveryDocumentHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformDeliveryDocumentHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformDeliveryDocumentHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformDeliveryDocumentHeaderData[i] = o.R.OrderIDDataPlatformDeliveryDocumentHeaderData[ln-1]
			}
			o.R.OrderIDDataPlatformDeliveryDocumentHeaderData = o.R.OrderIDDataPlatformDeliveryDocumentHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderIDDataPlatformDeliveryDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformDeliveryDocumentItemData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_delivery_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformDeliveryDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.DeliveryDocument, rel.DeliveryDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformDeliveryDocumentItemData: related,
		}
	} else {
		o.R.OrderIDDataPlatformDeliveryDocumentItemData = append(o.R.OrderIDDataPlatformDeliveryDocumentItemData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformDeliveryDocumentItemData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformDeliveryDocumentItemData accordingly.
// Replaces o.R.OrderIDDataPlatformDeliveryDocumentItemData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	query := "update `data_platform_delivery_document_item_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformDeliveryDocumentItemData = nil
	}

	return o.AddOrderIDDataPlatformDeliveryDocumentItemData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformDeliveryDocumentItemData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformDeliveryDocumentItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformDeliveryDocumentItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformDeliveryDocumentItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformDeliveryDocumentItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformDeliveryDocumentItemData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformDeliveryDocumentItemData[i] = o.R.OrderIDDataPlatformDeliveryDocumentItemData[ln-1]
			}
			o.R.OrderIDDataPlatformDeliveryDocumentItemData = o.R.OrderIDDataPlatformDeliveryDocumentItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderIDDataPlatformInvoiceDocumentItemData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformInvoiceDocumentItemData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformInvoiceDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformInvoiceDocumentItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_invoice_document_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformInvoiceDocumentItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.InvoiceDocument, rel.InvoiceDocumentItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformInvoiceDocumentItemData: related,
		}
	} else {
		o.R.OrderIDDataPlatformInvoiceDocumentItemData = append(o.R.OrderIDDataPlatformInvoiceDocumentItemData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformInvoiceDocumentItemData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformInvoiceDocumentItemData accordingly.
// Replaces o.R.OrderIDDataPlatformInvoiceDocumentItemData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformInvoiceDocumentItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformInvoiceDocumentItemDatum) error {
	query := "update `data_platform_invoice_document_item_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformInvoiceDocumentItemData = nil
	}

	return o.AddOrderIDDataPlatformInvoiceDocumentItemData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformInvoiceDocumentItemData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformInvoiceDocumentItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformInvoiceDocumentItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformInvoiceDocumentItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformInvoiceDocumentItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformInvoiceDocumentItemData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformInvoiceDocumentItemData[i] = o.R.OrderIDDataPlatformInvoiceDocumentItemData[ln-1]
			}
			o.R.OrderIDDataPlatformInvoiceDocumentItemData = o.R.OrderIDDataPlatformInvoiceDocumentItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderIDDataPlatformOrdersItemDocData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformOrdersItemDocData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformOrdersItemDocData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemDocDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderID = o.OrderID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_doc_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDocDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.OrderID, rel.OrderItem, rel.DocType, rel.DocVersionID, rel.DocID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderID = o.OrderID
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformOrdersItemDocData: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemDocData = append(o.R.OrderIDDataPlatformOrdersItemDocData, related...)
	}

	return nil
}

// AddOrderIDDataPlatformOrdersItemFreightAgreementData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformOrdersItemFreightAgreementData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformOrdersItemFreightAgreementData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemFreightAgreementDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderID = o.OrderID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_freight_agreement_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemFreightAgreementDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.OrderID, rel.OrderItem, rel.OrderItemFreightAgreement}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderID = o.OrderID
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformOrdersItemFreightAgreementData: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemFreightAgreementData = append(o.R.OrderIDDataPlatformOrdersItemFreightAgreementData, related...)
	}

	return nil
}

// AddOrderIDDataPlatformOrdersItemPricingElementData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformOrdersItemPricingElementData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformOrdersItemPricingElementData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemPricingElementDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderID = o.OrderID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_pricing_element_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemPricingElementDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.OrderID, rel.OrderItem, rel.PricingProcedureCounter}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderID = o.OrderID
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformOrdersItemPricingElementData: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemPricingElementData = append(o.R.OrderIDDataPlatformOrdersItemPricingElementData, related...)
	}

	return nil
}

// AddOrderIDDataPlatformOrdersItemScheduleLineData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformOrdersItemScheduleLineData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformOrdersItemScheduleLineData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformOrdersItemScheduleLineDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderID = o.OrderID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_orders_item_schedule_line_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemScheduleLineDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.OrderID, rel.OrderItem, rel.ScheduleLine}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderID = o.OrderID
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformOrdersItemScheduleLineData: related,
		}
	} else {
		o.R.OrderIDDataPlatformOrdersItemScheduleLineData = append(o.R.OrderIDDataPlatformOrdersItemScheduleLineData, related...)
	}

	return nil
}

// AddOrderIDDataPlatformPlannedOrderHeaderData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformPlannedOrderHeaderData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformPlannedOrderHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPlannedOrderHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_planned_order_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.PlannedOrder}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformPlannedOrderHeaderData: related,
		}
	} else {
		o.R.OrderIDDataPlatformPlannedOrderHeaderData = append(o.R.OrderIDDataPlatformPlannedOrderHeaderData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformPlannedOrderHeaderData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformPlannedOrderHeaderData accordingly.
// Replaces o.R.OrderIDDataPlatformPlannedOrderHeaderData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformPlannedOrderHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPlannedOrderHeaderDatum) error {
	query := "update `data_platform_planned_order_header_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformPlannedOrderHeaderData = nil
	}

	return o.AddOrderIDDataPlatformPlannedOrderHeaderData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformPlannedOrderHeaderData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformPlannedOrderHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformPlannedOrderHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPlannedOrderHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformPlannedOrderHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformPlannedOrderHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformPlannedOrderHeaderData[i] = o.R.OrderIDDataPlatformPlannedOrderHeaderData[ln-1]
			}
			o.R.OrderIDDataPlatformPlannedOrderHeaderData = o.R.OrderIDDataPlatformPlannedOrderHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderIDDataPlatformPlannedOrderItemData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformPlannedOrderItemData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformPlannedOrderItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPlannedOrderItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_planned_order_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPlannedOrderItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.PlannedOrder, rel.PlannedOrderItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformPlannedOrderItemData: related,
		}
	} else {
		o.R.OrderIDDataPlatformPlannedOrderItemData = append(o.R.OrderIDDataPlatformPlannedOrderItemData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformPlannedOrderItemData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformPlannedOrderItemData accordingly.
// Replaces o.R.OrderIDDataPlatformPlannedOrderItemData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformPlannedOrderItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPlannedOrderItemDatum) error {
	query := "update `data_platform_planned_order_item_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformPlannedOrderItemData = nil
	}

	return o.AddOrderIDDataPlatformPlannedOrderItemData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformPlannedOrderItemData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformPlannedOrderItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformPlannedOrderItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPlannedOrderItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformPlannedOrderItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformPlannedOrderItemData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformPlannedOrderItemData[i] = o.R.OrderIDDataPlatformPlannedOrderItemData[ln-1]
			}
			o.R.OrderIDDataPlatformPlannedOrderItemData = o.R.OrderIDDataPlatformPlannedOrderItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderIDDataPlatformProductStockProductStockByOrderData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformProductStockProductStockByOrderData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformProductStockProductStockByOrderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductStockProductStockByOrderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.OrderID = o.OrderID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_product_stock_product_stock_by_order_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductStockProductStockByOrderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.Product, rel.OrderID, rel.OrderItem, rel.SupplyChainRelationshipID, rel.SupplyChainRelationshipDeliveryID, rel.SupplyChainRelationshipDeliveryPlantID, rel.Buyer, rel.Seller, rel.DeliverToParty, rel.DeliverFromParty, rel.DeliverToPlant, rel.DeliverFromPlant, rel.InventoryStockType}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.OrderID = o.OrderID
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformProductStockProductStockByOrderData: related,
		}
	} else {
		o.R.OrderIDDataPlatformProductStockProductStockByOrderData = append(o.R.OrderIDDataPlatformProductStockProductStockByOrderData, related...)
	}

	return nil
}

// AddOrderIDDataPlatformProductionOrderHeaderData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformProductionOrderHeaderData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformProductionOrderHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_production_order_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.ProductionOrder}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformProductionOrderHeaderData: related,
		}
	} else {
		o.R.OrderIDDataPlatformProductionOrderHeaderData = append(o.R.OrderIDDataPlatformProductionOrderHeaderData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformProductionOrderHeaderData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformProductionOrderHeaderData accordingly.
// Replaces o.R.OrderIDDataPlatformProductionOrderHeaderData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformProductionOrderHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderHeaderDatum) error {
	query := "update `data_platform_production_order_header_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformProductionOrderHeaderData = nil
	}

	return o.AddOrderIDDataPlatformProductionOrderHeaderData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformProductionOrderHeaderData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformProductionOrderHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformProductionOrderHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformProductionOrderHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformProductionOrderHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformProductionOrderHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformProductionOrderHeaderData[i] = o.R.OrderIDDataPlatformProductionOrderHeaderData[ln-1]
			}
			o.R.OrderIDDataPlatformProductionOrderHeaderData = o.R.OrderIDDataPlatformProductionOrderHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddOrderIDDataPlatformProductionOrderItemData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.OrderIDDataPlatformProductionOrderItemData.
func (o *DataPlatformOrdersItemDatum) AddOrderIDDataPlatformProductionOrderItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.OrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_production_order_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"OrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformProductionOrderItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.ProductionOrder, rel.ProductionOrderItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.OrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			OrderIDDataPlatformProductionOrderItemData: related,
		}
	} else {
		o.R.OrderIDDataPlatformProductionOrderItemData = append(o.R.OrderIDDataPlatformProductionOrderItemData, related...)
	}

	return nil
}

// SetOrderIDDataPlatformProductionOrderItemData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.OrderIDDataPlatformOrdersItemDatum's OrderIDDataPlatformProductionOrderItemData accordingly.
// Replaces o.R.OrderIDDataPlatformProductionOrderItemData with related.
func (o *DataPlatformOrdersItemDatum) SetOrderIDDataPlatformProductionOrderItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformProductionOrderItemDatum) error {
	query := "update `data_platform_production_order_item_data` set `OrderID` = null where `OrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.OrderIDDataPlatformProductionOrderItemData = nil
	}

	return o.AddOrderIDDataPlatformProductionOrderItemData(ctx, exec, insert, related...)
}

// RemoveOrderIDDataPlatformProductionOrderItemData relationships from objects passed in.
// Removes related items from R.OrderIDDataPlatformProductionOrderItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveOrderIDDataPlatformProductionOrderItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformProductionOrderItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.OrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("OrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OrderIDDataPlatformProductionOrderItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.OrderIDDataPlatformProductionOrderItemData)
			if ln > 1 && i < ln-1 {
				o.R.OrderIDDataPlatformProductionOrderItemData[i] = o.R.OrderIDDataPlatformProductionOrderItemData[ln-1]
			}
			o.R.OrderIDDataPlatformProductionOrderItemData = o.R.OrderIDDataPlatformProductionOrderItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData.
func (o *DataPlatformOrdersItemDatum) AddPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionHeaderDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PrecedingOrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_purchase_requisition_header_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"PrecedingOrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionHeaderDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.PurchaseRequisition}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PrecedingOrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData: related,
		}
	} else {
		o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData = append(o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData, related...)
	}

	return nil
}

// SetPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.PrecedingOrderIDDataPlatformOrdersItemDatum's PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData accordingly.
// Replaces o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData with related.
func (o *DataPlatformOrdersItemDatum) SetPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionHeaderDatum) error {
	query := "update `data_platform_purchase_requisition_header_data` set `PrecedingOrderID` = null where `PrecedingOrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData = nil
	}

	return o.AddPrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData(ctx, exec, insert, related...)
}

// RemovePrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData relationships from objects passed in.
// Removes related items from R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemovePrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPurchaseRequisitionHeaderDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PrecedingOrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("PrecedingOrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData {
			if rel != ri {
				continue
			}

			ln := len(o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData)
			if ln > 1 && i < ln-1 {
				o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData[i] = o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData[ln-1]
			}
			o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData = o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionHeaderData[:ln-1]
			break
		}
	}

	return nil
}

// AddFollowingOrderIDDataPlatformPurchaseRequisitionItemData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData.
func (o *DataPlatformOrdersItemDatum) AddFollowingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FollowingOrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"FollowingOrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.PurchaseRequisition, rel.PurchaseRequisitionItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FollowingOrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			FollowingOrderIDDataPlatformPurchaseRequisitionItemData: related,
		}
	} else {
		o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData = append(o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData, related...)
	}

	return nil
}

// SetFollowingOrderIDDataPlatformPurchaseRequisitionItemData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FollowingOrderIDDataPlatformOrdersItemDatum's FollowingOrderIDDataPlatformPurchaseRequisitionItemData accordingly.
// Replaces o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData with related.
func (o *DataPlatformOrdersItemDatum) SetFollowingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	query := "update `data_platform_purchase_requisition_item_data` set `FollowingOrderID` = null where `FollowingOrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData = nil
	}

	return o.AddFollowingOrderIDDataPlatformPurchaseRequisitionItemData(ctx, exec, insert, related...)
}

// RemoveFollowingOrderIDDataPlatformPurchaseRequisitionItemData relationships from objects passed in.
// Removes related items from R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemoveFollowingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FollowingOrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("FollowingOrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData)
			if ln > 1 && i < ln-1 {
				o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData[i] = o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData[ln-1]
			}
			o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData = o.R.FollowingOrderIDDataPlatformPurchaseRequisitionItemData[:ln-1]
			break
		}
	}

	return nil
}

// AddPrecedingOrderIDDataPlatformPurchaseRequisitionItemData adds the given related objects to the existing relationships
// of the data_platform_orders_item_datum, optionally inserting them as new records.
// Appends related to o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData.
func (o *DataPlatformOrdersItemDatum) AddPrecedingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PrecedingOrderID, o.OrderID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"PrecedingOrderID"}),
				strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
			)
			values := []interface{}{o.OrderID, rel.PurchaseRequisition, rel.PurchaseRequisitionItem}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PrecedingOrderID, o.OrderID)
		}
	}

	if o.R == nil {
		o.R = &dataPlatformOrdersItemDatumR{
			PrecedingOrderIDDataPlatformPurchaseRequisitionItemData: related,
		}
	} else {
		o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData = append(o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData, related...)
	}

	return nil
}

// SetPrecedingOrderIDDataPlatformPurchaseRequisitionItemData removes all previously related items of the
// data_platform_orders_item_datum replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.PrecedingOrderIDDataPlatformOrdersItemDatum's PrecedingOrderIDDataPlatformPurchaseRequisitionItemData accordingly.
// Replaces o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData with related.
func (o *DataPlatformOrdersItemDatum) SetPrecedingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	query := "update `data_platform_purchase_requisition_item_data` set `PrecedingOrderID` = null where `PrecedingOrderID` = ?"
	values := []interface{}{o.OrderID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData = nil
	}

	return o.AddPrecedingOrderIDDataPlatformPurchaseRequisitionItemData(ctx, exec, insert, related...)
}

// RemovePrecedingOrderIDDataPlatformPurchaseRequisitionItemData relationships from objects passed in.
// Removes related items from R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData (uses pointer comparison, removal does not keep order)
func (o *DataPlatformOrdersItemDatum) RemovePrecedingOrderIDDataPlatformPurchaseRequisitionItemData(ctx context.Context, exec boil.ContextExecutor, related ...*DataPlatformPurchaseRequisitionItemDatum) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PrecedingOrderID, nil)
		if err = rel.Update(ctx, exec, boil.Whitelist("PrecedingOrderID")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData {
			if rel != ri {
				continue
			}

			ln := len(o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData)
			if ln > 1 && i < ln-1 {
				o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData[i] = o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData[ln-1]
			}
			o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData = o.R.PrecedingOrderIDDataPlatformPurchaseRequisitionItemData[:ln-1]
			break
		}
	}

	return nil
}

// DataPlatformOrdersItemData retrieves all the records using an executor.
func DataPlatformOrdersItemData(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	mods = append(mods, qm.From("`data_platform_orders_item_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_orders_item_data`.*"})
	}

	return dataPlatformOrdersItemDatumQuery{q}
}

// FindDataPlatformOrdersItemDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, orderID int, orderItem int, selectCols ...string) (*DataPlatformOrdersItemDatum, error) {
	dataPlatformOrdersItemDatumObj := &DataPlatformOrdersItemDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_orders_item_data` where `OrderID`=? AND `OrderItem`=?", sel,
	)

	q := queries.Raw(query, orderID, orderItem)

	err := q.Bind(ctx, exec, dataPlatformOrdersItemDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_orders_item_data")
	}

	return dataPlatformOrdersItemDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformOrdersItemDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_orders_item_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformOrdersItemDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformOrdersItemDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformOrdersItemDatumInsertCache[key]
	dataPlatformOrdersItemDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformOrdersItemDatumAllColumns,
			dataPlatformOrdersItemDatumColumnsWithDefault,
			dataPlatformOrdersItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_orders_item_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_orders_item_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_orders_item_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_orders_item_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.OrderID,
		o.OrderItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_orders_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformOrdersItemDatumInsertCacheMut.Lock()
		dataPlatformOrdersItemDatumInsertCache[key] = cache
		dataPlatformOrdersItemDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformOrdersItemDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformOrdersItemDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformOrdersItemDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformOrdersItemDatumUpdateCache[key]
	dataPlatformOrdersItemDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformOrdersItemDatumAllColumns,
			dataPlatformOrdersItemDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_orders_item_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformOrdersItemDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, append(wl, dataPlatformOrdersItemDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_orders_item_data row")
	}

	if !cached {
		dataPlatformOrdersItemDatumUpdateCacheMut.Lock()
		dataPlatformOrdersItemDatumUpdateCache[key] = cache
		dataPlatformOrdersItemDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformOrdersItemDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_orders_item_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformOrdersItemDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformOrdersItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_orders_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformOrdersItemDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformOrdersItemDatum slice")
	}

	return nil
}

var mySQLDataPlatformOrdersItemDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformOrdersItemDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_orders_item_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformOrdersItemDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformOrdersItemDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformOrdersItemDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformOrdersItemDatumUpsertCache[key]
	dataPlatformOrdersItemDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformOrdersItemDatumAllColumns,
			dataPlatformOrdersItemDatumColumnsWithDefault,
			dataPlatformOrdersItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformOrdersItemDatumAllColumns,
			dataPlatformOrdersItemDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_orders_item_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_orders_item_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_orders_item_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_orders_item_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformOrdersItemDatumType, dataPlatformOrdersItemDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_orders_item_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_orders_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformOrdersItemDatumUpsertCacheMut.Lock()
		dataPlatformOrdersItemDatumUpsertCache[key] = cache
		dataPlatformOrdersItemDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformOrdersItemDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformOrdersItemDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformOrdersItemDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformOrdersItemDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_orders_item_data` WHERE `OrderID`=? AND `OrderItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_orders_item_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformOrdersItemDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformOrdersItemDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_orders_item_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformOrdersItemDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformOrdersItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_orders_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformOrdersItemDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformOrdersItemDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformOrdersItemDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformOrdersItemDatum(ctx, exec, o.OrderID, o.OrderItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformOrdersItemDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformOrdersItemDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformOrdersItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_orders_item_data`.* FROM `data_platform_orders_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformOrdersItemDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformOrdersItemDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformOrdersItemDatumExists checks if the DataPlatformOrdersItemDatum row exists.
func DataPlatformOrdersItemDatumExists(ctx context.Context, exec boil.ContextExecutor, orderID int, orderItem int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_orders_item_data` where `OrderID`=? AND `OrderItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, orderID, orderItem)
	}
	row := exec.QueryRowContext(ctx, sql, orderID, orderItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_orders_item_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformOrdersItemDatum row exists.
func (o *DataPlatformOrdersItemDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformOrdersItemDatumExists(ctx, exec, o.OrderID, o.OrderItem)
}
