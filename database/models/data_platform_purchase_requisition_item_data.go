// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformPurchaseRequisitionItemDatum is an object representing the database table.
type DataPlatformPurchaseRequisitionItemDatum struct {
	PurchaseRequisition                      int          `boil:"PurchaseRequisition" json:"PurchaseRequisition" toml:"PurchaseRequisition" yaml:"PurchaseRequisition"`
	PurchaseRequisitionItem                  int          `boil:"PurchaseRequisitionItem" json:"PurchaseRequisitionItem" toml:"PurchaseRequisitionItem" yaml:"PurchaseRequisitionItem"`
	PurchaseRequisitionItemCategory          string       `boil:"PurchaseRequisitionItemCategory" json:"PurchaseRequisitionItemCategory" toml:"PurchaseRequisitionItemCategory" yaml:"PurchaseRequisitionItemCategory"`
	SupplyChainRelationshipID                null.Int     `boil:"SupplyChainRelationshipID" json:"SupplyChainRelationshipID,omitempty" toml:"SupplyChainRelationshipID" yaml:"SupplyChainRelationshipID,omitempty"`
	SupplyChainRelationshipDeliveryID        null.Int     `boil:"SupplyChainRelationshipDeliveryID" json:"SupplyChainRelationshipDeliveryID,omitempty" toml:"SupplyChainRelationshipDeliveryID" yaml:"SupplyChainRelationshipDeliveryID,omitempty"`
	SupplyChainRelationshipDeliveryPlantID   null.Int     `boil:"SupplyChainRelationshipDeliveryPlantID" json:"SupplyChainRelationshipDeliveryPlantID,omitempty" toml:"SupplyChainRelationshipDeliveryPlantID" yaml:"SupplyChainRelationshipDeliveryPlantID,omitempty"`
	SupplyChainRelationshipStockConfPlantID  null.Int     `boil:"SupplyChainRelationshipStockConfPlantID" json:"SupplyChainRelationshipStockConfPlantID,omitempty" toml:"SupplyChainRelationshipStockConfPlantID" yaml:"SupplyChainRelationshipStockConfPlantID,omitempty"`
	SupplyChainRelationshipProductionPlantID null.Int     `boil:"SupplyChainRelationshipProductionPlantID" json:"SupplyChainRelationshipProductionPlantID,omitempty" toml:"SupplyChainRelationshipProductionPlantID" yaml:"SupplyChainRelationshipProductionPlantID,omitempty"`
	Buyer                                    int          `boil:"Buyer" json:"Buyer" toml:"Buyer" yaml:"Buyer"`
	Seller                                   null.Int     `boil:"Seller" json:"Seller,omitempty" toml:"Seller" yaml:"Seller,omitempty"`
	DeliverToParty                           int          `boil:"DeliverToParty" json:"DeliverToParty" toml:"DeliverToParty" yaml:"DeliverToParty"`
	DeliverFromParty                         null.Int     `boil:"DeliverFromParty" json:"DeliverFromParty,omitempty" toml:"DeliverFromParty" yaml:"DeliverFromParty,omitempty"`
	DeliverToPlant                           string       `boil:"DeliverToPlant" json:"DeliverToPlant" toml:"DeliverToPlant" yaml:"DeliverToPlant"`
	DeliverToPlantStorageLocation            null.String  `boil:"DeliverToPlantStorageLocation" json:"DeliverToPlantStorageLocation,omitempty" toml:"DeliverToPlantStorageLocation" yaml:"DeliverToPlantStorageLocation,omitempty"`
	DeliverFromPlant                         null.String  `boil:"DeliverFromPlant" json:"DeliverFromPlant,omitempty" toml:"DeliverFromPlant" yaml:"DeliverFromPlant,omitempty"`
	DeliverFromPlantStorageLocation          null.String  `boil:"DeliverFromPlantStorageLocation" json:"DeliverFromPlantStorageLocation,omitempty" toml:"DeliverFromPlantStorageLocation" yaml:"DeliverFromPlantStorageLocation,omitempty"`
	Product                                  string       `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	ProductGroup                             null.String  `boil:"ProductGroup" json:"ProductGroup,omitempty" toml:"ProductGroup" yaml:"ProductGroup,omitempty"`
	RequestedQuantityInBaseUnit              float32      `boil:"RequestedQuantityInBaseUnit" json:"RequestedQuantityInBaseUnit" toml:"RequestedQuantityInBaseUnit" yaml:"RequestedQuantityInBaseUnit"`
	RequestedQuantityInDeliveryUnit          float32      `boil:"RequestedQuantityInDeliveryUnit" json:"RequestedQuantityInDeliveryUnit" toml:"RequestedQuantityInDeliveryUnit" yaml:"RequestedQuantityInDeliveryUnit"`
	BaseUnit                                 string       `boil:"BaseUnit" json:"BaseUnit" toml:"BaseUnit" yaml:"BaseUnit"`
	DeliveryUnit                             string       `boil:"DeliveryUnit" json:"DeliveryUnit" toml:"DeliveryUnit" yaml:"DeliveryUnit"`
	RequestedDeliveryDate                    string       `boil:"RequestedDeliveryDate" json:"RequestedDeliveryDate" toml:"RequestedDeliveryDate" yaml:"RequestedDeliveryDate"`
	PlannedOrder                             null.Int     `boil:"PlannedOrder" json:"PlannedOrder,omitempty" toml:"PlannedOrder" yaml:"PlannedOrder,omitempty"`
	PlannedOrderItem                         null.Int     `boil:"PlannedOrderItem" json:"PlannedOrderItem,omitempty" toml:"PlannedOrderItem" yaml:"PlannedOrderItem,omitempty"`
	ProductionOrder                          null.Int     `boil:"ProductionOrder" json:"ProductionOrder,omitempty" toml:"ProductionOrder" yaml:"ProductionOrder,omitempty"`
	ProductionOrderItem                      null.Int     `boil:"ProductionOrderItem" json:"ProductionOrderItem,omitempty" toml:"ProductionOrderItem" yaml:"ProductionOrderItem,omitempty"`
	PrecedingOrderID                         null.Int     `boil:"PrecedingOrderID" json:"PrecedingOrderID,omitempty" toml:"PrecedingOrderID" yaml:"PrecedingOrderID,omitempty"`
	PrecedingOrderItem                       null.Int     `boil:"PrecedingOrderItem" json:"PrecedingOrderItem,omitempty" toml:"PrecedingOrderItem" yaml:"PrecedingOrderItem,omitempty"`
	FollowingOrderID                         null.Int     `boil:"FollowingOrderID" json:"FollowingOrderID,omitempty" toml:"FollowingOrderID" yaml:"FollowingOrderID,omitempty"`
	FollowingOrderItem                       null.Int     `boil:"FollowingOrderItem" json:"FollowingOrderItem,omitempty" toml:"FollowingOrderItem" yaml:"FollowingOrderItem,omitempty"`
	Project                                  null.Int     `boil:"Project" json:"Project,omitempty" toml:"Project" yaml:"Project,omitempty"`
	WBSElement                               null.Int     `boil:"WBSElement" json:"WBSElement,omitempty" toml:"WBSElement" yaml:"WBSElement,omitempty"`
	PurchaseRequisitionItemText              null.String  `boil:"PurchaseRequisitionItemText" json:"PurchaseRequisitionItemText,omitempty" toml:"PurchaseRequisitionItemText" yaml:"PurchaseRequisitionItemText,omitempty"`
	PurchaseRequisitionItemTextByBuyer       null.String  `boil:"PurchaseRequisitionItemTextByBuyer" json:"PurchaseRequisitionItemTextByBuyer,omitempty" toml:"PurchaseRequisitionItemTextByBuyer" yaml:"PurchaseRequisitionItemTextByBuyer,omitempty"`
	PurchaseRequisitionItemTextBySeller      null.String  `boil:"PurchaseRequisitionItemTextBySeller" json:"PurchaseRequisitionItemTextBySeller,omitempty" toml:"PurchaseRequisitionItemTextBySeller" yaml:"PurchaseRequisitionItemTextBySeller,omitempty"`
	PurchaseRequisitionItemPrice             null.Float32 `boil:"PurchaseRequisitionItemPrice" json:"PurchaseRequisitionItemPrice,omitempty" toml:"PurchaseRequisitionItemPrice" yaml:"PurchaseRequisitionItemPrice,omitempty"`
	PurchaseRequisitionItemPriceQuantity     null.Int     `boil:"PurchaseRequisitionItemPriceQuantity" json:"PurchaseRequisitionItemPriceQuantity,omitempty" toml:"PurchaseRequisitionItemPriceQuantity" yaml:"PurchaseRequisitionItemPriceQuantity,omitempty"`
	ProductPlannedDeliveryDuration           null.Float32 `boil:"ProductPlannedDeliveryDuration" json:"ProductPlannedDeliveryDuration,omitempty" toml:"ProductPlannedDeliveryDuration" yaml:"ProductPlannedDeliveryDuration,omitempty"`
	ProductPlannedDeliveryDurationUnit       null.String  `boil:"ProductPlannedDeliveryDurationUnit" json:"ProductPlannedDeliveryDurationUnit,omitempty" toml:"ProductPlannedDeliveryDurationUnit" yaml:"ProductPlannedDeliveryDurationUnit,omitempty"`
	OrderedQuantityInBaseUnit                null.Float32 `boil:"OrderedQuantityInBaseUnit" json:"OrderedQuantityInBaseUnit,omitempty" toml:"OrderedQuantityInBaseUnit" yaml:"OrderedQuantityInBaseUnit,omitempty"`
	OrderedQuantityInDeliveryUnit            null.Float32 `boil:"OrderedQuantityInDeliveryUnit" json:"OrderedQuantityInDeliveryUnit,omitempty" toml:"OrderedQuantityInDeliveryUnit" yaml:"OrderedQuantityInDeliveryUnit,omitempty"`
	ItemCompleteOrderIsDefined               null.Bool    `boil:"ItemCompleteOrderIsDefined" json:"ItemCompleteOrderIsDefined,omitempty" toml:"ItemCompleteOrderIsDefined" yaml:"ItemCompleteOrderIsDefined,omitempty"`
	TransactionCurrency                      null.String  `boil:"TransactionCurrency" json:"TransactionCurrency,omitempty" toml:"TransactionCurrency" yaml:"TransactionCurrency,omitempty"`
	MRPArea                                  null.String  `boil:"MRPArea" json:"MRPArea,omitempty" toml:"MRPArea" yaml:"MRPArea,omitempty"`
	MRPController                            null.String  `boil:"MRPController" json:"MRPController,omitempty" toml:"MRPController" yaml:"MRPController,omitempty"`
	StockConfirmationBusinessPartner         null.Int     `boil:"StockConfirmationBusinessPartner" json:"StockConfirmationBusinessPartner,omitempty" toml:"StockConfirmationBusinessPartner" yaml:"StockConfirmationBusinessPartner,omitempty"`
	StockConfirmationPlant                   null.String  `boil:"StockConfirmationPlant" json:"StockConfirmationPlant,omitempty" toml:"StockConfirmationPlant" yaml:"StockConfirmationPlant,omitempty"`
	ProductionPlantBusinessPartner           null.Int     `boil:"ProductionPlantBusinessPartner" json:"ProductionPlantBusinessPartner,omitempty" toml:"ProductionPlantBusinessPartner" yaml:"ProductionPlantBusinessPartner,omitempty"`
	ProductionPlant                          null.String  `boil:"ProductionPlant" json:"ProductionPlant,omitempty" toml:"ProductionPlant" yaml:"ProductionPlant,omitempty"`
	GLAccount                                null.String  `boil:"GLAccount" json:"GLAccount,omitempty" toml:"GLAccount" yaml:"GLAccount,omitempty"`
	CreationDate                             string       `boil:"CreationDate" json:"CreationDate" toml:"CreationDate" yaml:"CreationDate"`
	CreationTime                             string       `boil:"CreationTime" json:"CreationTime" toml:"CreationTime" yaml:"CreationTime"`
	LastChangeDate                           string       `boil:"LastChangeDate" json:"LastChangeDate" toml:"LastChangeDate" yaml:"LastChangeDate"`
	LastChangeTime                           string       `boil:"LastChangeTime" json:"LastChangeTime" toml:"LastChangeTime" yaml:"LastChangeTime"`
	IsReleased                               null.Bool    `boil:"IsReleased" json:"IsReleased,omitempty" toml:"IsReleased" yaml:"IsReleased,omitempty"`
	IsCancelled                              null.Bool    `boil:"IsCancelled" json:"IsCancelled,omitempty" toml:"IsCancelled" yaml:"IsCancelled,omitempty"`
	IsMarkedForDeletion                      null.Bool    `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`
	IssuingPlant                             string       `boil:"IssuingPlant" json:"IssuingPlant" toml:"IssuingPlant" yaml:"IssuingPlant"`
	IssuingPlantStorageLocation              string       `boil:"IssuingPlantStorageLocation" json:"IssuingPlantStorageLocation" toml:"IssuingPlantStorageLocation" yaml:"IssuingPlantStorageLocation"`
	ReceivingPlant                           string       `boil:"ReceivingPlant" json:"ReceivingPlant" toml:"ReceivingPlant" yaml:"ReceivingPlant"`
	ReceivingPlantStorageLocation            string       `boil:"ReceivingPlantStorageLocation" json:"ReceivingPlantStorageLocation" toml:"ReceivingPlantStorageLocation" yaml:"ReceivingPlantStorageLocation"`
	StockConfirmationPartnerFunction         string       `boil:"StockConfirmationPartnerFunction" json:"StockConfirmationPartnerFunction" toml:"StockConfirmationPartnerFunction" yaml:"StockConfirmationPartnerFunction"`
	StockConfirmationPlantBatch              string       `boil:"StockConfirmationPlantBatch" json:"StockConfirmationPlantBatch" toml:"StockConfirmationPlantBatch" yaml:"StockConfirmationPlantBatch"`

	R *dataPlatformPurchaseRequisitionItemDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformPurchaseRequisitionItemDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformPurchaseRequisitionItemDatumColumns = struct {
	PurchaseRequisition                      string
	PurchaseRequisitionItem                  string
	PurchaseRequisitionItemCategory          string
	SupplyChainRelationshipID                string
	SupplyChainRelationshipDeliveryID        string
	SupplyChainRelationshipDeliveryPlantID   string
	SupplyChainRelationshipStockConfPlantID  string
	SupplyChainRelationshipProductionPlantID string
	Buyer                                    string
	Seller                                   string
	DeliverToParty                           string
	DeliverFromParty                         string
	DeliverToPlant                           string
	DeliverToPlantStorageLocation            string
	DeliverFromPlant                         string
	DeliverFromPlantStorageLocation          string
	Product                                  string
	ProductGroup                             string
	RequestedQuantityInBaseUnit              string
	RequestedQuantityInDeliveryUnit          string
	BaseUnit                                 string
	DeliveryUnit                             string
	RequestedDeliveryDate                    string
	PlannedOrder                             string
	PlannedOrderItem                         string
	ProductionOrder                          string
	ProductionOrderItem                      string
	PrecedingOrderID                         string
	PrecedingOrderItem                       string
	FollowingOrderID                         string
	FollowingOrderItem                       string
	Project                                  string
	WBSElement                               string
	PurchaseRequisitionItemText              string
	PurchaseRequisitionItemTextByBuyer       string
	PurchaseRequisitionItemTextBySeller      string
	PurchaseRequisitionItemPrice             string
	PurchaseRequisitionItemPriceQuantity     string
	ProductPlannedDeliveryDuration           string
	ProductPlannedDeliveryDurationUnit       string
	OrderedQuantityInBaseUnit                string
	OrderedQuantityInDeliveryUnit            string
	ItemCompleteOrderIsDefined               string
	TransactionCurrency                      string
	MRPArea                                  string
	MRPController                            string
	StockConfirmationBusinessPartner         string
	StockConfirmationPlant                   string
	ProductionPlantBusinessPartner           string
	ProductionPlant                          string
	GLAccount                                string
	CreationDate                             string
	CreationTime                             string
	LastChangeDate                           string
	LastChangeTime                           string
	IsReleased                               string
	IsCancelled                              string
	IsMarkedForDeletion                      string
	IssuingPlant                             string
	IssuingPlantStorageLocation              string
	ReceivingPlant                           string
	ReceivingPlantStorageLocation            string
	StockConfirmationPartnerFunction         string
	StockConfirmationPlantBatch              string
}{
	PurchaseRequisition:                      "PurchaseRequisition",
	PurchaseRequisitionItem:                  "PurchaseRequisitionItem",
	PurchaseRequisitionItemCategory:          "PurchaseRequisitionItemCategory",
	SupplyChainRelationshipID:                "SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:        "SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:   "SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipStockConfPlantID:  "SupplyChainRelationshipStockConfPlantID",
	SupplyChainRelationshipProductionPlantID: "SupplyChainRelationshipProductionPlantID",
	Buyer:                                    "Buyer",
	Seller:                                   "Seller",
	DeliverToParty:                           "DeliverToParty",
	DeliverFromParty:                         "DeliverFromParty",
	DeliverToPlant:                           "DeliverToPlant",
	DeliverToPlantStorageLocation:            "DeliverToPlantStorageLocation",
	DeliverFromPlant:                         "DeliverFromPlant",
	DeliverFromPlantStorageLocation:          "DeliverFromPlantStorageLocation",
	Product:                                  "Product",
	ProductGroup:                             "ProductGroup",
	RequestedQuantityInBaseUnit:              "RequestedQuantityInBaseUnit",
	RequestedQuantityInDeliveryUnit:          "RequestedQuantityInDeliveryUnit",
	BaseUnit:                                 "BaseUnit",
	DeliveryUnit:                             "DeliveryUnit",
	RequestedDeliveryDate:                    "RequestedDeliveryDate",
	PlannedOrder:                             "PlannedOrder",
	PlannedOrderItem:                         "PlannedOrderItem",
	ProductionOrder:                          "ProductionOrder",
	ProductionOrderItem:                      "ProductionOrderItem",
	PrecedingOrderID:                         "PrecedingOrderID",
	PrecedingOrderItem:                       "PrecedingOrderItem",
	FollowingOrderID:                         "FollowingOrderID",
	FollowingOrderItem:                       "FollowingOrderItem",
	Project:                                  "Project",
	WBSElement:                               "WBSElement",
	PurchaseRequisitionItemText:              "PurchaseRequisitionItemText",
	PurchaseRequisitionItemTextByBuyer:       "PurchaseRequisitionItemTextByBuyer",
	PurchaseRequisitionItemTextBySeller:      "PurchaseRequisitionItemTextBySeller",
	PurchaseRequisitionItemPrice:             "PurchaseRequisitionItemPrice",
	PurchaseRequisitionItemPriceQuantity:     "PurchaseRequisitionItemPriceQuantity",
	ProductPlannedDeliveryDuration:           "ProductPlannedDeliveryDuration",
	ProductPlannedDeliveryDurationUnit:       "ProductPlannedDeliveryDurationUnit",
	OrderedQuantityInBaseUnit:                "OrderedQuantityInBaseUnit",
	OrderedQuantityInDeliveryUnit:            "OrderedQuantityInDeliveryUnit",
	ItemCompleteOrderIsDefined:               "ItemCompleteOrderIsDefined",
	TransactionCurrency:                      "TransactionCurrency",
	MRPArea:                                  "MRPArea",
	MRPController:                            "MRPController",
	StockConfirmationBusinessPartner:         "StockConfirmationBusinessPartner",
	StockConfirmationPlant:                   "StockConfirmationPlant",
	ProductionPlantBusinessPartner:           "ProductionPlantBusinessPartner",
	ProductionPlant:                          "ProductionPlant",
	GLAccount:                                "GLAccount",
	CreationDate:                             "CreationDate",
	CreationTime:                             "CreationTime",
	LastChangeDate:                           "LastChangeDate",
	LastChangeTime:                           "LastChangeTime",
	IsReleased:                               "IsReleased",
	IsCancelled:                              "IsCancelled",
	IsMarkedForDeletion:                      "IsMarkedForDeletion",
	IssuingPlant:                             "IssuingPlant",
	IssuingPlantStorageLocation:              "IssuingPlantStorageLocation",
	ReceivingPlant:                           "ReceivingPlant",
	ReceivingPlantStorageLocation:            "ReceivingPlantStorageLocation",
	StockConfirmationPartnerFunction:         "StockConfirmationPartnerFunction",
	StockConfirmationPlantBatch:              "StockConfirmationPlantBatch",
}

var DataPlatformPurchaseRequisitionItemDatumTableColumns = struct {
	PurchaseRequisition                      string
	PurchaseRequisitionItem                  string
	PurchaseRequisitionItemCategory          string
	SupplyChainRelationshipID                string
	SupplyChainRelationshipDeliveryID        string
	SupplyChainRelationshipDeliveryPlantID   string
	SupplyChainRelationshipStockConfPlantID  string
	SupplyChainRelationshipProductionPlantID string
	Buyer                                    string
	Seller                                   string
	DeliverToParty                           string
	DeliverFromParty                         string
	DeliverToPlant                           string
	DeliverToPlantStorageLocation            string
	DeliverFromPlant                         string
	DeliverFromPlantStorageLocation          string
	Product                                  string
	ProductGroup                             string
	RequestedQuantityInBaseUnit              string
	RequestedQuantityInDeliveryUnit          string
	BaseUnit                                 string
	DeliveryUnit                             string
	RequestedDeliveryDate                    string
	PlannedOrder                             string
	PlannedOrderItem                         string
	ProductionOrder                          string
	ProductionOrderItem                      string
	PrecedingOrderID                         string
	PrecedingOrderItem                       string
	FollowingOrderID                         string
	FollowingOrderItem                       string
	Project                                  string
	WBSElement                               string
	PurchaseRequisitionItemText              string
	PurchaseRequisitionItemTextByBuyer       string
	PurchaseRequisitionItemTextBySeller      string
	PurchaseRequisitionItemPrice             string
	PurchaseRequisitionItemPriceQuantity     string
	ProductPlannedDeliveryDuration           string
	ProductPlannedDeliveryDurationUnit       string
	OrderedQuantityInBaseUnit                string
	OrderedQuantityInDeliveryUnit            string
	ItemCompleteOrderIsDefined               string
	TransactionCurrency                      string
	MRPArea                                  string
	MRPController                            string
	StockConfirmationBusinessPartner         string
	StockConfirmationPlant                   string
	ProductionPlantBusinessPartner           string
	ProductionPlant                          string
	GLAccount                                string
	CreationDate                             string
	CreationTime                             string
	LastChangeDate                           string
	LastChangeTime                           string
	IsReleased                               string
	IsCancelled                              string
	IsMarkedForDeletion                      string
	IssuingPlant                             string
	IssuingPlantStorageLocation              string
	ReceivingPlant                           string
	ReceivingPlantStorageLocation            string
	StockConfirmationPartnerFunction         string
	StockConfirmationPlantBatch              string
}{
	PurchaseRequisition:                      "data_platform_purchase_requisition_item_data.PurchaseRequisition",
	PurchaseRequisitionItem:                  "data_platform_purchase_requisition_item_data.PurchaseRequisitionItem",
	PurchaseRequisitionItemCategory:          "data_platform_purchase_requisition_item_data.PurchaseRequisitionItemCategory",
	SupplyChainRelationshipID:                "data_platform_purchase_requisition_item_data.SupplyChainRelationshipID",
	SupplyChainRelationshipDeliveryID:        "data_platform_purchase_requisition_item_data.SupplyChainRelationshipDeliveryID",
	SupplyChainRelationshipDeliveryPlantID:   "data_platform_purchase_requisition_item_data.SupplyChainRelationshipDeliveryPlantID",
	SupplyChainRelationshipStockConfPlantID:  "data_platform_purchase_requisition_item_data.SupplyChainRelationshipStockConfPlantID",
	SupplyChainRelationshipProductionPlantID: "data_platform_purchase_requisition_item_data.SupplyChainRelationshipProductionPlantID",
	Buyer:                                    "data_platform_purchase_requisition_item_data.Buyer",
	Seller:                                   "data_platform_purchase_requisition_item_data.Seller",
	DeliverToParty:                           "data_platform_purchase_requisition_item_data.DeliverToParty",
	DeliverFromParty:                         "data_platform_purchase_requisition_item_data.DeliverFromParty",
	DeliverToPlant:                           "data_platform_purchase_requisition_item_data.DeliverToPlant",
	DeliverToPlantStorageLocation:            "data_platform_purchase_requisition_item_data.DeliverToPlantStorageLocation",
	DeliverFromPlant:                         "data_platform_purchase_requisition_item_data.DeliverFromPlant",
	DeliverFromPlantStorageLocation:          "data_platform_purchase_requisition_item_data.DeliverFromPlantStorageLocation",
	Product:                                  "data_platform_purchase_requisition_item_data.Product",
	ProductGroup:                             "data_platform_purchase_requisition_item_data.ProductGroup",
	RequestedQuantityInBaseUnit:              "data_platform_purchase_requisition_item_data.RequestedQuantityInBaseUnit",
	RequestedQuantityInDeliveryUnit:          "data_platform_purchase_requisition_item_data.RequestedQuantityInDeliveryUnit",
	BaseUnit:                                 "data_platform_purchase_requisition_item_data.BaseUnit",
	DeliveryUnit:                             "data_platform_purchase_requisition_item_data.DeliveryUnit",
	RequestedDeliveryDate:                    "data_platform_purchase_requisition_item_data.RequestedDeliveryDate",
	PlannedOrder:                             "data_platform_purchase_requisition_item_data.PlannedOrder",
	PlannedOrderItem:                         "data_platform_purchase_requisition_item_data.PlannedOrderItem",
	ProductionOrder:                          "data_platform_purchase_requisition_item_data.ProductionOrder",
	ProductionOrderItem:                      "data_platform_purchase_requisition_item_data.ProductionOrderItem",
	PrecedingOrderID:                         "data_platform_purchase_requisition_item_data.PrecedingOrderID",
	PrecedingOrderItem:                       "data_platform_purchase_requisition_item_data.PrecedingOrderItem",
	FollowingOrderID:                         "data_platform_purchase_requisition_item_data.FollowingOrderID",
	FollowingOrderItem:                       "data_platform_purchase_requisition_item_data.FollowingOrderItem",
	Project:                                  "data_platform_purchase_requisition_item_data.Project",
	WBSElement:                               "data_platform_purchase_requisition_item_data.WBSElement",
	PurchaseRequisitionItemText:              "data_platform_purchase_requisition_item_data.PurchaseRequisitionItemText",
	PurchaseRequisitionItemTextByBuyer:       "data_platform_purchase_requisition_item_data.PurchaseRequisitionItemTextByBuyer",
	PurchaseRequisitionItemTextBySeller:      "data_platform_purchase_requisition_item_data.PurchaseRequisitionItemTextBySeller",
	PurchaseRequisitionItemPrice:             "data_platform_purchase_requisition_item_data.PurchaseRequisitionItemPrice",
	PurchaseRequisitionItemPriceQuantity:     "data_platform_purchase_requisition_item_data.PurchaseRequisitionItemPriceQuantity",
	ProductPlannedDeliveryDuration:           "data_platform_purchase_requisition_item_data.ProductPlannedDeliveryDuration",
	ProductPlannedDeliveryDurationUnit:       "data_platform_purchase_requisition_item_data.ProductPlannedDeliveryDurationUnit",
	OrderedQuantityInBaseUnit:                "data_platform_purchase_requisition_item_data.OrderedQuantityInBaseUnit",
	OrderedQuantityInDeliveryUnit:            "data_platform_purchase_requisition_item_data.OrderedQuantityInDeliveryUnit",
	ItemCompleteOrderIsDefined:               "data_platform_purchase_requisition_item_data.ItemCompleteOrderIsDefined",
	TransactionCurrency:                      "data_platform_purchase_requisition_item_data.TransactionCurrency",
	MRPArea:                                  "data_platform_purchase_requisition_item_data.MRPArea",
	MRPController:                            "data_platform_purchase_requisition_item_data.MRPController",
	StockConfirmationBusinessPartner:         "data_platform_purchase_requisition_item_data.StockConfirmationBusinessPartner",
	StockConfirmationPlant:                   "data_platform_purchase_requisition_item_data.StockConfirmationPlant",
	ProductionPlantBusinessPartner:           "data_platform_purchase_requisition_item_data.ProductionPlantBusinessPartner",
	ProductionPlant:                          "data_platform_purchase_requisition_item_data.ProductionPlant",
	GLAccount:                                "data_platform_purchase_requisition_item_data.GLAccount",
	CreationDate:                             "data_platform_purchase_requisition_item_data.CreationDate",
	CreationTime:                             "data_platform_purchase_requisition_item_data.CreationTime",
	LastChangeDate:                           "data_platform_purchase_requisition_item_data.LastChangeDate",
	LastChangeTime:                           "data_platform_purchase_requisition_item_data.LastChangeTime",
	IsReleased:                               "data_platform_purchase_requisition_item_data.IsReleased",
	IsCancelled:                              "data_platform_purchase_requisition_item_data.IsCancelled",
	IsMarkedForDeletion:                      "data_platform_purchase_requisition_item_data.IsMarkedForDeletion",
	IssuingPlant:                             "data_platform_purchase_requisition_item_data.IssuingPlant",
	IssuingPlantStorageLocation:              "data_platform_purchase_requisition_item_data.IssuingPlantStorageLocation",
	ReceivingPlant:                           "data_platform_purchase_requisition_item_data.ReceivingPlant",
	ReceivingPlantStorageLocation:            "data_platform_purchase_requisition_item_data.ReceivingPlantStorageLocation",
	StockConfirmationPartnerFunction:         "data_platform_purchase_requisition_item_data.StockConfirmationPartnerFunction",
	StockConfirmationPlantBatch:              "data_platform_purchase_requisition_item_data.StockConfirmationPlantBatch",
}

// Generated where

var DataPlatformPurchaseRequisitionItemDatumWhere = struct {
	PurchaseRequisition                      whereHelperint
	PurchaseRequisitionItem                  whereHelperint
	PurchaseRequisitionItemCategory          whereHelperstring
	SupplyChainRelationshipID                whereHelpernull_Int
	SupplyChainRelationshipDeliveryID        whereHelpernull_Int
	SupplyChainRelationshipDeliveryPlantID   whereHelpernull_Int
	SupplyChainRelationshipStockConfPlantID  whereHelpernull_Int
	SupplyChainRelationshipProductionPlantID whereHelpernull_Int
	Buyer                                    whereHelperint
	Seller                                   whereHelpernull_Int
	DeliverToParty                           whereHelperint
	DeliverFromParty                         whereHelpernull_Int
	DeliverToPlant                           whereHelperstring
	DeliverToPlantStorageLocation            whereHelpernull_String
	DeliverFromPlant                         whereHelpernull_String
	DeliverFromPlantStorageLocation          whereHelpernull_String
	Product                                  whereHelperstring
	ProductGroup                             whereHelpernull_String
	RequestedQuantityInBaseUnit              whereHelperfloat32
	RequestedQuantityInDeliveryUnit          whereHelperfloat32
	BaseUnit                                 whereHelperstring
	DeliveryUnit                             whereHelperstring
	RequestedDeliveryDate                    whereHelperstring
	PlannedOrder                             whereHelpernull_Int
	PlannedOrderItem                         whereHelpernull_Int
	ProductionOrder                          whereHelpernull_Int
	ProductionOrderItem                      whereHelpernull_Int
	PrecedingOrderID                         whereHelpernull_Int
	PrecedingOrderItem                       whereHelpernull_Int
	FollowingOrderID                         whereHelpernull_Int
	FollowingOrderItem                       whereHelpernull_Int
	Project                                  whereHelpernull_Int
	WBSElement                               whereHelpernull_Int
	PurchaseRequisitionItemText              whereHelpernull_String
	PurchaseRequisitionItemTextByBuyer       whereHelpernull_String
	PurchaseRequisitionItemTextBySeller      whereHelpernull_String
	PurchaseRequisitionItemPrice             whereHelpernull_Float32
	PurchaseRequisitionItemPriceQuantity     whereHelpernull_Int
	ProductPlannedDeliveryDuration           whereHelpernull_Float32
	ProductPlannedDeliveryDurationUnit       whereHelpernull_String
	OrderedQuantityInBaseUnit                whereHelpernull_Float32
	OrderedQuantityInDeliveryUnit            whereHelpernull_Float32
	ItemCompleteOrderIsDefined               whereHelpernull_Bool
	TransactionCurrency                      whereHelpernull_String
	MRPArea                                  whereHelpernull_String
	MRPController                            whereHelpernull_String
	StockConfirmationBusinessPartner         whereHelpernull_Int
	StockConfirmationPlant                   whereHelpernull_String
	ProductionPlantBusinessPartner           whereHelpernull_Int
	ProductionPlant                          whereHelpernull_String
	GLAccount                                whereHelpernull_String
	CreationDate                             whereHelperstring
	CreationTime                             whereHelperstring
	LastChangeDate                           whereHelperstring
	LastChangeTime                           whereHelperstring
	IsReleased                               whereHelpernull_Bool
	IsCancelled                              whereHelpernull_Bool
	IsMarkedForDeletion                      whereHelpernull_Bool
	IssuingPlant                             whereHelperstring
	IssuingPlantStorageLocation              whereHelperstring
	ReceivingPlant                           whereHelperstring
	ReceivingPlantStorageLocation            whereHelperstring
	StockConfirmationPartnerFunction         whereHelperstring
	StockConfirmationPlantBatch              whereHelperstring
}{
	PurchaseRequisition:                      whereHelperint{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisition`"},
	PurchaseRequisitionItem:                  whereHelperint{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItem`"},
	PurchaseRequisitionItemCategory:          whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItemCategory`"},
	SupplyChainRelationshipID:                whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`SupplyChainRelationshipID`"},
	SupplyChainRelationshipDeliveryID:        whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`SupplyChainRelationshipDeliveryID`"},
	SupplyChainRelationshipDeliveryPlantID:   whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`SupplyChainRelationshipDeliveryPlantID`"},
	SupplyChainRelationshipStockConfPlantID:  whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`SupplyChainRelationshipStockConfPlantID`"},
	SupplyChainRelationshipProductionPlantID: whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`SupplyChainRelationshipProductionPlantID`"},
	Buyer:                                    whereHelperint{field: "`data_platform_purchase_requisition_item_data`.`Buyer`"},
	Seller:                                   whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`Seller`"},
	DeliverToParty:                           whereHelperint{field: "`data_platform_purchase_requisition_item_data`.`DeliverToParty`"},
	DeliverFromParty:                         whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`DeliverFromParty`"},
	DeliverToPlant:                           whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`DeliverToPlant`"},
	DeliverToPlantStorageLocation:            whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`DeliverToPlantStorageLocation`"},
	DeliverFromPlant:                         whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`DeliverFromPlant`"},
	DeliverFromPlantStorageLocation:          whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`DeliverFromPlantStorageLocation`"},
	Product:                                  whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`Product`"},
	ProductGroup:                             whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`ProductGroup`"},
	RequestedQuantityInBaseUnit:              whereHelperfloat32{field: "`data_platform_purchase_requisition_item_data`.`RequestedQuantityInBaseUnit`"},
	RequestedQuantityInDeliveryUnit:          whereHelperfloat32{field: "`data_platform_purchase_requisition_item_data`.`RequestedQuantityInDeliveryUnit`"},
	BaseUnit:                                 whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`BaseUnit`"},
	DeliveryUnit:                             whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`DeliveryUnit`"},
	RequestedDeliveryDate:                    whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`RequestedDeliveryDate`"},
	PlannedOrder:                             whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`PlannedOrder`"},
	PlannedOrderItem:                         whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`PlannedOrderItem`"},
	ProductionOrder:                          whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`ProductionOrder`"},
	ProductionOrderItem:                      whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`ProductionOrderItem`"},
	PrecedingOrderID:                         whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`PrecedingOrderID`"},
	PrecedingOrderItem:                       whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`PrecedingOrderItem`"},
	FollowingOrderID:                         whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`FollowingOrderID`"},
	FollowingOrderItem:                       whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`FollowingOrderItem`"},
	Project:                                  whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`Project`"},
	WBSElement:                               whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`WBSElement`"},
	PurchaseRequisitionItemText:              whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItemText`"},
	PurchaseRequisitionItemTextByBuyer:       whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItemTextByBuyer`"},
	PurchaseRequisitionItemTextBySeller:      whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItemTextBySeller`"},
	PurchaseRequisitionItemPrice:             whereHelpernull_Float32{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItemPrice`"},
	PurchaseRequisitionItemPriceQuantity:     whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`PurchaseRequisitionItemPriceQuantity`"},
	ProductPlannedDeliveryDuration:           whereHelpernull_Float32{field: "`data_platform_purchase_requisition_item_data`.`ProductPlannedDeliveryDuration`"},
	ProductPlannedDeliveryDurationUnit:       whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`ProductPlannedDeliveryDurationUnit`"},
	OrderedQuantityInBaseUnit:                whereHelpernull_Float32{field: "`data_platform_purchase_requisition_item_data`.`OrderedQuantityInBaseUnit`"},
	OrderedQuantityInDeliveryUnit:            whereHelpernull_Float32{field: "`data_platform_purchase_requisition_item_data`.`OrderedQuantityInDeliveryUnit`"},
	ItemCompleteOrderIsDefined:               whereHelpernull_Bool{field: "`data_platform_purchase_requisition_item_data`.`ItemCompleteOrderIsDefined`"},
	TransactionCurrency:                      whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`TransactionCurrency`"},
	MRPArea:                                  whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`MRPArea`"},
	MRPController:                            whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`MRPController`"},
	StockConfirmationBusinessPartner:         whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`StockConfirmationBusinessPartner`"},
	StockConfirmationPlant:                   whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`StockConfirmationPlant`"},
	ProductionPlantBusinessPartner:           whereHelpernull_Int{field: "`data_platform_purchase_requisition_item_data`.`ProductionPlantBusinessPartner`"},
	ProductionPlant:                          whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`ProductionPlant`"},
	GLAccount:                                whereHelpernull_String{field: "`data_platform_purchase_requisition_item_data`.`GLAccount`"},
	CreationDate:                             whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`CreationDate`"},
	CreationTime:                             whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`CreationTime`"},
	LastChangeDate:                           whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`LastChangeDate`"},
	LastChangeTime:                           whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`LastChangeTime`"},
	IsReleased:                               whereHelpernull_Bool{field: "`data_platform_purchase_requisition_item_data`.`IsReleased`"},
	IsCancelled:                              whereHelpernull_Bool{field: "`data_platform_purchase_requisition_item_data`.`IsCancelled`"},
	IsMarkedForDeletion:                      whereHelpernull_Bool{field: "`data_platform_purchase_requisition_item_data`.`IsMarkedForDeletion`"},
	IssuingPlant:                             whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`IssuingPlant`"},
	IssuingPlantStorageLocation:              whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`IssuingPlantStorageLocation`"},
	ReceivingPlant:                           whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`ReceivingPlant`"},
	ReceivingPlantStorageLocation:            whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`ReceivingPlantStorageLocation`"},
	StockConfirmationPartnerFunction:         whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`StockConfirmationPartnerFunction`"},
	StockConfirmationPlantBatch:              whereHelperstring{field: "`data_platform_purchase_requisition_item_data`.`StockConfirmationPlantBatch`"},
}

// DataPlatformPurchaseRequisitionItemDatumRels is where relationship names are stored.
var DataPlatformPurchaseRequisitionItemDatumRels = struct {
	BaseUnitDataPlatformQuantityUnitQuantityUnitDatum             string
	DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum       string
	DeliverToPartyDataPlatformBusinessPartnerGeneralDatum         string
	FollowingOrderIDDataPlatformOrdersItemDatum                   string
	DeliverFromPartyDataPlatformPlantStorageLocationDatum         string
	DeliverFromPartyDataPlatformPlantGeneralDatum                 string
	PrecedingOrderIDDataPlatformOrdersItemDatum                   string
	ProductGroupDataPlatformProductGroupProductGroupDatum         string
	ProductionOrderDataPlatformProductionOrderItemDatum           string
	ProductDataPlatformProductMasterGeneralDatum                  string
	DeliverToPartyDataPlatformPlantStorageLocationDatum           string
	DeliverToPartyDataPlatformPlantGeneralDatum                   string
	SellerDataPlatformBusinessPartnerGeneralDatum                 string
	ProductDataPlatformBatchMasterRecordBatchDatum                string
	StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum string
	BuyerDataPlatformPurchaseRequisitionHeaderDatum               string
}{
	BaseUnitDataPlatformQuantityUnitQuantityUnitDatum:             "BaseUnitDataPlatformQuantityUnitQuantityUnitDatum",
	DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum:       "DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum",
	DeliverToPartyDataPlatformBusinessPartnerGeneralDatum:         "DeliverToPartyDataPlatformBusinessPartnerGeneralDatum",
	FollowingOrderIDDataPlatformOrdersItemDatum:                   "FollowingOrderIDDataPlatformOrdersItemDatum",
	DeliverFromPartyDataPlatformPlantStorageLocationDatum:         "DeliverFromPartyDataPlatformPlantStorageLocationDatum",
	DeliverFromPartyDataPlatformPlantGeneralDatum:                 "DeliverFromPartyDataPlatformPlantGeneralDatum",
	PrecedingOrderIDDataPlatformOrdersItemDatum:                   "PrecedingOrderIDDataPlatformOrdersItemDatum",
	ProductGroupDataPlatformProductGroupProductGroupDatum:         "ProductGroupDataPlatformProductGroupProductGroupDatum",
	ProductionOrderDataPlatformProductionOrderItemDatum:           "ProductionOrderDataPlatformProductionOrderItemDatum",
	ProductDataPlatformProductMasterGeneralDatum:                  "ProductDataPlatformProductMasterGeneralDatum",
	DeliverToPartyDataPlatformPlantStorageLocationDatum:           "DeliverToPartyDataPlatformPlantStorageLocationDatum",
	DeliverToPartyDataPlatformPlantGeneralDatum:                   "DeliverToPartyDataPlatformPlantGeneralDatum",
	SellerDataPlatformBusinessPartnerGeneralDatum:                 "SellerDataPlatformBusinessPartnerGeneralDatum",
	ProductDataPlatformBatchMasterRecordBatchDatum:                "ProductDataPlatformBatchMasterRecordBatchDatum",
	StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum: "StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum",
	BuyerDataPlatformPurchaseRequisitionHeaderDatum:               "BuyerDataPlatformPurchaseRequisitionHeaderDatum",
}

// dataPlatformPurchaseRequisitionItemDatumR is where relationships are stored.
type dataPlatformPurchaseRequisitionItemDatumR struct {
	BaseUnitDataPlatformQuantityUnitQuantityUnitDatum             *DataPlatformQuantityUnitQuantityUnitDatum  `boil:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"BaseUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum       *DataPlatformBusinessPartnerGeneralDatum    `boil:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum" json:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum" toml:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum" yaml:"DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum"`
	DeliverToPartyDataPlatformBusinessPartnerGeneralDatum         *DataPlatformBusinessPartnerGeneralDatum    `boil:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum" json:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum" toml:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum" yaml:"DeliverToPartyDataPlatformBusinessPartnerGeneralDatum"`
	FollowingOrderIDDataPlatformOrdersItemDatum                   *DataPlatformOrdersItemDatum                `boil:"FollowingOrderIDDataPlatformOrdersItemDatum" json:"FollowingOrderIDDataPlatformOrdersItemDatum" toml:"FollowingOrderIDDataPlatformOrdersItemDatum" yaml:"FollowingOrderIDDataPlatformOrdersItemDatum"`
	DeliverFromPartyDataPlatformPlantStorageLocationDatum         *DataPlatformPlantStorageLocationDatum      `boil:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" json:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" toml:"DeliverFromPartyDataPlatformPlantStorageLocationDatum" yaml:"DeliverFromPartyDataPlatformPlantStorageLocationDatum"`
	DeliverFromPartyDataPlatformPlantGeneralDatum                 *DataPlatformPlantGeneralDatum              `boil:"DeliverFromPartyDataPlatformPlantGeneralDatum" json:"DeliverFromPartyDataPlatformPlantGeneralDatum" toml:"DeliverFromPartyDataPlatformPlantGeneralDatum" yaml:"DeliverFromPartyDataPlatformPlantGeneralDatum"`
	PrecedingOrderIDDataPlatformOrdersItemDatum                   *DataPlatformOrdersItemDatum                `boil:"PrecedingOrderIDDataPlatformOrdersItemDatum" json:"PrecedingOrderIDDataPlatformOrdersItemDatum" toml:"PrecedingOrderIDDataPlatformOrdersItemDatum" yaml:"PrecedingOrderIDDataPlatformOrdersItemDatum"`
	ProductGroupDataPlatformProductGroupProductGroupDatum         *DataPlatformProductGroupProductGroupDatum  `boil:"ProductGroupDataPlatformProductGroupProductGroupDatum" json:"ProductGroupDataPlatformProductGroupProductGroupDatum" toml:"ProductGroupDataPlatformProductGroupProductGroupDatum" yaml:"ProductGroupDataPlatformProductGroupProductGroupDatum"`
	ProductionOrderDataPlatformProductionOrderItemDatum           *DataPlatformProductionOrderItemDatum       `boil:"ProductionOrderDataPlatformProductionOrderItemDatum" json:"ProductionOrderDataPlatformProductionOrderItemDatum" toml:"ProductionOrderDataPlatformProductionOrderItemDatum" yaml:"ProductionOrderDataPlatformProductionOrderItemDatum"`
	ProductDataPlatformProductMasterGeneralDatum                  *DataPlatformProductMasterGeneralDatum      `boil:"ProductDataPlatformProductMasterGeneralDatum" json:"ProductDataPlatformProductMasterGeneralDatum" toml:"ProductDataPlatformProductMasterGeneralDatum" yaml:"ProductDataPlatformProductMasterGeneralDatum"`
	DeliverToPartyDataPlatformPlantStorageLocationDatum           *DataPlatformPlantStorageLocationDatum      `boil:"DeliverToPartyDataPlatformPlantStorageLocationDatum" json:"DeliverToPartyDataPlatformPlantStorageLocationDatum" toml:"DeliverToPartyDataPlatformPlantStorageLocationDatum" yaml:"DeliverToPartyDataPlatformPlantStorageLocationDatum"`
	DeliverToPartyDataPlatformPlantGeneralDatum                   *DataPlatformPlantGeneralDatum              `boil:"DeliverToPartyDataPlatformPlantGeneralDatum" json:"DeliverToPartyDataPlatformPlantGeneralDatum" toml:"DeliverToPartyDataPlatformPlantGeneralDatum" yaml:"DeliverToPartyDataPlatformPlantGeneralDatum"`
	SellerDataPlatformBusinessPartnerGeneralDatum                 *DataPlatformBusinessPartnerGeneralDatum    `boil:"SellerDataPlatformBusinessPartnerGeneralDatum" json:"SellerDataPlatformBusinessPartnerGeneralDatum" toml:"SellerDataPlatformBusinessPartnerGeneralDatum" yaml:"SellerDataPlatformBusinessPartnerGeneralDatum"`
	ProductDataPlatformBatchMasterRecordBatchDatum                *DataPlatformBatchMasterRecordBatchDatum    `boil:"ProductDataPlatformBatchMasterRecordBatchDatum" json:"ProductDataPlatformBatchMasterRecordBatchDatum" toml:"ProductDataPlatformBatchMasterRecordBatchDatum" yaml:"ProductDataPlatformBatchMasterRecordBatchDatum"`
	StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum *DataPlatformPlantGeneralDatum              `boil:"StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum" json:"StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum" toml:"StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum" yaml:"StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum"`
	BuyerDataPlatformPurchaseRequisitionHeaderDatum               *DataPlatformPurchaseRequisitionHeaderDatum `boil:"BuyerDataPlatformPurchaseRequisitionHeaderDatum" json:"BuyerDataPlatformPurchaseRequisitionHeaderDatum" toml:"BuyerDataPlatformPurchaseRequisitionHeaderDatum" yaml:"BuyerDataPlatformPurchaseRequisitionHeaderDatum"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformPurchaseRequisitionItemDatumR) NewStruct() *dataPlatformPurchaseRequisitionItemDatumR {
	return &dataPlatformPurchaseRequisitionItemDatumR{}
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetBaseUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetDeliverToPartyDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetFollowingOrderIDDataPlatformOrdersItemDatum() *DataPlatformOrdersItemDatum {
	if r == nil {
		return nil
	}
	return r.FollowingOrderIDDataPlatformOrdersItemDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetDeliverFromPartyDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetDeliverFromPartyDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.DeliverFromPartyDataPlatformPlantGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetPrecedingOrderIDDataPlatformOrdersItemDatum() *DataPlatformOrdersItemDatum {
	if r == nil {
		return nil
	}
	return r.PrecedingOrderIDDataPlatformOrdersItemDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetProductGroupDataPlatformProductGroupProductGroupDatum() *DataPlatformProductGroupProductGroupDatum {
	if r == nil {
		return nil
	}
	return r.ProductGroupDataPlatformProductGroupProductGroupDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetProductionOrderDataPlatformProductionOrderItemDatum() *DataPlatformProductionOrderItemDatum {
	if r == nil {
		return nil
	}
	return r.ProductionOrderDataPlatformProductionOrderItemDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetProductDataPlatformProductMasterGeneralDatum() *DataPlatformProductMasterGeneralDatum {
	if r == nil {
		return nil
	}
	return r.ProductDataPlatformProductMasterGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetDeliverToPartyDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetDeliverToPartyDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.DeliverToPartyDataPlatformPlantGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetSellerDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.SellerDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetProductDataPlatformBatchMasterRecordBatchDatum() *DataPlatformBatchMasterRecordBatchDatum {
	if r == nil {
		return nil
	}
	return r.ProductDataPlatformBatchMasterRecordBatchDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum
}

func (r *dataPlatformPurchaseRequisitionItemDatumR) GetBuyerDataPlatformPurchaseRequisitionHeaderDatum() *DataPlatformPurchaseRequisitionHeaderDatum {
	if r == nil {
		return nil
	}
	return r.BuyerDataPlatformPurchaseRequisitionHeaderDatum
}

// dataPlatformPurchaseRequisitionItemDatumL is where Load methods for each relationship are stored.
type dataPlatformPurchaseRequisitionItemDatumL struct{}

var (
	dataPlatformPurchaseRequisitionItemDatumAllColumns            = []string{"PurchaseRequisition", "PurchaseRequisitionItem", "PurchaseRequisitionItemCategory", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipStockConfPlantID", "SupplyChainRelationshipProductionPlantID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverToPlantStorageLocation", "DeliverFromPlant", "DeliverFromPlantStorageLocation", "Product", "ProductGroup", "RequestedQuantityInBaseUnit", "RequestedQuantityInDeliveryUnit", "BaseUnit", "DeliveryUnit", "RequestedDeliveryDate", "PlannedOrder", "PlannedOrderItem", "ProductionOrder", "ProductionOrderItem", "PrecedingOrderID", "PrecedingOrderItem", "FollowingOrderID", "FollowingOrderItem", "Project", "WBSElement", "PurchaseRequisitionItemText", "PurchaseRequisitionItemTextByBuyer", "PurchaseRequisitionItemTextBySeller", "PurchaseRequisitionItemPrice", "PurchaseRequisitionItemPriceQuantity", "ProductPlannedDeliveryDuration", "ProductPlannedDeliveryDurationUnit", "OrderedQuantityInBaseUnit", "OrderedQuantityInDeliveryUnit", "ItemCompleteOrderIsDefined", "TransactionCurrency", "MRPArea", "MRPController", "StockConfirmationBusinessPartner", "StockConfirmationPlant", "ProductionPlantBusinessPartner", "ProductionPlant", "GLAccount", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsReleased", "IsCancelled", "IsMarkedForDeletion", "IssuingPlant", "IssuingPlantStorageLocation", "ReceivingPlant", "ReceivingPlantStorageLocation", "StockConfirmationPartnerFunction", "StockConfirmationPlantBatch"}
	dataPlatformPurchaseRequisitionItemDatumColumnsWithoutDefault = []string{"PurchaseRequisition", "PurchaseRequisitionItem", "PurchaseRequisitionItemCategory", "SupplyChainRelationshipID", "SupplyChainRelationshipDeliveryID", "SupplyChainRelationshipDeliveryPlantID", "SupplyChainRelationshipStockConfPlantID", "SupplyChainRelationshipProductionPlantID", "Buyer", "Seller", "DeliverToParty", "DeliverFromParty", "DeliverToPlant", "DeliverToPlantStorageLocation", "DeliverFromPlant", "DeliverFromPlantStorageLocation", "Product", "ProductGroup", "RequestedQuantityInBaseUnit", "RequestedQuantityInDeliveryUnit", "BaseUnit", "DeliveryUnit", "RequestedDeliveryDate", "PlannedOrder", "PlannedOrderItem", "ProductionOrder", "ProductionOrderItem", "PrecedingOrderID", "PrecedingOrderItem", "FollowingOrderID", "FollowingOrderItem", "Project", "WBSElement", "PurchaseRequisitionItemText", "PurchaseRequisitionItemTextByBuyer", "PurchaseRequisitionItemTextBySeller", "PurchaseRequisitionItemPrice", "PurchaseRequisitionItemPriceQuantity", "ProductPlannedDeliveryDuration", "ProductPlannedDeliveryDurationUnit", "OrderedQuantityInBaseUnit", "OrderedQuantityInDeliveryUnit", "ItemCompleteOrderIsDefined", "TransactionCurrency", "MRPArea", "MRPController", "StockConfirmationBusinessPartner", "StockConfirmationPlant", "ProductionPlantBusinessPartner", "ProductionPlant", "GLAccount", "CreationDate", "CreationTime", "LastChangeDate", "LastChangeTime", "IsReleased", "IsCancelled", "IsMarkedForDeletion", "IssuingPlant", "IssuingPlantStorageLocation", "ReceivingPlant", "ReceivingPlantStorageLocation", "StockConfirmationPartnerFunction", "StockConfirmationPlantBatch"}
	dataPlatformPurchaseRequisitionItemDatumColumnsWithDefault    = []string{}
	dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns     = []string{"PurchaseRequisition", "PurchaseRequisitionItem"}
	dataPlatformPurchaseRequisitionItemDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformPurchaseRequisitionItemDatumSlice is an alias for a slice of pointers to DataPlatformPurchaseRequisitionItemDatum.
	// This should almost always be used instead of []DataPlatformPurchaseRequisitionItemDatum.
	DataPlatformPurchaseRequisitionItemDatumSlice []*DataPlatformPurchaseRequisitionItemDatum

	dataPlatformPurchaseRequisitionItemDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformPurchaseRequisitionItemDatumType                 = reflect.TypeOf(&DataPlatformPurchaseRequisitionItemDatum{})
	dataPlatformPurchaseRequisitionItemDatumMapping              = queries.MakeStructMapping(dataPlatformPurchaseRequisitionItemDatumType)
	dataPlatformPurchaseRequisitionItemDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns)
	dataPlatformPurchaseRequisitionItemDatumInsertCacheMut       sync.RWMutex
	dataPlatformPurchaseRequisitionItemDatumInsertCache          = make(map[string]insertCache)
	dataPlatformPurchaseRequisitionItemDatumUpdateCacheMut       sync.RWMutex
	dataPlatformPurchaseRequisitionItemDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformPurchaseRequisitionItemDatumUpsertCacheMut       sync.RWMutex
	dataPlatformPurchaseRequisitionItemDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single dataPlatformPurchaseRequisitionItemDatum record from the query.
func (q dataPlatformPurchaseRequisitionItemDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformPurchaseRequisitionItemDatum, error) {
	o := &DataPlatformPurchaseRequisitionItemDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_purchase_requisition_item_data")
	}

	return o, nil
}

// All returns all DataPlatformPurchaseRequisitionItemDatum records from the query.
func (q dataPlatformPurchaseRequisitionItemDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformPurchaseRequisitionItemDatumSlice, error) {
	var o []*DataPlatformPurchaseRequisitionItemDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformPurchaseRequisitionItemDatum slice")
	}

	return o, nil
}

// Count returns the count of all DataPlatformPurchaseRequisitionItemDatum records in the query.
func (q dataPlatformPurchaseRequisitionItemDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_purchase_requisition_item_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformPurchaseRequisitionItemDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_purchase_requisition_item_data exists")
	}

	return count > 0, nil
}

// BaseUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) BaseUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.BaseUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// DeliverToPartyDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) DeliverToPartyDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// FollowingOrderIDDataPlatformOrdersItemDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) FollowingOrderIDDataPlatformOrdersItemDatum(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OrderID` = ?", o.FollowingOrderID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOrdersItemData(queryMods...)
}

// DeliverFromPartyDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) DeliverFromPartyDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// DeliverFromPartyDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) DeliverFromPartyDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverFromParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// PrecedingOrderIDDataPlatformOrdersItemDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) PrecedingOrderIDDataPlatformOrdersItemDatum(mods ...qm.QueryMod) dataPlatformOrdersItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`OrderID` = ?", o.PrecedingOrderID),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformOrdersItemData(queryMods...)
}

// ProductGroupDataPlatformProductGroupProductGroupDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) ProductGroupDataPlatformProductGroupProductGroupDatum(mods ...qm.QueryMod) dataPlatformProductGroupProductGroupDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductGroup` = ?", o.ProductGroup),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductGroupProductGroupData(queryMods...)
}

// ProductionOrderDataPlatformProductionOrderItemDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) ProductionOrderDataPlatformProductionOrderItemDatum(mods ...qm.QueryMod) dataPlatformProductionOrderItemDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`ProductionOrder` = ?", o.ProductionOrder),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductionOrderItemData(queryMods...)
}

// ProductDataPlatformProductMasterGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) ProductDataPlatformProductMasterGeneralDatum(mods ...qm.QueryMod) dataPlatformProductMasterGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.Product),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductMasterGeneralData(queryMods...)
}

// DeliverToPartyDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) DeliverToPartyDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// DeliverToPartyDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) DeliverToPartyDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.DeliverToParty),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// SellerDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) SellerDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.Seller),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// ProductDataPlatformBatchMasterRecordBatchDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) ProductDataPlatformBatchMasterRecordBatchDatum(mods ...qm.QueryMod) dataPlatformBatchMasterRecordBatchDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.Product),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBatchMasterRecordBatchData(queryMods...)
}

// StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.StockConfirmationBusinessPartner),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// BuyerDataPlatformPurchaseRequisitionHeaderDatum pointed to by the foreign key.
func (o *DataPlatformPurchaseRequisitionItemDatum) BuyerDataPlatformPurchaseRequisitionHeaderDatum(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionHeaderDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Buyer` = ?", o.Buyer),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPurchaseRequisitionHeaderData(queryMods...)
}

// LoadBaseUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.BaseUnit)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.BaseUnit {
					continue Outer
				}
			}

			args = append(args, obj.BaseUnit)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BaseUnit == foreign.QuantityUnit {
				local.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.DeliverFromParty) {
			args = append(args, object.DeliverFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromParty) {
				args = append(args, obj.DeliverFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromParty, foreign.BusinessPartner) {
				local.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadDeliverToPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.DeliverToParty)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliverToParty {
					continue Outer
				}
			}

			args = append(args, obj.DeliverToParty)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliverToParty == foreign.BusinessPartner {
				local.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadFollowingOrderIDDataPlatformOrdersItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadFollowingOrderIDDataPlatformOrdersItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.FollowingOrderID) {
			args = append(args, object.FollowingOrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FollowingOrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.FollowingOrderID) {
				args = append(args, obj.FollowingOrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOrdersItemDatum")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOrdersItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FollowingOrderIDDataPlatformOrdersItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.FollowingOrderID, foreign.OrderID) {
				local.R.FollowingOrderIDDataPlatformOrdersItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.DeliverFromParty) {
			args = append(args, object.DeliverFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromParty) {
				args = append(args, obj.DeliverFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromParty, foreign.BusinessPartner) {
				local.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverFromPartyDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadDeliverFromPartyDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.DeliverFromParty) {
			args = append(args, object.DeliverFromParty)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DeliverFromParty) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DeliverFromParty) {
				args = append(args, obj.DeliverFromParty)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverFromPartyDataPlatformPlantGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DeliverFromParty, foreign.BusinessPartner) {
				local.R.DeliverFromPartyDataPlatformPlantGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadPrecedingOrderIDDataPlatformOrdersItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadPrecedingOrderIDDataPlatformOrdersItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.PrecedingOrderID) {
			args = append(args, object.PrecedingOrderID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PrecedingOrderID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PrecedingOrderID) {
				args = append(args, obj.PrecedingOrderID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_orders_item_data`),
		qm.WhereIn(`data_platform_orders_item_data.OrderID in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformOrdersItemDatum")
	}

	var resultSlice []*DataPlatformOrdersItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformOrdersItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_orders_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_orders_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PrecedingOrderIDDataPlatformOrdersItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PrecedingOrderID, foreign.OrderID) {
				local.R.PrecedingOrderIDDataPlatformOrdersItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductGroupDataPlatformProductGroupProductGroupDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadProductGroupDataPlatformProductGroupProductGroupDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.ProductGroup) {
			args = append(args, object.ProductGroup)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductGroup) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductGroup) {
				args = append(args, obj.ProductGroup)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_product_group_product_group_data`),
		qm.WhereIn(`data_platform_product_group_product_group_data.ProductGroup in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductGroupProductGroupDatum")
	}

	var resultSlice []*DataPlatformProductGroupProductGroupDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductGroupProductGroupDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_product_group_product_group_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_product_group_product_group_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductGroupDataPlatformProductGroupProductGroupDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductGroup, foreign.ProductGroup) {
				local.R.ProductGroupDataPlatformProductGroupProductGroupDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductionOrderDataPlatformProductionOrderItemDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.ProductionOrder) {
			args = append(args, object.ProductionOrder)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ProductionOrder) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ProductionOrder) {
				args = append(args, obj.ProductionOrder)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_production_order_item_data`),
		qm.WhereIn(`data_platform_production_order_item_data.ProductionOrder in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductionOrderItemDatum")
	}

	var resultSlice []*DataPlatformProductionOrderItemDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductionOrderItemDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_production_order_item_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_production_order_item_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ProductionOrder, foreign.ProductionOrder) {
				local.R.ProductionOrderDataPlatformProductionOrderItemDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductDataPlatformProductMasterGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadProductDataPlatformProductMasterGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.Product)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_product_master_general_data`),
		qm.WhereIn(`data_platform_product_master_general_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductMasterGeneralDatum")
	}

	var resultSlice []*DataPlatformProductMasterGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductMasterGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_product_master_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_product_master_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductDataPlatformProductMasterGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Product == foreign.Product {
				local.R.ProductDataPlatformProductMasterGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.DeliverToParty)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliverToParty {
					continue Outer
				}
			}

			args = append(args, obj.DeliverToParty)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliverToParty == foreign.BusinessPartner {
				local.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadDeliverToPartyDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadDeliverToPartyDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.DeliverToParty)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.DeliverToParty {
					continue Outer
				}
			}

			args = append(args, obj.DeliverToParty)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DeliverToPartyDataPlatformPlantGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DeliverToParty == foreign.BusinessPartner {
				local.R.DeliverToPartyDataPlatformPlantGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadSellerDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadSellerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.Seller) {
			args = append(args, object.Seller)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Seller) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Seller) {
				args = append(args, obj.Seller)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SellerDataPlatformBusinessPartnerGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Seller, foreign.BusinessPartner) {
				local.R.SellerDataPlatformBusinessPartnerGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadProductDataPlatformBatchMasterRecordBatchDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.Product)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_batch_master_record_batch_data`),
		qm.WhereIn(`data_platform_batch_master_record_batch_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBatchMasterRecordBatchDatum")
	}

	var resultSlice []*DataPlatformBatchMasterRecordBatchDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBatchMasterRecordBatchDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_batch_master_record_batch_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_batch_master_record_batch_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductDataPlatformBatchMasterRecordBatchDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Product == foreign.Product {
				local.R.ProductDataPlatformBatchMasterRecordBatchDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		if !queries.IsNil(object.StockConfirmationBusinessPartner) {
			args = append(args, object.StockConfirmationBusinessPartner)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.StockConfirmationBusinessPartner) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.StockConfirmationBusinessPartner) {
				args = append(args, obj.StockConfirmationBusinessPartner)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.StockConfirmationBusinessPartner, foreign.BusinessPartner) {
				local.R.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum = foreign
				break
			}
		}
	}

	return nil
}

// LoadBuyerDataPlatformPurchaseRequisitionHeaderDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformPurchaseRequisitionItemDatumL) LoadBuyerDataPlatformPurchaseRequisitionHeaderDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformPurchaseRequisitionItemDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformPurchaseRequisitionItemDatum
	var object *DataPlatformPurchaseRequisitionItemDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformPurchaseRequisitionItemDatum.(*DataPlatformPurchaseRequisitionItemDatum)
		if !ok {
			object = new(DataPlatformPurchaseRequisitionItemDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformPurchaseRequisitionItemDatum.(*[]*DataPlatformPurchaseRequisitionItemDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformPurchaseRequisitionItemDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformPurchaseRequisitionItemDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformPurchaseRequisitionItemDatumR{}
		}
		args = append(args, object.Buyer)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformPurchaseRequisitionItemDatumR{}
			}

			for _, a := range args {
				if a == obj.Buyer {
					continue Outer
				}
			}

			args = append(args, obj.Buyer)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_purchase_requisition_header_data`),
		qm.WhereIn(`data_platform_purchase_requisition_header_data.Buyer in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPurchaseRequisitionHeaderDatum")
	}

	var resultSlice []*DataPlatformPurchaseRequisitionHeaderDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPurchaseRequisitionHeaderDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_purchase_requisition_header_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_purchase_requisition_header_data")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BuyerDataPlatformPurchaseRequisitionHeaderDatum = foreign
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Buyer == foreign.Buyer {
				local.R.BuyerDataPlatformPurchaseRequisitionHeaderDatum = foreign
				break
			}
		}
	}

	return nil
}

// SetBaseUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetBaseUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BaseUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BaseUnit = related.QuantityUnit
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			BaseUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.BaseUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	return nil
}

// SetDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = related
	}

	return nil
}

// RemoveDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum relationship.
// Sets o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveDeliverFromPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPartyDataPlatformBusinessPartnerGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverToPartyDataPlatformBusinessPartnerGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetDeliverToPartyDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliverToParty = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			DeliverToPartyDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformBusinessPartnerGeneralDatum = related
	}

	return nil
}

// SetFollowingOrderIDDataPlatformOrdersItemDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.FollowingOrderIDDataPlatformOrdersItemDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetFollowingOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOrdersItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"FollowingOrderID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OrderID, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.FollowingOrderID, related.OrderID)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			FollowingOrderIDDataPlatformOrdersItemDatum: related,
		}
	} else {
		o.R.FollowingOrderIDDataPlatformOrdersItemDatum = related
	}

	return nil
}

// RemoveFollowingOrderIDDataPlatformOrdersItemDatum relationship.
// Sets o.R.FollowingOrderIDDataPlatformOrdersItemDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveFollowingOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformOrdersItemDatum) error {
	var err error

	queries.SetScanner(&o.FollowingOrderID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("FollowingOrderID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.FollowingOrderIDDataPlatformOrdersItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverFromPartyDataPlatformPlantStorageLocationDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			DeliverFromPartyDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// RemoveDeliverFromPartyDataPlatformPlantStorageLocationDatum relationship.
// Sets o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveDeliverFromPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantStorageLocationDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPartyDataPlatformPlantStorageLocationDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetDeliverFromPartyDataPlatformPlantGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.DeliverFromPartyDataPlatformPlantGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetDeliverFromPartyDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverFromParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DeliverFromParty, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			DeliverFromPartyDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.DeliverFromPartyDataPlatformPlantGeneralDatum = related
	}

	return nil
}

// RemoveDeliverFromPartyDataPlatformPlantGeneralDatum relationship.
// Sets o.R.DeliverFromPartyDataPlatformPlantGeneralDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveDeliverFromPartyDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantGeneralDatum) error {
	var err error

	queries.SetScanner(&o.DeliverFromParty, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("DeliverFromParty")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DeliverFromPartyDataPlatformPlantGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetPrecedingOrderIDDataPlatformOrdersItemDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.PrecedingOrderIDDataPlatformOrdersItemDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetPrecedingOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformOrdersItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"PrecedingOrderID"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.OrderID, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PrecedingOrderID, related.OrderID)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			PrecedingOrderIDDataPlatformOrdersItemDatum: related,
		}
	} else {
		o.R.PrecedingOrderIDDataPlatformOrdersItemDatum = related
	}

	return nil
}

// RemovePrecedingOrderIDDataPlatformOrdersItemDatum relationship.
// Sets o.R.PrecedingOrderIDDataPlatformOrdersItemDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemovePrecedingOrderIDDataPlatformOrdersItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformOrdersItemDatum) error {
	var err error

	queries.SetScanner(&o.PrecedingOrderID, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("PrecedingOrderID")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.PrecedingOrderIDDataPlatformOrdersItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductGroupDataPlatformProductGroupProductGroupDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.ProductGroupDataPlatformProductGroupProductGroupDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetProductGroupDataPlatformProductGroupProductGroupDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductGroupProductGroupDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductGroup"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductGroup, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductGroup, related.ProductGroup)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			ProductGroupDataPlatformProductGroupProductGroupDatum: related,
		}
	} else {
		o.R.ProductGroupDataPlatformProductGroupProductGroupDatum = related
	}

	return nil
}

// RemoveProductGroupDataPlatformProductGroupProductGroupDatum relationship.
// Sets o.R.ProductGroupDataPlatformProductGroupProductGroupDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveProductGroupDataPlatformProductGroupProductGroupDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductGroupProductGroupDatum) error {
	var err error

	queries.SetScanner(&o.ProductGroup, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductGroup")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductGroupDataPlatformProductGroupProductGroupDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductionOrderDataPlatformProductionOrderItemDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductionOrderItemDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ProductionOrder"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.ProductionOrder, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ProductionOrder, related.ProductionOrder)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			ProductionOrderDataPlatformProductionOrderItemDatum: related,
		}
	} else {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = related
	}

	return nil
}

// RemoveProductionOrderDataPlatformProductionOrderItemDatum relationship.
// Sets o.R.ProductionOrderDataPlatformProductionOrderItemDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveProductionOrderDataPlatformProductionOrderItemDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformProductionOrderItemDatum) error {
	var err error

	queries.SetScanner(&o.ProductionOrder, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("ProductionOrder")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ProductionOrderDataPlatformProductionOrderItemDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductDataPlatformProductMasterGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.ProductDataPlatformProductMasterGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetProductDataPlatformProductMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductMasterGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Product = related.Product
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			ProductDataPlatformProductMasterGeneralDatum: related,
		}
	} else {
		o.R.ProductDataPlatformProductMasterGeneralDatum = related
	}

	return nil
}

// SetDeliverToPartyDataPlatformPlantStorageLocationDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetDeliverToPartyDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliverToParty = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			DeliverToPartyDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformPlantStorageLocationDatum = related
	}

	return nil
}

// SetDeliverToPartyDataPlatformPlantGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.DeliverToPartyDataPlatformPlantGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetDeliverToPartyDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"DeliverToParty"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DeliverToParty = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			DeliverToPartyDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.DeliverToPartyDataPlatformPlantGeneralDatum = related
	}

	return nil
}

// SetSellerDataPlatformBusinessPartnerGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.SellerDataPlatformBusinessPartnerGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetSellerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Seller"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Seller, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			SellerDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.SellerDataPlatformBusinessPartnerGeneralDatum = related
	}

	return nil
}

// RemoveSellerDataPlatformBusinessPartnerGeneralDatum relationship.
// Sets o.R.SellerDataPlatformBusinessPartnerGeneralDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveSellerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error

	queries.SetScanner(&o.Seller, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("Seller")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SellerDataPlatformBusinessPartnerGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetProductDataPlatformBatchMasterRecordBatchDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.ProductDataPlatformBatchMasterRecordBatchDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetProductDataPlatformBatchMasterRecordBatchDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBatchMasterRecordBatchDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Product = related.Product
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			ProductDataPlatformBatchMasterRecordBatchDatum: related,
		}
	} else {
		o.R.ProductDataPlatformBatchMasterRecordBatchDatum = related
	}

	return nil
}

// SetStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"StockConfirmationBusinessPartner"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.StockConfirmationBusinessPartner, related.BusinessPartner)
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum = related
	}

	return nil
}

// RemoveStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum relationship.
// Sets o.R.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum to nil.
func (o *DataPlatformPurchaseRequisitionItemDatum) RemoveStockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformPlantGeneralDatum) error {
	var err error

	queries.SetScanner(&o.StockConfirmationBusinessPartner, nil)
	if err = o.Update(ctx, exec, boil.Whitelist("StockConfirmationBusinessPartner")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.StockConfirmationBusinessPartnerDataPlatformPlantGeneralDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	return nil
}

// SetBuyerDataPlatformPurchaseRequisitionHeaderDatum of the dataPlatformPurchaseRequisitionItemDatum to the related item.
// Sets o.R.BuyerDataPlatformPurchaseRequisitionHeaderDatum to related.
func (o *DataPlatformPurchaseRequisitionItemDatum) SetBuyerDataPlatformPurchaseRequisitionHeaderDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPurchaseRequisitionHeaderDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Buyer"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Buyer, o.PurchaseRequisition, o.PurchaseRequisitionItem}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Buyer = related.Buyer
	if o.R == nil {
		o.R = &dataPlatformPurchaseRequisitionItemDatumR{
			BuyerDataPlatformPurchaseRequisitionHeaderDatum: related,
		}
	} else {
		o.R.BuyerDataPlatformPurchaseRequisitionHeaderDatum = related
	}

	return nil
}

// DataPlatformPurchaseRequisitionItemData retrieves all the records using an executor.
func DataPlatformPurchaseRequisitionItemData(mods ...qm.QueryMod) dataPlatformPurchaseRequisitionItemDatumQuery {
	mods = append(mods, qm.From("`data_platform_purchase_requisition_item_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_purchase_requisition_item_data`.*"})
	}

	return dataPlatformPurchaseRequisitionItemDatumQuery{q}
}

// FindDataPlatformPurchaseRequisitionItemDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformPurchaseRequisitionItemDatum(ctx context.Context, exec boil.ContextExecutor, purchaseRequisition int, purchaseRequisitionItem int, selectCols ...string) (*DataPlatformPurchaseRequisitionItemDatum, error) {
	dataPlatformPurchaseRequisitionItemDatumObj := &DataPlatformPurchaseRequisitionItemDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_purchase_requisition_item_data` where `PurchaseRequisition`=? AND `PurchaseRequisitionItem`=?", sel,
	)

	q := queries.Raw(query, purchaseRequisition, purchaseRequisitionItem)

	err := q.Bind(ctx, exec, dataPlatformPurchaseRequisitionItemDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_purchase_requisition_item_data")
	}

	return dataPlatformPurchaseRequisitionItemDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformPurchaseRequisitionItemDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_purchase_requisition_item_data provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformPurchaseRequisitionItemDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformPurchaseRequisitionItemDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformPurchaseRequisitionItemDatumInsertCache[key]
	dataPlatformPurchaseRequisitionItemDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformPurchaseRequisitionItemDatumAllColumns,
			dataPlatformPurchaseRequisitionItemDatumColumnsWithDefault,
			dataPlatformPurchaseRequisitionItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_purchase_requisition_item_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_purchase_requisition_item_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_purchase_requisition_item_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_purchase_requisition_item_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.PurchaseRequisition,
		o.PurchaseRequisitionItem,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_purchase_requisition_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformPurchaseRequisitionItemDatumInsertCacheMut.Lock()
		dataPlatformPurchaseRequisitionItemDatumInsertCache[key] = cache
		dataPlatformPurchaseRequisitionItemDatumInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DataPlatformPurchaseRequisitionItemDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformPurchaseRequisitionItemDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	dataPlatformPurchaseRequisitionItemDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformPurchaseRequisitionItemDatumUpdateCache[key]
	dataPlatformPurchaseRequisitionItemDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformPurchaseRequisitionItemDatumAllColumns,
			dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return errors.New("models: unable to update data_platform_purchase_requisition_item_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, append(wl, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update data_platform_purchase_requisition_item_data row")
	}

	if !cached {
		dataPlatformPurchaseRequisitionItemDatumUpdateCacheMut.Lock()
		dataPlatformPurchaseRequisitionItemDatumUpdateCache[key] = cache
		dataPlatformPurchaseRequisitionItemDatumUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformPurchaseRequisitionItemDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all for data_platform_purchase_requisition_item_data")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformPurchaseRequisitionItemDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPurchaseRequisitionItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_purchase_requisition_item_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to update all in dataPlatformPurchaseRequisitionItemDatum slice")
	}

	return nil
}

var mySQLDataPlatformPurchaseRequisitionItemDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformPurchaseRequisitionItemDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_purchase_requisition_item_data provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformPurchaseRequisitionItemDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformPurchaseRequisitionItemDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformPurchaseRequisitionItemDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformPurchaseRequisitionItemDatumUpsertCache[key]
	dataPlatformPurchaseRequisitionItemDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformPurchaseRequisitionItemDatumAllColumns,
			dataPlatformPurchaseRequisitionItemDatumColumnsWithDefault,
			dataPlatformPurchaseRequisitionItemDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformPurchaseRequisitionItemDatumAllColumns,
			dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_purchase_requisition_item_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_purchase_requisition_item_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_purchase_requisition_item_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_purchase_requisition_item_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformPurchaseRequisitionItemDatumType, dataPlatformPurchaseRequisitionItemDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_purchase_requisition_item_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_purchase_requisition_item_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformPurchaseRequisitionItemDatumUpsertCacheMut.Lock()
		dataPlatformPurchaseRequisitionItemDatumUpsertCache[key] = cache
		dataPlatformPurchaseRequisitionItemDatumUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DataPlatformPurchaseRequisitionItemDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformPurchaseRequisitionItemDatum) Delete(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil {
		return errors.New("models: no DataPlatformPurchaseRequisitionItemDatum provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformPurchaseRequisitionItemDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_purchase_requisition_item_data` WHERE `PurchaseRequisition`=? AND `PurchaseRequisitionItem`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete from data_platform_purchase_requisition_item_data")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformPurchaseRequisitionItemDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if q.Query == nil {
		return errors.New("models: no dataPlatformPurchaseRequisitionItemDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from data_platform_purchase_requisition_item_data")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformPurchaseRequisitionItemDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPurchaseRequisitionItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_purchase_requisition_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	_, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return errors.Wrap(err, "models: unable to delete all from dataPlatformPurchaseRequisitionItemDatum slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformPurchaseRequisitionItemDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformPurchaseRequisitionItemDatum(ctx, exec, o.PurchaseRequisition, o.PurchaseRequisitionItem)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformPurchaseRequisitionItemDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformPurchaseRequisitionItemDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformPurchaseRequisitionItemDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_purchase_requisition_item_data`.* FROM `data_platform_purchase_requisition_item_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformPurchaseRequisitionItemDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformPurchaseRequisitionItemDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformPurchaseRequisitionItemDatumExists checks if the DataPlatformPurchaseRequisitionItemDatum row exists.
func DataPlatformPurchaseRequisitionItemDatumExists(ctx context.Context, exec boil.ContextExecutor, purchaseRequisition int, purchaseRequisitionItem int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_purchase_requisition_item_data` where `PurchaseRequisition`=? AND `PurchaseRequisitionItem`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, purchaseRequisition, purchaseRequisitionItem)
	}
	row := exec.QueryRowContext(ctx, sql, purchaseRequisition, purchaseRequisitionItem)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_purchase_requisition_item_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformPurchaseRequisitionItemDatum row exists.
func (o *DataPlatformPurchaseRequisitionItemDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformPurchaseRequisitionItemDatumExists(ctx, exec, o.PurchaseRequisition, o.PurchaseRequisitionItem)
}
