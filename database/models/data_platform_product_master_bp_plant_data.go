// Code generated by SQLBoiler 4.13.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DataPlatformProductMasterBPPlantDatum is an object representing the database table.
type DataPlatformProductMasterBPPlantDatum struct {
	Product                   string      `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	BusinessPartner           int         `boil:"BusinessPartner" json:"BusinessPartner" toml:"BusinessPartner" yaml:"BusinessPartner"`
	Plant                     string      `boil:"Plant" json:"Plant" toml:"Plant" yaml:"Plant"`
	Issuable                  null.Bool   `boil:"Issuable" json:"Issuable,omitempty" toml:"Issuable" yaml:"Issuable,omitempty"`
	Receivable                null.Bool   `boil:"Receivable" json:"Receivable,omitempty" toml:"Receivable" yaml:"Receivable,omitempty"`
	IssuingDeliveryUnit       null.String `boil:"IssuingDeliveryUnit" json:"IssuingDeliveryUnit,omitempty" toml:"IssuingDeliveryUnit" yaml:"IssuingDeliveryUnit,omitempty"`
	ReceivingDeliveryUnit     null.String `boil:"ReceivingDeliveryUnit" json:"ReceivingDeliveryUnit,omitempty" toml:"ReceivingDeliveryUnit" yaml:"ReceivingDeliveryUnit,omitempty"`
	IssuingStorageLocation    null.String `boil:"IssuingStorageLocation" json:"IssuingStorageLocation,omitempty" toml:"IssuingStorageLocation" yaml:"IssuingStorageLocation,omitempty"`
	ReceivingStorageLocation  null.String `boil:"ReceivingStorageLocation" json:"ReceivingStorageLocation,omitempty" toml:"ReceivingStorageLocation" yaml:"ReceivingStorageLocation,omitempty"`
	AvailabilityCheckType     null.String `boil:"AvailabilityCheckType" json:"AvailabilityCheckType,omitempty" toml:"AvailabilityCheckType" yaml:"AvailabilityCheckType,omitempty"`
	ProfitCenter              null.String `boil:"ProfitCenter" json:"ProfitCenter,omitempty" toml:"ProfitCenter" yaml:"ProfitCenter,omitempty"`
	GoodsReceiptDuration      null.Int    `boil:"GoodsReceiptDuration" json:"GoodsReceiptDuration,omitempty" toml:"GoodsReceiptDuration" yaml:"GoodsReceiptDuration,omitempty"`
	MRPType                   null.String `boil:"MRPType" json:"MRPType,omitempty" toml:"MRPType" yaml:"MRPType,omitempty"`
	MRPResponsible            null.String `boil:"MRPResponsible" json:"MRPResponsible,omitempty" toml:"MRPResponsible" yaml:"MRPResponsible,omitempty"`
	MinimumLotSizeQuantity    null.String `boil:"MinimumLotSizeQuantity" json:"MinimumLotSizeQuantity,omitempty" toml:"MinimumLotSizeQuantity" yaml:"MinimumLotSizeQuantity,omitempty"`
	MaximumLotSizeQuantity    null.String `boil:"MaximumLotSizeQuantity" json:"MaximumLotSizeQuantity,omitempty" toml:"MaximumLotSizeQuantity" yaml:"MaximumLotSizeQuantity,omitempty"`
	FixedLotSizeQuantity      null.String `boil:"FixedLotSizeQuantity" json:"FixedLotSizeQuantity,omitempty" toml:"FixedLotSizeQuantity" yaml:"FixedLotSizeQuantity,omitempty"`
	IsBatchManagementRequired null.Bool   `boil:"IsBatchManagementRequired" json:"IsBatchManagementRequired,omitempty" toml:"IsBatchManagementRequired" yaml:"IsBatchManagementRequired,omitempty"`
	BatchManagementPolicy     null.String `boil:"BatchManagementPolicy" json:"BatchManagementPolicy,omitempty" toml:"BatchManagementPolicy" yaml:"BatchManagementPolicy,omitempty"`
	ProcurementType           null.String `boil:"ProcurementType" json:"ProcurementType,omitempty" toml:"ProcurementType" yaml:"ProcurementType,omitempty"`
	InventoryUnit             null.String `boil:"InventoryUnit" json:"InventoryUnit,omitempty" toml:"InventoryUnit" yaml:"InventoryUnit,omitempty"`
	IsMarkedForDeletion       null.Bool   `boil:"IsMarkedForDeletion" json:"IsMarkedForDeletion,omitempty" toml:"IsMarkedForDeletion" yaml:"IsMarkedForDeletion,omitempty"`

	R *dataPlatformProductMasterBPPlantDatumR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L dataPlatformProductMasterBPPlantDatumL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DataPlatformProductMasterBPPlantDatumColumns = struct {
	Product                   string
	BusinessPartner           string
	Plant                     string
	Issuable                  string
	Receivable                string
	IssuingDeliveryUnit       string
	ReceivingDeliveryUnit     string
	IssuingStorageLocation    string
	ReceivingStorageLocation  string
	AvailabilityCheckType     string
	ProfitCenter              string
	GoodsReceiptDuration      string
	MRPType                   string
	MRPResponsible            string
	MinimumLotSizeQuantity    string
	MaximumLotSizeQuantity    string
	FixedLotSizeQuantity      string
	IsBatchManagementRequired string
	BatchManagementPolicy     string
	ProcurementType           string
	InventoryUnit             string
	IsMarkedForDeletion       string
}{
	Product:                   "Product",
	BusinessPartner:           "BusinessPartner",
	Plant:                     "Plant",
	Issuable:                  "Issuable",
	Receivable:                "Receivable",
	IssuingDeliveryUnit:       "IssuingDeliveryUnit",
	ReceivingDeliveryUnit:     "ReceivingDeliveryUnit",
	IssuingStorageLocation:    "IssuingStorageLocation",
	ReceivingStorageLocation:  "ReceivingStorageLocation",
	AvailabilityCheckType:     "AvailabilityCheckType",
	ProfitCenter:              "ProfitCenter",
	GoodsReceiptDuration:      "GoodsReceiptDuration",
	MRPType:                   "MRPType",
	MRPResponsible:            "MRPResponsible",
	MinimumLotSizeQuantity:    "MinimumLotSizeQuantity",
	MaximumLotSizeQuantity:    "MaximumLotSizeQuantity",
	FixedLotSizeQuantity:      "FixedLotSizeQuantity",
	IsBatchManagementRequired: "IsBatchManagementRequired",
	BatchManagementPolicy:     "BatchManagementPolicy",
	ProcurementType:           "ProcurementType",
	InventoryUnit:             "InventoryUnit",
	IsMarkedForDeletion:       "IsMarkedForDeletion",
}

var DataPlatformProductMasterBPPlantDatumTableColumns = struct {
	Product                   string
	BusinessPartner           string
	Plant                     string
	Issuable                  string
	Receivable                string
	IssuingDeliveryUnit       string
	ReceivingDeliveryUnit     string
	IssuingStorageLocation    string
	ReceivingStorageLocation  string
	AvailabilityCheckType     string
	ProfitCenter              string
	GoodsReceiptDuration      string
	MRPType                   string
	MRPResponsible            string
	MinimumLotSizeQuantity    string
	MaximumLotSizeQuantity    string
	FixedLotSizeQuantity      string
	IsBatchManagementRequired string
	BatchManagementPolicy     string
	ProcurementType           string
	InventoryUnit             string
	IsMarkedForDeletion       string
}{
	Product:                   "data_platform_product_master_bp_plant_data.Product",
	BusinessPartner:           "data_platform_product_master_bp_plant_data.BusinessPartner",
	Plant:                     "data_platform_product_master_bp_plant_data.Plant",
	Issuable:                  "data_platform_product_master_bp_plant_data.Issuable",
	Receivable:                "data_platform_product_master_bp_plant_data.Receivable",
	IssuingDeliveryUnit:       "data_platform_product_master_bp_plant_data.IssuingDeliveryUnit",
	ReceivingDeliveryUnit:     "data_platform_product_master_bp_plant_data.ReceivingDeliveryUnit",
	IssuingStorageLocation:    "data_platform_product_master_bp_plant_data.IssuingStorageLocation",
	ReceivingStorageLocation:  "data_platform_product_master_bp_plant_data.ReceivingStorageLocation",
	AvailabilityCheckType:     "data_platform_product_master_bp_plant_data.AvailabilityCheckType",
	ProfitCenter:              "data_platform_product_master_bp_plant_data.ProfitCenter",
	GoodsReceiptDuration:      "data_platform_product_master_bp_plant_data.GoodsReceiptDuration",
	MRPType:                   "data_platform_product_master_bp_plant_data.MRPType",
	MRPResponsible:            "data_platform_product_master_bp_plant_data.MRPResponsible",
	MinimumLotSizeQuantity:    "data_platform_product_master_bp_plant_data.MinimumLotSizeQuantity",
	MaximumLotSizeQuantity:    "data_platform_product_master_bp_plant_data.MaximumLotSizeQuantity",
	FixedLotSizeQuantity:      "data_platform_product_master_bp_plant_data.FixedLotSizeQuantity",
	IsBatchManagementRequired: "data_platform_product_master_bp_plant_data.IsBatchManagementRequired",
	BatchManagementPolicy:     "data_platform_product_master_bp_plant_data.BatchManagementPolicy",
	ProcurementType:           "data_platform_product_master_bp_plant_data.ProcurementType",
	InventoryUnit:             "data_platform_product_master_bp_plant_data.InventoryUnit",
	IsMarkedForDeletion:       "data_platform_product_master_bp_plant_data.IsMarkedForDeletion",
}

// Generated where

var DataPlatformProductMasterBPPlantDatumWhere = struct {
	Product                   whereHelperstring
	BusinessPartner           whereHelperint
	Plant                     whereHelperstring
	Issuable                  whereHelpernull_Bool
	Receivable                whereHelpernull_Bool
	IssuingDeliveryUnit       whereHelpernull_String
	ReceivingDeliveryUnit     whereHelpernull_String
	IssuingStorageLocation    whereHelpernull_String
	ReceivingStorageLocation  whereHelpernull_String
	AvailabilityCheckType     whereHelpernull_String
	ProfitCenter              whereHelpernull_String
	GoodsReceiptDuration      whereHelpernull_Int
	MRPType                   whereHelpernull_String
	MRPResponsible            whereHelpernull_String
	MinimumLotSizeQuantity    whereHelpernull_String
	MaximumLotSizeQuantity    whereHelpernull_String
	FixedLotSizeQuantity      whereHelpernull_String
	IsBatchManagementRequired whereHelpernull_Bool
	BatchManagementPolicy     whereHelpernull_String
	ProcurementType           whereHelpernull_String
	InventoryUnit             whereHelpernull_String
	IsMarkedForDeletion       whereHelpernull_Bool
}{
	Product:                   whereHelperstring{field: "`data_platform_product_master_bp_plant_data`.`Product`"},
	BusinessPartner:           whereHelperint{field: "`data_platform_product_master_bp_plant_data`.`BusinessPartner`"},
	Plant:                     whereHelperstring{field: "`data_platform_product_master_bp_plant_data`.`Plant`"},
	Issuable:                  whereHelpernull_Bool{field: "`data_platform_product_master_bp_plant_data`.`Issuable`"},
	Receivable:                whereHelpernull_Bool{field: "`data_platform_product_master_bp_plant_data`.`Receivable`"},
	IssuingDeliveryUnit:       whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`IssuingDeliveryUnit`"},
	ReceivingDeliveryUnit:     whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`ReceivingDeliveryUnit`"},
	IssuingStorageLocation:    whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`IssuingStorageLocation`"},
	ReceivingStorageLocation:  whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`ReceivingStorageLocation`"},
	AvailabilityCheckType:     whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`AvailabilityCheckType`"},
	ProfitCenter:              whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`ProfitCenter`"},
	GoodsReceiptDuration:      whereHelpernull_Int{field: "`data_platform_product_master_bp_plant_data`.`GoodsReceiptDuration`"},
	MRPType:                   whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`MRPType`"},
	MRPResponsible:            whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`MRPResponsible`"},
	MinimumLotSizeQuantity:    whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`MinimumLotSizeQuantity`"},
	MaximumLotSizeQuantity:    whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`MaximumLotSizeQuantity`"},
	FixedLotSizeQuantity:      whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`FixedLotSizeQuantity`"},
	IsBatchManagementRequired: whereHelpernull_Bool{field: "`data_platform_product_master_bp_plant_data`.`IsBatchManagementRequired`"},
	BatchManagementPolicy:     whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`BatchManagementPolicy`"},
	ProcurementType:           whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`ProcurementType`"},
	InventoryUnit:             whereHelpernull_String{field: "`data_platform_product_master_bp_plant_data`.`InventoryUnit`"},
	IsMarkedForDeletion:       whereHelpernull_Bool{field: "`data_platform_product_master_bp_plant_data`.`IsMarkedForDeletion`"},
}

// DataPlatformProductMasterBPPlantDatumRels is where relationship names are stored.
var DataPlatformProductMasterBPPlantDatumRels = struct {
	BusinessPartnerDataPlatformBusinessPartnerGeneralDatum         string
	InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum         string
	BusinessPartnerDataPlatformPlantStorageLocationDatum           string
	BusinessPartnerDataPlatformPlantGeneralDatum                   string
	ProductDataPlatformProductMasterGeneralDatum                   string
	IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum   string
	ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum string
}{
	BusinessPartnerDataPlatformBusinessPartnerGeneralDatum:         "BusinessPartnerDataPlatformBusinessPartnerGeneralDatum",
	InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum:         "InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum",
	BusinessPartnerDataPlatformPlantStorageLocationDatum:           "BusinessPartnerDataPlatformPlantStorageLocationDatum",
	BusinessPartnerDataPlatformPlantGeneralDatum:                   "BusinessPartnerDataPlatformPlantGeneralDatum",
	ProductDataPlatformProductMasterGeneralDatum:                   "ProductDataPlatformProductMasterGeneralDatum",
	IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum:   "IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum",
	ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: "ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum",
}

// dataPlatformProductMasterBPPlantDatumR is where relationships are stored.
type dataPlatformProductMasterBPPlantDatumR struct {
	BusinessPartnerDataPlatformBusinessPartnerGeneralDatum         *DataPlatformBusinessPartnerGeneralDatum   `boil:"BusinessPartnerDataPlatformBusinessPartnerGeneralDatum" json:"BusinessPartnerDataPlatformBusinessPartnerGeneralDatum" toml:"BusinessPartnerDataPlatformBusinessPartnerGeneralDatum" yaml:"BusinessPartnerDataPlatformBusinessPartnerGeneralDatum"`
	InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum         *DataPlatformQuantityUnitQuantityUnitDatum `boil:"InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	BusinessPartnerDataPlatformPlantStorageLocationDatum           *DataPlatformPlantStorageLocationDatum     `boil:"BusinessPartnerDataPlatformPlantStorageLocationDatum" json:"BusinessPartnerDataPlatformPlantStorageLocationDatum" toml:"BusinessPartnerDataPlatformPlantStorageLocationDatum" yaml:"BusinessPartnerDataPlatformPlantStorageLocationDatum"`
	BusinessPartnerDataPlatformPlantGeneralDatum                   *DataPlatformPlantGeneralDatum             `boil:"BusinessPartnerDataPlatformPlantGeneralDatum" json:"BusinessPartnerDataPlatformPlantGeneralDatum" toml:"BusinessPartnerDataPlatformPlantGeneralDatum" yaml:"BusinessPartnerDataPlatformPlantGeneralDatum"`
	ProductDataPlatformProductMasterGeneralDatum                   *DataPlatformProductMasterGeneralDatum     `boil:"ProductDataPlatformProductMasterGeneralDatum" json:"ProductDataPlatformProductMasterGeneralDatum" toml:"ProductDataPlatformProductMasterGeneralDatum" yaml:"ProductDataPlatformProductMasterGeneralDatum"`
	IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum   *DataPlatformQuantityUnitQuantityUnitDatum `boil:"IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum"`
	ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum *DataPlatformQuantityUnitQuantityUnitDatum `boil:"ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" json:"ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" toml:"ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum" yaml:"ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum"`
}

// NewStruct creates a new relationship struct
func (*dataPlatformProductMasterBPPlantDatumR) NewStruct() *dataPlatformProductMasterBPPlantDatumR {
	return &dataPlatformProductMasterBPPlantDatumR{}
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetBusinessPartnerDataPlatformBusinessPartnerGeneralDatum() *DataPlatformBusinessPartnerGeneralDatum {
	if r == nil {
		return nil
	}
	return r.BusinessPartnerDataPlatformBusinessPartnerGeneralDatum
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetBusinessPartnerDataPlatformPlantStorageLocationDatum() *DataPlatformPlantStorageLocationDatum {
	if r == nil {
		return nil
	}
	return r.BusinessPartnerDataPlatformPlantStorageLocationDatum
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetBusinessPartnerDataPlatformPlantGeneralDatum() *DataPlatformPlantGeneralDatum {
	if r == nil {
		return nil
	}
	return r.BusinessPartnerDataPlatformPlantGeneralDatum
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetProductDataPlatformProductMasterGeneralDatum() *DataPlatformProductMasterGeneralDatum {
	if r == nil {
		return nil
	}
	return r.ProductDataPlatformProductMasterGeneralDatum
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum
}

func (r *dataPlatformProductMasterBPPlantDatumR) GetReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum() *DataPlatformQuantityUnitQuantityUnitDatum {
	if r == nil {
		return nil
	}
	return r.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum
}

// dataPlatformProductMasterBPPlantDatumL is where Load methods for each relationship are stored.
type dataPlatformProductMasterBPPlantDatumL struct{}

var (
	dataPlatformProductMasterBPPlantDatumAllColumns            = []string{"Product", "BusinessPartner", "Plant", "Issuable", "Receivable", "IssuingDeliveryUnit", "ReceivingDeliveryUnit", "IssuingStorageLocation", "ReceivingStorageLocation", "AvailabilityCheckType", "ProfitCenter", "GoodsReceiptDuration", "MRPType", "MRPResponsible", "MinimumLotSizeQuantity", "MaximumLotSizeQuantity", "FixedLotSizeQuantity", "IsBatchManagementRequired", "BatchManagementPolicy", "ProcurementType", "InventoryUnit", "IsMarkedForDeletion"}
	dataPlatformProductMasterBPPlantDatumColumnsWithoutDefault = []string{"Product", "BusinessPartner", "Plant", "Issuable", "Receivable", "IssuingDeliveryUnit", "ReceivingDeliveryUnit", "IssuingStorageLocation", "ReceivingStorageLocation", "AvailabilityCheckType", "ProfitCenter", "GoodsReceiptDuration", "MRPType", "MRPResponsible", "MinimumLotSizeQuantity", "MaximumLotSizeQuantity", "FixedLotSizeQuantity", "IsBatchManagementRequired", "BatchManagementPolicy", "ProcurementType", "InventoryUnit", "IsMarkedForDeletion"}
	dataPlatformProductMasterBPPlantDatumColumnsWithDefault    = []string{}
	dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns     = []string{"Product", "BusinessPartner", "Plant"}
	dataPlatformProductMasterBPPlantDatumGeneratedColumns      = []string{}
)

type (
	// DataPlatformProductMasterBPPlantDatumSlice is an alias for a slice of pointers to DataPlatformProductMasterBPPlantDatum.
	// This should almost always be used instead of []DataPlatformProductMasterBPPlantDatum.
	DataPlatformProductMasterBPPlantDatumSlice []*DataPlatformProductMasterBPPlantDatum
	// DataPlatformProductMasterBPPlantDatumHook is the signature for custom DataPlatformProductMasterBPPlantDatum hook methods
	DataPlatformProductMasterBPPlantDatumHook func(context.Context, boil.ContextExecutor, *DataPlatformProductMasterBPPlantDatum) error

	dataPlatformProductMasterBPPlantDatumQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	dataPlatformProductMasterBPPlantDatumType                 = reflect.TypeOf(&DataPlatformProductMasterBPPlantDatum{})
	dataPlatformProductMasterBPPlantDatumMapping              = queries.MakeStructMapping(dataPlatformProductMasterBPPlantDatumType)
	dataPlatformProductMasterBPPlantDatumPrimaryKeyMapping, _ = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns)
	dataPlatformProductMasterBPPlantDatumInsertCacheMut       sync.RWMutex
	dataPlatformProductMasterBPPlantDatumInsertCache          = make(map[string]insertCache)
	dataPlatformProductMasterBPPlantDatumUpdateCacheMut       sync.RWMutex
	dataPlatformProductMasterBPPlantDatumUpdateCache          = make(map[string]updateCache)
	dataPlatformProductMasterBPPlantDatumUpsertCacheMut       sync.RWMutex
	dataPlatformProductMasterBPPlantDatumUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var dataPlatformProductMasterBPPlantDatumAfterSelectHooks []DataPlatformProductMasterBPPlantDatumHook

var dataPlatformProductMasterBPPlantDatumBeforeInsertHooks []DataPlatformProductMasterBPPlantDatumHook
var dataPlatformProductMasterBPPlantDatumAfterInsertHooks []DataPlatformProductMasterBPPlantDatumHook

var dataPlatformProductMasterBPPlantDatumBeforeUpdateHooks []DataPlatformProductMasterBPPlantDatumHook
var dataPlatformProductMasterBPPlantDatumAfterUpdateHooks []DataPlatformProductMasterBPPlantDatumHook

var dataPlatformProductMasterBPPlantDatumBeforeDeleteHooks []DataPlatformProductMasterBPPlantDatumHook
var dataPlatformProductMasterBPPlantDatumAfterDeleteHooks []DataPlatformProductMasterBPPlantDatumHook

var dataPlatformProductMasterBPPlantDatumBeforeUpsertHooks []DataPlatformProductMasterBPPlantDatumHook
var dataPlatformProductMasterBPPlantDatumAfterUpsertHooks []DataPlatformProductMasterBPPlantDatumHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *DataPlatformProductMasterBPPlantDatum) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range dataPlatformProductMasterBPPlantDatumAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDataPlatformProductMasterBPPlantDatumHook registers your hook function for all future operations.
func AddDataPlatformProductMasterBPPlantDatumHook(hookPoint boil.HookPoint, dataPlatformProductMasterBPPlantDatumHook DataPlatformProductMasterBPPlantDatumHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		dataPlatformProductMasterBPPlantDatumAfterSelectHooks = append(dataPlatformProductMasterBPPlantDatumAfterSelectHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.BeforeInsertHook:
		dataPlatformProductMasterBPPlantDatumBeforeInsertHooks = append(dataPlatformProductMasterBPPlantDatumBeforeInsertHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.AfterInsertHook:
		dataPlatformProductMasterBPPlantDatumAfterInsertHooks = append(dataPlatformProductMasterBPPlantDatumAfterInsertHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.BeforeUpdateHook:
		dataPlatformProductMasterBPPlantDatumBeforeUpdateHooks = append(dataPlatformProductMasterBPPlantDatumBeforeUpdateHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.AfterUpdateHook:
		dataPlatformProductMasterBPPlantDatumAfterUpdateHooks = append(dataPlatformProductMasterBPPlantDatumAfterUpdateHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.BeforeDeleteHook:
		dataPlatformProductMasterBPPlantDatumBeforeDeleteHooks = append(dataPlatformProductMasterBPPlantDatumBeforeDeleteHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.AfterDeleteHook:
		dataPlatformProductMasterBPPlantDatumAfterDeleteHooks = append(dataPlatformProductMasterBPPlantDatumAfterDeleteHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.BeforeUpsertHook:
		dataPlatformProductMasterBPPlantDatumBeforeUpsertHooks = append(dataPlatformProductMasterBPPlantDatumBeforeUpsertHooks, dataPlatformProductMasterBPPlantDatumHook)
	case boil.AfterUpsertHook:
		dataPlatformProductMasterBPPlantDatumAfterUpsertHooks = append(dataPlatformProductMasterBPPlantDatumAfterUpsertHooks, dataPlatformProductMasterBPPlantDatumHook)
	}
}

// One returns a single dataPlatformProductMasterBPPlantDatum record from the query.
func (q dataPlatformProductMasterBPPlantDatumQuery) One(ctx context.Context, exec boil.ContextExecutor) (*DataPlatformProductMasterBPPlantDatum, error) {
	o := &DataPlatformProductMasterBPPlantDatum{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for data_platform_product_master_bp_plant_data")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all DataPlatformProductMasterBPPlantDatum records from the query.
func (q dataPlatformProductMasterBPPlantDatumQuery) All(ctx context.Context, exec boil.ContextExecutor) (DataPlatformProductMasterBPPlantDatumSlice, error) {
	var o []*DataPlatformProductMasterBPPlantDatum

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to DataPlatformProductMasterBPPlantDatum slice")
	}

	if len(dataPlatformProductMasterBPPlantDatumAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all DataPlatformProductMasterBPPlantDatum records in the query.
func (q dataPlatformProductMasterBPPlantDatumQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count data_platform_product_master_bp_plant_data rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q dataPlatformProductMasterBPPlantDatumQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if data_platform_product_master_bp_plant_data exists")
	}

	return count > 0, nil
}

// BusinessPartnerDataPlatformBusinessPartnerGeneralDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) BusinessPartnerDataPlatformBusinessPartnerGeneralDatum(mods ...qm.QueryMod) dataPlatformBusinessPartnerGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.BusinessPartner),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformBusinessPartnerGeneralData(queryMods...)
}

// InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.InventoryUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// BusinessPartnerDataPlatformPlantStorageLocationDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) BusinessPartnerDataPlatformPlantStorageLocationDatum(mods ...qm.QueryMod) dataPlatformPlantStorageLocationDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.BusinessPartner),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantStorageLocationData(queryMods...)
}

// BusinessPartnerDataPlatformPlantGeneralDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) BusinessPartnerDataPlatformPlantGeneralDatum(mods ...qm.QueryMod) dataPlatformPlantGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`BusinessPartner` = ?", o.BusinessPartner),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformPlantGeneralData(queryMods...)
}

// ProductDataPlatformProductMasterGeneralDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) ProductDataPlatformProductMasterGeneralDatum(mods ...qm.QueryMod) dataPlatformProductMasterGeneralDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`Product` = ?", o.Product),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformProductMasterGeneralData(queryMods...)
}

// IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.IssuingDeliveryUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum pointed to by the foreign key.
func (o *DataPlatformProductMasterBPPlantDatum) ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(mods ...qm.QueryMod) dataPlatformQuantityUnitQuantityUnitDatumQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`QuantityUnit` = ?", o.ReceivingDeliveryUnit),
	}

	queryMods = append(queryMods, mods...)

	return DataPlatformQuantityUnitQuantityUnitData(queryMods...)
}

// LoadBusinessPartnerDataPlatformBusinessPartnerGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadBusinessPartnerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		args = append(args, object.BusinessPartner)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if a == obj.BusinessPartner {
					continue Outer
				}
			}

			args = append(args, obj.BusinessPartner)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_business_partner_general_data`),
		qm.WhereIn(`data_platform_business_partner_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformBusinessPartnerGeneralDatum")
	}

	var resultSlice []*DataPlatformBusinessPartnerGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformBusinessPartnerGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_business_partner_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_business_partner_general_data")
	}

	if len(dataPlatformBusinessPartnerGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BusinessPartnerDataPlatformBusinessPartnerGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
		}
		foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BusinessPartner == foreign.BusinessPartner {
				local.R.BusinessPartnerDataPlatformBusinessPartnerGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformBusinessPartnerGeneralDatumR{}
				}
				foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// LoadInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		if !queries.IsNil(object.InventoryUnit) {
			args = append(args, object.InventoryUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InventoryUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InventoryUnit) {
				args = append(args, obj.InventoryUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(dataPlatformQuantityUnitQuantityUnitDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
		}
		foreign.R.InventoryUnitDataPlatformProductMasterBPPlantData = append(foreign.R.InventoryUnitDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InventoryUnit, foreign.QuantityUnit) {
				local.R.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
				}
				foreign.R.InventoryUnitDataPlatformProductMasterBPPlantData = append(foreign.R.InventoryUnitDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// LoadBusinessPartnerDataPlatformPlantStorageLocationDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadBusinessPartnerDataPlatformPlantStorageLocationDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		args = append(args, object.BusinessPartner)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if a == obj.BusinessPartner {
					continue Outer
				}
			}

			args = append(args, obj.BusinessPartner)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_storage_location_data`),
		qm.WhereIn(`data_platform_plant_storage_location_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantStorageLocationDatum")
	}

	var resultSlice []*DataPlatformPlantStorageLocationDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantStorageLocationDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_storage_location_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_storage_location_data")
	}

	if len(dataPlatformPlantStorageLocationDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BusinessPartnerDataPlatformPlantStorageLocationDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformPlantStorageLocationDatumR{}
		}
		foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BusinessPartner == foreign.BusinessPartner {
				local.R.BusinessPartnerDataPlatformPlantStorageLocationDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformPlantStorageLocationDatumR{}
				}
				foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// LoadBusinessPartnerDataPlatformPlantGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadBusinessPartnerDataPlatformPlantGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		args = append(args, object.BusinessPartner)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if a == obj.BusinessPartner {
					continue Outer
				}
			}

			args = append(args, obj.BusinessPartner)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_plant_general_data`),
		qm.WhereIn(`data_platform_plant_general_data.BusinessPartner in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformPlantGeneralDatum")
	}

	var resultSlice []*DataPlatformPlantGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformPlantGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_plant_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_plant_general_data")
	}

	if len(dataPlatformPlantGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BusinessPartnerDataPlatformPlantGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformPlantGeneralDatumR{}
		}
		foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.BusinessPartner == foreign.BusinessPartner {
				local.R.BusinessPartnerDataPlatformPlantGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformPlantGeneralDatumR{}
				}
				foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(foreign.R.BusinessPartnerDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// LoadProductDataPlatformProductMasterGeneralDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadProductDataPlatformProductMasterGeneralDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		args = append(args, object.Product)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if a == obj.Product {
					continue Outer
				}
			}

			args = append(args, obj.Product)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_product_master_general_data`),
		qm.WhereIn(`data_platform_product_master_general_data.Product in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformProductMasterGeneralDatum")
	}

	var resultSlice []*DataPlatformProductMasterGeneralDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformProductMasterGeneralDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_product_master_general_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_product_master_general_data")
	}

	if len(dataPlatformProductMasterGeneralDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ProductDataPlatformProductMasterGeneralDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformProductMasterGeneralDatumR{}
		}
		foreign.R.ProductDataPlatformProductMasterBPPlantData = append(foreign.R.ProductDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Product == foreign.Product {
				local.R.ProductDataPlatformProductMasterGeneralDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformProductMasterGeneralDatumR{}
				}
				foreign.R.ProductDataPlatformProductMasterBPPlantData = append(foreign.R.ProductDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// LoadIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		if !queries.IsNil(object.IssuingDeliveryUnit) {
			args = append(args, object.IssuingDeliveryUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.IssuingDeliveryUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.IssuingDeliveryUnit) {
				args = append(args, obj.IssuingDeliveryUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(dataPlatformQuantityUnitQuantityUnitDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
		}
		foreign.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData = append(foreign.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.IssuingDeliveryUnit, foreign.QuantityUnit) {
				local.R.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
				}
				foreign.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData = append(foreign.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// LoadReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (dataPlatformProductMasterBPPlantDatumL) LoadReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDataPlatformProductMasterBPPlantDatum interface{}, mods queries.Applicator) error {
	var slice []*DataPlatformProductMasterBPPlantDatum
	var object *DataPlatformProductMasterBPPlantDatum

	if singular {
		var ok bool
		object, ok = maybeDataPlatformProductMasterBPPlantDatum.(*DataPlatformProductMasterBPPlantDatum)
		if !ok {
			object = new(DataPlatformProductMasterBPPlantDatum)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	} else {
		s, ok := maybeDataPlatformProductMasterBPPlantDatum.(*[]*DataPlatformProductMasterBPPlantDatum)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDataPlatformProductMasterBPPlantDatum)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDataPlatformProductMasterBPPlantDatum))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &dataPlatformProductMasterBPPlantDatumR{}
		}
		if !queries.IsNil(object.ReceivingDeliveryUnit) {
			args = append(args, object.ReceivingDeliveryUnit)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &dataPlatformProductMasterBPPlantDatumR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ReceivingDeliveryUnit) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ReceivingDeliveryUnit) {
				args = append(args, obj.ReceivingDeliveryUnit)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_platform_quantity_unit_quantity_unit_data`),
		qm.WhereIn(`data_platform_quantity_unit_quantity_unit_data.QuantityUnit in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataPlatformQuantityUnitQuantityUnitDatum")
	}

	var resultSlice []*DataPlatformQuantityUnitQuantityUnitDatum
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataPlatformQuantityUnitQuantityUnitDatum")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_platform_quantity_unit_quantity_unit_data")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_platform_quantity_unit_quantity_unit_data")
	}

	if len(dataPlatformQuantityUnitQuantityUnitDatumAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
		if foreign.R == nil {
			foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
		}
		foreign.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData = append(foreign.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ReceivingDeliveryUnit, foreign.QuantityUnit) {
				local.R.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = foreign
				if foreign.R == nil {
					foreign.R = &dataPlatformQuantityUnitQuantityUnitDatumR{}
				}
				foreign.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData = append(foreign.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData, local)
				break
			}
		}
	}

	return nil
}

// SetBusinessPartnerDataPlatformBusinessPartnerGeneralDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.BusinessPartnerDataPlatformBusinessPartnerGeneralDatum to related.
// Adds o to related.R.BusinessPartnerDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetBusinessPartnerDataPlatformBusinessPartnerGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformBusinessPartnerGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BusinessPartner"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BusinessPartner = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			BusinessPartnerDataPlatformBusinessPartnerGeneralDatum: related,
		}
	} else {
		o.R.BusinessPartnerDataPlatformBusinessPartnerGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformBusinessPartnerGeneralDatumR{
			BusinessPartnerDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(related.R.BusinessPartnerDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// SetInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
// Adds o to related.R.InventoryUnitDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"InventoryUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InventoryUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformQuantityUnitQuantityUnitDatumR{
			InventoryUnitDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.InventoryUnitDataPlatformProductMasterBPPlantData = append(related.R.InventoryUnitDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// RemoveInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformProductMasterBPPlantDatum) RemoveInventoryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.InventoryUnit, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("InventoryUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InventoryUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.InventoryUnitDataPlatformProductMasterBPPlantData {
		if queries.Equal(o.InventoryUnit, ri.InventoryUnit) {
			continue
		}

		ln := len(related.R.InventoryUnitDataPlatformProductMasterBPPlantData)
		if ln > 1 && i < ln-1 {
			related.R.InventoryUnitDataPlatformProductMasterBPPlantData[i] = related.R.InventoryUnitDataPlatformProductMasterBPPlantData[ln-1]
		}
		related.R.InventoryUnitDataPlatformProductMasterBPPlantData = related.R.InventoryUnitDataPlatformProductMasterBPPlantData[:ln-1]
		break
	}
	return nil
}

// SetBusinessPartnerDataPlatformPlantStorageLocationDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.BusinessPartnerDataPlatformPlantStorageLocationDatum to related.
// Adds o to related.R.BusinessPartnerDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetBusinessPartnerDataPlatformPlantStorageLocationDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantStorageLocationDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BusinessPartner"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BusinessPartner = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			BusinessPartnerDataPlatformPlantStorageLocationDatum: related,
		}
	} else {
		o.R.BusinessPartnerDataPlatformPlantStorageLocationDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformPlantStorageLocationDatumR{
			BusinessPartnerDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(related.R.BusinessPartnerDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// SetBusinessPartnerDataPlatformPlantGeneralDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.BusinessPartnerDataPlatformPlantGeneralDatum to related.
// Adds o to related.R.BusinessPartnerDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetBusinessPartnerDataPlatformPlantGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformPlantGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"BusinessPartner"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.BusinessPartner, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.BusinessPartner = related.BusinessPartner
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			BusinessPartnerDataPlatformPlantGeneralDatum: related,
		}
	} else {
		o.R.BusinessPartnerDataPlatformPlantGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformPlantGeneralDatumR{
			BusinessPartnerDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.BusinessPartnerDataPlatformProductMasterBPPlantData = append(related.R.BusinessPartnerDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// SetProductDataPlatformProductMasterGeneralDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.ProductDataPlatformProductMasterGeneralDatum to related.
// Adds o to related.R.ProductDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetProductDataPlatformProductMasterGeneralDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformProductMasterGeneralDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"Product"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.Product, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Product = related.Product
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			ProductDataPlatformProductMasterGeneralDatum: related,
		}
	} else {
		o.R.ProductDataPlatformProductMasterGeneralDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformProductMasterGeneralDatumR{
			ProductDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.ProductDataPlatformProductMasterBPPlantData = append(related.R.ProductDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// SetIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
// Adds o to related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"IssuingDeliveryUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.IssuingDeliveryUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformQuantityUnitQuantityUnitDatumR{
			IssuingDeliveryUnitDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData = append(related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// RemoveIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformProductMasterBPPlantDatum) RemoveIssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.IssuingDeliveryUnit, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("IssuingDeliveryUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.IssuingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData {
		if queries.Equal(o.IssuingDeliveryUnit, ri.IssuingDeliveryUnit) {
			continue
		}

		ln := len(related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData)
		if ln > 1 && i < ln-1 {
			related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData[i] = related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData[ln-1]
		}
		related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData = related.R.IssuingDeliveryUnitDataPlatformProductMasterBPPlantData[:ln-1]
		break
	}
	return nil
}

// SetReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum of the dataPlatformProductMasterBPPlantDatum to the related item.
// Sets o.R.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to related.
// Adds o to related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData.
func (o *DataPlatformProductMasterBPPlantDatum) SetReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"ReceivingDeliveryUnit"}),
		strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
	)
	values := []interface{}{related.QuantityUnit, o.Product, o.BusinessPartner, o.Plant}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ReceivingDeliveryUnit, related.QuantityUnit)
	if o.R == nil {
		o.R = &dataPlatformProductMasterBPPlantDatumR{
			ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum: related,
		}
	} else {
		o.R.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = related
	}

	if related.R == nil {
		related.R = &dataPlatformQuantityUnitQuantityUnitDatumR{
			ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData: DataPlatformProductMasterBPPlantDatumSlice{o},
		}
	} else {
		related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData = append(related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData, o)
	}

	return nil
}

// RemoveReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum relationship.
// Sets o.R.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DataPlatformProductMasterBPPlantDatum) RemoveReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum(ctx context.Context, exec boil.ContextExecutor, related *DataPlatformQuantityUnitQuantityUnitDatum) error {
	var err error

	queries.SetScanner(&o.ReceivingDeliveryUnit, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("ReceivingDeliveryUnit")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ReceivingDeliveryUnitDataPlatformQuantityUnitQuantityUnitDatum = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData {
		if queries.Equal(o.ReceivingDeliveryUnit, ri.ReceivingDeliveryUnit) {
			continue
		}

		ln := len(related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData)
		if ln > 1 && i < ln-1 {
			related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData[i] = related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData[ln-1]
		}
		related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData = related.R.ReceivingDeliveryUnitDataPlatformProductMasterBPPlantData[:ln-1]
		break
	}
	return nil
}

// DataPlatformProductMasterBPPlantData retrieves all the records using an executor.
func DataPlatformProductMasterBPPlantData(mods ...qm.QueryMod) dataPlatformProductMasterBPPlantDatumQuery {
	mods = append(mods, qm.From("`data_platform_product_master_bp_plant_data`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`data_platform_product_master_bp_plant_data`.*"})
	}

	return dataPlatformProductMasterBPPlantDatumQuery{q}
}

// FindDataPlatformProductMasterBPPlantDatum retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDataPlatformProductMasterBPPlantDatum(ctx context.Context, exec boil.ContextExecutor, product string, businessPartner int, plant string, selectCols ...string) (*DataPlatformProductMasterBPPlantDatum, error) {
	dataPlatformProductMasterBPPlantDatumObj := &DataPlatformProductMasterBPPlantDatum{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `data_platform_product_master_bp_plant_data` where `Product`=? AND `BusinessPartner`=? AND `Plant`=?", sel,
	)

	q := queries.Raw(query, product, businessPartner, plant)

	err := q.Bind(ctx, exec, dataPlatformProductMasterBPPlantDatumObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from data_platform_product_master_bp_plant_data")
	}

	if err = dataPlatformProductMasterBPPlantDatumObj.doAfterSelectHooks(ctx, exec); err != nil {
		return dataPlatformProductMasterBPPlantDatumObj, err
	}

	return dataPlatformProductMasterBPPlantDatumObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DataPlatformProductMasterBPPlantDatum) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_product_master_bp_plant_data provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformProductMasterBPPlantDatumColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	dataPlatformProductMasterBPPlantDatumInsertCacheMut.RLock()
	cache, cached := dataPlatformProductMasterBPPlantDatumInsertCache[key]
	dataPlatformProductMasterBPPlantDatumInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			dataPlatformProductMasterBPPlantDatumAllColumns,
			dataPlatformProductMasterBPPlantDatumColumnsWithDefault,
			dataPlatformProductMasterBPPlantDatumColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `data_platform_product_master_bp_plant_data` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `data_platform_product_master_bp_plant_data` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `data_platform_product_master_bp_plant_data` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into data_platform_product_master_bp_plant_data")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.Product,
		o.BusinessPartner,
		o.Plant,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_product_master_bp_plant_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformProductMasterBPPlantDatumInsertCacheMut.Lock()
		dataPlatformProductMasterBPPlantDatumInsertCache[key] = cache
		dataPlatformProductMasterBPPlantDatumInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the DataPlatformProductMasterBPPlantDatum.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DataPlatformProductMasterBPPlantDatum) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	dataPlatformProductMasterBPPlantDatumUpdateCacheMut.RLock()
	cache, cached := dataPlatformProductMasterBPPlantDatumUpdateCache[key]
	dataPlatformProductMasterBPPlantDatumUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			dataPlatformProductMasterBPPlantDatumAllColumns,
			dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update data_platform_product_master_bp_plant_data, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, append(wl, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update data_platform_product_master_bp_plant_data row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for data_platform_product_master_bp_plant_data")
	}

	if !cached {
		dataPlatformProductMasterBPPlantDatumUpdateCacheMut.Lock()
		dataPlatformProductMasterBPPlantDatumUpdateCache[key] = cache
		dataPlatformProductMasterBPPlantDatumUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q dataPlatformProductMasterBPPlantDatumQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for data_platform_product_master_bp_plant_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for data_platform_product_master_bp_plant_data")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DataPlatformProductMasterBPPlantDatumSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductMasterBPPlantDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `data_platform_product_master_bp_plant_data` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in dataPlatformProductMasterBPPlantDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all dataPlatformProductMasterBPPlantDatum")
	}
	return rowsAff, nil
}

var mySQLDataPlatformProductMasterBPPlantDatumUniqueColumns = []string{}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DataPlatformProductMasterBPPlantDatum) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no data_platform_product_master_bp_plant_data provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(dataPlatformProductMasterBPPlantDatumColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDataPlatformProductMasterBPPlantDatumUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	dataPlatformProductMasterBPPlantDatumUpsertCacheMut.RLock()
	cache, cached := dataPlatformProductMasterBPPlantDatumUpsertCache[key]
	dataPlatformProductMasterBPPlantDatumUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			dataPlatformProductMasterBPPlantDatumAllColumns,
			dataPlatformProductMasterBPPlantDatumColumnsWithDefault,
			dataPlatformProductMasterBPPlantDatumColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			dataPlatformProductMasterBPPlantDatumAllColumns,
			dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert data_platform_product_master_bp_plant_data, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`data_platform_product_master_bp_plant_data`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `data_platform_product_master_bp_plant_data` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for data_platform_product_master_bp_plant_data")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(dataPlatformProductMasterBPPlantDatumType, dataPlatformProductMasterBPPlantDatumMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for data_platform_product_master_bp_plant_data")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for data_platform_product_master_bp_plant_data")
	}

CacheNoHooks:
	if !cached {
		dataPlatformProductMasterBPPlantDatumUpsertCacheMut.Lock()
		dataPlatformProductMasterBPPlantDatumUpsertCache[key] = cache
		dataPlatformProductMasterBPPlantDatumUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single DataPlatformProductMasterBPPlantDatum record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DataPlatformProductMasterBPPlantDatum) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no DataPlatformProductMasterBPPlantDatum provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), dataPlatformProductMasterBPPlantDatumPrimaryKeyMapping)
	sql := "DELETE FROM `data_platform_product_master_bp_plant_data` WHERE `Product`=? AND `BusinessPartner`=? AND `Plant`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from data_platform_product_master_bp_plant_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for data_platform_product_master_bp_plant_data")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q dataPlatformProductMasterBPPlantDatumQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no dataPlatformProductMasterBPPlantDatumQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from data_platform_product_master_bp_plant_data")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for data_platform_product_master_bp_plant_data")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DataPlatformProductMasterBPPlantDatumSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(dataPlatformProductMasterBPPlantDatumBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductMasterBPPlantDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `data_platform_product_master_bp_plant_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from dataPlatformProductMasterBPPlantDatum slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for data_platform_product_master_bp_plant_data")
	}

	if len(dataPlatformProductMasterBPPlantDatumAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DataPlatformProductMasterBPPlantDatum) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDataPlatformProductMasterBPPlantDatum(ctx, exec, o.Product, o.BusinessPartner, o.Plant)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DataPlatformProductMasterBPPlantDatumSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DataPlatformProductMasterBPPlantDatumSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), dataPlatformProductMasterBPPlantDatumPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `data_platform_product_master_bp_plant_data`.* FROM `data_platform_product_master_bp_plant_data` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, dataPlatformProductMasterBPPlantDatumPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DataPlatformProductMasterBPPlantDatumSlice")
	}

	*o = slice

	return nil
}

// DataPlatformProductMasterBPPlantDatumExists checks if the DataPlatformProductMasterBPPlantDatum row exists.
func DataPlatformProductMasterBPPlantDatumExists(ctx context.Context, exec boil.ContextExecutor, product string, businessPartner int, plant string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `data_platform_product_master_bp_plant_data` where `Product`=? AND `BusinessPartner`=? AND `Plant`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, product, businessPartner, plant)
	}
	row := exec.QueryRowContext(ctx, sql, product, businessPartner, plant)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if data_platform_product_master_bp_plant_data exists")
	}

	return exists, nil
}

// Exists checks if the DataPlatformProductMasterBPPlantDatum row exists.
func (o *DataPlatformProductMasterBPPlantDatum) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DataPlatformProductMasterBPPlantDatumExists(ctx, exec, o.Product, o.BusinessPartner, o.Plant)
}
